#[BuildingPy] DO NOT EDIT THIS FILE. IT IS GENERATED FROM THE SOURCE CODE
import math
import sys
import os
#import requests
import json
from collections import defaultdict
import subprocess
import urllib
import time
import urllib.request
import string
import random
from typing import List, Tuple
import xml.etree.ElementTree as ET
from pathlib import Path
#import numpy as np
#import ezdxf
#from svg.path import parse_path





def find_in_list_of_list(mylist, char):
    for sub_list in mylist:
        if char in sub_list:
            return (mylist.index(sub_list))
    raise ValueError("'{char}' is not in list".format(char=char))

class generateID:
    def __init__(self) -> None:
        self.id = None
        self.object = None
        self.name = None
        self.generateID()

    def generateID(self) -> None:
        id = ""
        lengthID = 12
        random_source = string.ascii_uppercase + string.digits
        for x in range(lengthID):
            id += random.choice(random_source)

        id_list = list(id)
        self.id = f"#"+"".join(id_list)
        return f"test {self.__class__.__name__}"

    def __repr__(self) -> str:
        return f"{self.id}"


def findjson(id, json_string):
    #faster way to search in json
    results = []

    def _decode_dict(a_dict):
        try:
            results.append(a_dict[id])
        except KeyError:
            pass
        return a_dict

    json.loads(json_string, object_hook=_decode_dict) # Return value ignored.
    return results

def list_transpose(lst):
    #list of lists, transpose columns/rows
    newlist = list(map(list, zip(*lst)))
    return newlist

def is_null(lst):
    return all(el is None for el in lst)

def clean_list(input_list, preserve_indices=True):
    if not input_list:
        return input_list
    
    culled_list = []

    if preserve_indices:
        if is_null(input_list):
            return None
        
        j = len(input_list) - 1
        while j >= 0 and input_list[j] is None:
            j -= 1

        for i in range(j + 1):
            sublist = input_list[i]

            if isinstance(sublist, list):
                val = clean_list(sublist, preserve_indices)
                culled_list.append(val)
            else:
                culled_list.append(input_list[i])
    else:
        if is_null(input_list):
            return []
        
        for el in input_list:
            if isinstance(el, list):
                if not is_null(el):
                    val = clean_list(el, preserve_indices=False)
                    if val:
                        culled_list.append(val)
            elif el is not None:
                culled_list.append(el)
            
    return culled_list

def flatten(lst):
    if type(lst) != list:
        lst = [lst]
    flat_list = []
    for sublist in lst:
        try:
            for item in sublist:
                flat_list.append(item)
        except:
            flat_list.append(sublist)
    return flat_list

def all_true(lst):
    for element in lst:
        if not element:
            return False
    return True

def replace_at_index(object, index, new_object):
    if index < 0 or index >= len(object):
        raise IndexError("Index out of range")
    return object[:index] + new_object + object[index+1:]

def xmldata(myurl, xPathStrings):
    urlFile = urllib.request.urlopen(myurl)
    tree = ET.parse(urlFile)
    xPathResults = []
    for xPathString in xPathStrings:
        a = tree.findall(xPathString)
        xPathResulttemp2 = []
        for xPathResult in a:
            xPathResulttemp2.append(xPathResult.text)
        xPathResults.append(xPathResulttemp2)
    return xPathResults



class Vector3:
    def __init__(self, x, y, z):
        self.id = generateID()
        self.type = __class__.__name__
        self.x: float = 0.0
        self.y: float = 0.0
        self.z: float = 0.0

        self.x = x
        self.y = y
        self.z = z

    def serialize(self):
        id_value = str(self.id) if not isinstance(
            self.id, (str, int, float)) else self.id
        return {
            'id': id_value,
            'type': self.type,
            'x': self.x,
            'y': self.y,
            'z': self.z
        }

    @staticmethod
    def deserialize(data):
        return Vector3(data['x'], data['y'], data['z'])

    @staticmethod
    def sum(vector_1, vector_2):
        return Vector3(
            vector_1.x + vector_2.x,
            vector_1.y + vector_2.y,
            vector_1.z + vector_2.z
        )

    @staticmethod
    def sum3(vector_1, vector_2, vector_3):
        return Vector3(
            vector_1.x + vector_2.x + vector_3.x,
            vector_1.y + vector_2.y + vector_3.y,
            vector_1.z + vector_2.z + vector_3.z
        )

    @staticmethod
    def diff(vector_1, vector_2):
        return Vector3(
            vector_1.x - vector_2.x,
            vector_1.y - vector_2.y,
            vector_1.z - vector_2.z
        )

    @staticmethod
    def subtract(vector_1, vector_2):
        return Vector3(
            vector_1.x - vector_2.x,
            vector_1.y - vector_2.y,
            vector_1.z - vector_2.z
        )

    @staticmethod
    def divide(vector_1, vector_2):
        return Vector3(
            vector_1.x / vector_2.x,
            vector_1.y / vector_2.y,
            vector_1.z / vector_2.z
        )

    @staticmethod
    def square(vector_1):
        return Vector3(
            vector_1.x ** 2,
            vector_1.y ** 2,
            vector_1.z ** 2
        )

    @staticmethod
    def to_point(vector_1):
        return Point(x=vector_1.x, y=vector_1.y, z=vector_1.z)

    @staticmethod
    def to_line(vector_1, vector_2):
        return Line(start=Point(x=vector_1.x, y=vector_1.y, z=vector_1.z), end=Point(x=vector_2.x, y=vector_2.y, z=vector_2.z))

    @staticmethod
    def by_line(line_1):
        return Vector3(line_1.dx, line_1.dy, line_1.dz)

    @staticmethod
    def line_by_length(vector_1, length: float):
        return None
        # return Line(start = Point(x=vector_1.x,y=vector_1.y,z=vector_1.z), end = Point(x=vector_2.x,y=vector_2.y,z=vector_2.z))

    @staticmethod
    def cross_product(vector_1, vector_2):
        return Vector3(
            vector_1.y*vector_2.z - vector_1.z*vector_2.y,
            vector_1.z*vector_2.x - vector_1.x*vector_2.z,
            vector_1.x*vector_2.y - vector_1.y*vector_2.x
        )

    @staticmethod
    def dot_product(vector_1, vector_2):
        return vector_1.x*vector_2.x+vector_1.y*vector_2.y+vector_1.z*vector_2.z

    @staticmethod
    def product(number, vector_1):
        return Vector3(
            vector_1.x*number,
            vector_1.y*number,
            vector_1.z*number
        )

    @staticmethod
    def length(vector_1):
        return math.sqrt(vector_1.x*vector_1.x+vector_1.y*vector_1.y+vector_1.z*vector_1.z)

    @staticmethod
    def pitch(vector_1, angle):
        return Vector3(
            vector_1.x,
            vector_1.y*math.cos(angle) - vector_1.z*math.sin(angle),
            vector_1.y*math.sin(angle) + vector_1.z*math.cos(angle)
        )

    @staticmethod
    def angle_between(vector_1, vector_2):
        proj_vector_1 = Vector3.to_matrix(vector_1)
        proj_vector_2 = Vector3.to_matrix(vector_2)
        dot_product = Vector3.dot_product(vector_1, vector_2)
        length_vector_1 = Vector3.length(vector_1)
        length_vector_2 = Vector3.length(vector_2)

        if length_vector_1 == 0 or length_vector_2 == 0:
            return 0

        cos_angle = dot_product / (length_vector_1 * length_vector_2)
        cos_angle = max(-1.0, min(cos_angle, 1.0))
        angle = math.acos(cos_angle)
        return math.degrees(angle)

    @staticmethod
    def angle_radian_between(vector_1, vector_2):
        return math.acos((Vector3.dot_product(vector_1, vector_2)/(Vector3.length(vector_1)*Vector3.length(vector_2))))

    @staticmethod
    def angle_between_YZ(vector_1, vector_2):  # X Axis degrees
        dot_product = Vector3.dot_product(vector_1, vector_2)
        length_vector_1 = Vector3.length(Vector3(0, vector_1.y, vector_1.z))
        length_vector_2 = Vector3.length(Vector3(0, vector_2.y, vector_2.z))
        if length_vector_1 == 0 or length_vector_2 == 0:
            return 0

        cos_angle = dot_product / (length_vector_1 * length_vector_2)
        cos_angle = max(-1.0, min(cos_angle, 1.0))
        angle = math.acos(cos_angle)
        return math.degrees(angle)

    @staticmethod
    def angle_between_XZ(vector_1, vector_2):  # Y Axis degrees
        dot_product = Vector3.dot_product(vector_1, vector_2)
        length_vector_1 = Vector3.length(Vector3(vector_1.x, 0, vector_1.z))
        length_vector_2 = Vector3.length(Vector3(vector_2.x, 0, vector_2.z))

        if length_vector_1 == 0 or length_vector_2 == 0:
            return 0

        cos_angle = dot_product / (length_vector_1 * length_vector_2)
        cos_angle = max(-1.0, min(cos_angle, 1.0))
        angle = math.acos(cos_angle)
        return math.degrees(angle)

    @staticmethod
    def angle_between_XY(vector_1, vector_2):  # Z Axis degrees
        dot_product = Vector3.dot_product(vector_1, vector_2)
        length_vector_1 = Vector3.length(Vector3(vector_1.x, vector_1.y, 0))
        length_vector_2 = Vector3.length(Vector3(vector_2.x, vector_2.y, 0))

        if length_vector_1 == 0 or length_vector_2 == 0:
            return 0

        cos_angle = dot_product / (length_vector_1 * length_vector_2)
        cos_angle = max(-1.0, min(cos_angle, 1.0))
        angle = math.acos(cos_angle)
        return math.degrees(angle)

    @staticmethod
    def value(vector_1):
        roundValue = 4
        return (round(vector_1.x, roundValue), round(vector_1.y, roundValue), round(vector_1.z, roundValue))

    @staticmethod
    def reverse(vector_1):
        return Vector3(
            vector_1.x*-1,
            vector_1.y*-1,
            vector_1.z*-1
        )

    @staticmethod
    def perpendicular(vector_1):
        lokX = Vector3(vector_1.y, -vector_1.x, 0)
        lokZ = Vector3.cross_product(vector_1, lokX)
        if lokZ.z < 0:
            lokZ = Vector3.reverse(lokZ)
        return lokX, lokZ

    @staticmethod
    def normalize(vector_1):
        length = Vector3.length(vector_1)
        if length == 0:
            return Vector3(0, 0, 0)

        normalized_vector = Vector3(
            vector_1.x / length,
            vector_1.y / length,
            vector_1.z / length
        )

        return normalized_vector

    @staticmethod
    def by_two_points(p1, p2):
        return Vector3(
            p2.x-p1.x,
            p2.y-p1.y,
            p2.z-p1.z
        )

    @staticmethod
    def rotate_XY(vector_1, Beta):
        return Vector3(
            math.cos(Beta)*vector_1.x - math.sin(Beta)*vector_1.y,
            math.sin(Beta)*vector_1.x + math.cos(Beta)*vector_1.y,
            vector_1.z
        )

    @staticmethod
    def scale(vector_1, scalefactor):
        return Vector3(
            vector_1.x * scalefactor,
            vector_1.y * scalefactor,
            vector_1.z * scalefactor
        )

    @staticmethod
    def new_length(vector_1, newlength: float):
        scale = newlength / Vector3.length(vector_1)

        return Vector3.scale(vector_1, scale)

    @staticmethod
    def to_matrix(self):
        return [self.x, self.y, self.z]

    @staticmethod
    def from_matrix(self):
        return Vector3(
            self[0],
            self[1],
            self[2]
        )

    def __str__(self):
        return f"{__class__.__name__}(" + f"X = {self.x:.3f}, Y = {self.y:.3f}, Z = {self.z:.3f})"


XAxis = Vector3(1, 0, 0)

YAxis = Vector3(0, 1, 0)

ZAxis = Vector3(0, 0, 1)



# from project.fileformat import project


class Point:
    def __init__(self, x, y, z):
        self.id = generateID()
        self.type = __class__.__name__
        self.x: float = 0.0
        self.y: float = 0.0
        self.z: float = 0.0
        self.x = float(x)
        self.y = float(y)
        self.z = float(z)
        self.value = self.x, self.y, self.z
        self.units = "mm"

    def __str__(self) -> str:
        return f"{__class__.__name__}(X = {self.x:.3f}, Y = {self.y:.3f}, Z = {self.z:.3f})"

    def serialize(self):
        id_value = str(self.id) if not isinstance(
            self.id, (str, int, float)) else self.id
        return {
            'id': id_value,
            'type': self.type,
            'x': self.x,
            'y': self.y,
            'z': self.z,
            'value': self.value,
            'units': self.units
        }

    @staticmethod
    def deserialize(data):
        return Point(data['x'], data['y'], data['z'])

    @staticmethod
    def distance(point_1, point_2):
        return math.sqrt((point_1.x - point_2.x)**2 + (point_1.y - point_2.y)**2 + (point_1.z - point_2.z)**2)

    @staticmethod
    def calculate_distance(points: list) -> float:
        distances = []
        for i in range(len(points)):
            for j in range(i+1, len(points)):
                distances.append(
                    (points[i], points[j], Point.distance(points[i], points[j])))
        distances.sort(key=lambda x: x[2])
        return distances

    @staticmethod
    def difference(point_1, point_2):
        return Vector3(
            point_2.x - point_1.x,
            point_2.y - point_1.y,
            point_2.z - point_1.z
        )

    @staticmethod
    def translate(point, vector):

        ar1 = Point.to_matrix(point)
        ar2 = Vector3.to_matrix(vector)
        if len(ar1) == len(ar2):
            c = [ar1[i] + ar2[i] for i in range(len(ar1))]
        else:
            c = [0, 0, 0]
            raise ValueError("Arrays must have the same size")
        return Point(c[0], c[1], c[2])

    @staticmethod
    def origin(point_1, point_2):
        return Point(
            (point_1.x + point_2.x) / 2,
            (point_1.y + point_2.y) / 2,
            (point_1.z + point_2.z) / 2
        )

    @staticmethod
    def point_2D_to_3D(point_2D):
        return Point(
            point_2D.x,
            point_2D.y,
            0
        )

    @staticmethod
    def to_vector(point_1):
        return Vector3(
            point_1.x,
            point_1.y,
            point_1.z
        )

    @staticmethod
    def sum(point_1, point_2):
        return Point(
            point_1.x + point_2.x,
            point_1.y + point_2.y,
            point_1.z + point_2.z
        )

    @staticmethod
    def diff(point_1, point_2):
        return Point(
            point_1.x - point_2.x,
            point_1.y - point_2.y,
            point_1.z - point_2.z
        )

    @staticmethod
    def rotate_XY(point_1, beta, dz):
        return Point(
            math.cos(math.radians(beta))*point_1.x -
            math.sin(math.radians(beta))*point_1.y,
            math.sin(math.radians(beta))*point_1.x +
            math.cos(math.radians(beta))*point_1.y,
            point_1.z + dz
        )

    def product(number, point_1):  # Same as scale
        return Point(
            point_1.x*number,
            point_1.y*number,
            point_1.z*number
        )

    @staticmethod
    def intersect(point_1, point_2):
        # Intersection of two points
        if point_1.x == point_2.x and point_1.y == point_2.y and point_1.z == point_2.z:
            return 1
        else:
            return 0

    @staticmethod
    def to_matrix(self):
        return [self.x, self.y, self.z]

    @staticmethod
    def from_matrix(self):
        return Point(
            self[0],
            self[1],
            self[2]
        )


class CoordinateSystem:
    # UNITY VECTORS REQUIRED
    def __init__(self, origin: Point, xaxis, yaxis, zaxis):
        self.id = generateID()
        self.type = __class__.__name__
        self.Origin = origin
        self.Xaxis = Vector3.normalize(xaxis)
        self.Yaxis = Vector3.normalize(yaxis)
        self.Zaxis = Vector3.normalize(zaxis)

    @classmethod
    def by_origin(self, origin: Point):
        return self(origin, xaxis=XAxis, yaxis=YAxis, zaxis=ZAxis)

    @staticmethod
    def translate(CS_old, direction):
        new_origin = Point.translate(CS_old.Origin, direction)

        XAxis = Vector3(1, 0, 0)

        YAxis = Vector3(0, 1, 0)

        ZAxis = Vector3(0, 0, 1)

        CSNew = CoordinateSystem(
            new_origin, xaxis=XAxis, yaxis=YAxis, zaxis=ZAxis)

        CSNew.Origin = new_origin
        return CSNew

    def __str__(self):
        return f"{__class__.__name__}(Origin = " + f"{self.Origin}, XAxis = {self.Xaxis}, YAxis = {self.Yaxis}, ZAxis = {self.Zaxis})"

    @staticmethod
    def by_point_main_vector(self, new_origin_coordinatesystem: Point, DirectionVectorZ):
        vz = DirectionVectorZ  # LineVector and new Z-axis
        vz = Vector3.normalize(vz)  # NewZAxis
        vx = Vector3.perpendicular(vz)[0]  # NewXAxis
        try:
            vx = Vector3.normalize(vx)  # NewXAxisnormalized
        except:
            # In case of vertical element the length is zero
            vx = Vector3(1, 0, 0)
        vy = Vector3.perpendicular(vz)[1]  # NewYAxis
        try:
            vy = Vector3.normalize(vy)  # NewYAxisnormalized
        except:
            # In case of vertical element the length is zero
            vy = Vector3(0, 1, 0)
        CSNew = CoordinateSystem(new_origin_coordinatesystem, vx, vy, vz)
        return CSNew

    @staticmethod
    def move_local(CS_old, x: float, y: float, z: float):
        # move coordinatesystem by y in local coordinates(not global)
        xloc_vect_norm = CS_old.Xaxis
        xdisp = Vector3.scale(xloc_vect_norm, x)
        yloc_vect_norm = CS_old.Xaxis
        ydisp = Vector3.scale(yloc_vect_norm, y)
        zloc_vect_norm = CS_old.Xaxis
        zdisp = Vector3.scale(zloc_vect_norm, z)
        disp = Vector3.sum3(xdisp, ydisp, zdisp)
        CS = CoordinateSystem.translate(CS_old, disp)
        return CS

    @staticmethod
    def translate_origin(origin1, origin2):

        origin1_n = Point.to_matrix(origin1)
        origin2_n = Point.to_matrix(origin2)

        new_origin_n = origin1_n + (origin2_n - origin1_n)
        return Point(new_origin_n[0], new_origin_n[1], new_origin_n[2])

    @staticmethod
    def calculate_rotation_matrix(xaxis_1, yaxis_1, zaxis_1, xaxis_2, yaxis_2, zaxis_2):

        R1 = [Vector3.to_matrix(xaxis_1), Vector3.to_matrix(
            yaxis_1), Vector3.to_matrix(zaxis_1)]

        R2 = [Vector3.to_matrix(xaxis_2), Vector3.to_matrix(
            yaxis_2), Vector3.to_matrix(zaxis_2)]

        R1_transposed = list(map(list, zip(*R1)))
        R2_transposed = list(map(list, zip(*R2)))

        rotation_matrix = Vector3.dot_product(Vector3.from_matrix(
            R2_transposed), Vector3.length(Vector3.from_matrix(R1_transposed)))
        return rotation_matrix

    @staticmethod
    def normalize(v):
        norm = (v[0]**2 + v[1]**2 + v[2]**2)**0.5
        return [v[0] / norm, v[1] / norm, v[2] / norm] if norm > 0 else v


def transform_point(point_local, coordinate_system_old, new_origin, direction_vector):

    direction_vector = Vector3.to_matrix(direction_vector)
    new_origin = Point.to_matrix(new_origin)
    vz_norm = Vector3.length(Vector3(*direction_vector))
    vz = [direction_vector[0] / vz_norm, direction_vector[1] /
          vz_norm, direction_vector[2] / vz_norm]

    vx = [-vz[1], vz[0], 0]
    vx_norm = Vector3.length(Vector3(*vx))

    if vx_norm == 0:
        vx = [1, 0, 0]
    else:
        vx = [vx[0] / vx_norm, vx[1] / vx_norm, vx[2] / vx_norm]

    vy = Vector3.cross_product(Vector3(*vz), Vector3(*vx))
    vy_norm = Vector3.length(vy)
    if vy_norm != 0:
        vy = [vy.x / vy_norm, vy.y / vy_norm, vy.z / vy_norm]
    else:
        vy = [0, 1, 0]

    point_1 = point_local
    CSNew = CoordinateSystem(Point.from_matrix(new_origin), Vector3.from_matrix(
        vx), Vector3.from_matrix(vy), Vector3.from_matrix(vz))
    v1 = Point.difference(coordinate_system_old.Origin, CSNew.Origin)

    v2 = Vector3.product(point_1.x, CSNew.Xaxis)
    v3 = Vector3.product(point_1.y, CSNew.Yaxis)
    v4 = Vector3.product(point_1.z, CSNew.Zaxis)
    vtot = Vector3(v1.x + v2.x + v3.x + v4.x, v1.y + v2.y +
                   v3.y + v4.y, v1.z + v2.z + v3.z + v4.z)
    pointNew = Point.translate(Point(0, 0, 0), vtot)

    return pointNew


def transform_point_2(PointLocal: Point, CoordinateSystemNew: CoordinateSystem):
    pn = Point.translate(CoordinateSystemNew.Origin, Vector3.scale(
        CoordinateSystemNew.Xaxis, PointLocal.x))
    pn2 = Point.translate(pn, Vector3.scale(
        CoordinateSystemNew.Yaxis, PointLocal.y))
    pn3 = Point.translate(pn2, Vector3.scale(
        CoordinateSystemNew.Zaxis, PointLocal.z))
    return pn3


class BuildingPy:
    def __init__(self, name=None, number=None):
        self.name: str = name
        self.number: str = number
        self.debug: bool = True
        self.objects = []
        self.units = "mm"
        self.decimals = 3 #not fully implemented yet
        self.origin = Point(0,0,0)
        self.default_font = "calibri"
        self.scale = 1000
        self.font_height = 500
        self.repr_round = 3
        #prefix objects (name)
        #Geometry settings

        #export selection info
        self.domain = None
        self.applicationId = "OPEN-AEC | BuildingPy"

        #different settings for company's?

        #rename this to autoclose?
        self.closed: bool = True #auto close polygons? By default true, else overwrite
        self.round: bool = False #If True then arcs will be segmented. Can be used in Speckle.

        #functie polycurve of iets van een class/def
        self.autoclose: bool = True #new self.closed

        #nodes
        self.node_merge = True #False not yet created
        self.node_diameter = 250
        self.node_threshold = 50
        
        #text
        self.createdTxt = "has been created"

        #structural elements
        self.structural_fallback_element = "HEA100"

        #Speckle settings
        self.speckleserver = "speckle.xyz"
        self.specklestream = None

        #FreeCAD settings

        XAxis = Vector3(1, 0, 0)
        YAxis = Vector3(0, 1, 0)
        ZAxis = Vector3(0, 0, 1)
        self.CSGlobal = CoordinateSystem(Point(0, 0, 0), XAxis, YAxis, ZAxis)
        
    def save(self):
        # print(self.objects)
        serialized_objects = []
        for obj in self.objects:
            try:
                # print(obj)
                serialized_objects.append(json.dumps(obj.serialize()))
            except:
                print(obj)

        serialized_data = json.dumps(serialized_objects)
        file_name = 'project/data.json'
        with open(file_name, 'w') as file:
            file.write(serialized_data)


        type_count = defaultdict(int)
        for serialized_item in serialized_objects:
            item = json.loads(serialized_item)
            item_type = item.get("type")
            if item_type:
                type_count[item_type] += 1

        total_items = len(serialized_objects)

        print(f"\nTotal saved items to '{file_name}': {total_items}")
        print("Type counts:")
        for item_type, count in type_count.items():
            print(f"{item_type}: {count}")

    def open(self):
        pass  # open data.json objects in here

    def toSpeckle(self, streamid, commitstring=None):
        self.specklestream = streamid
        speckleobj = translateObjectsToSpeckleObjects(self.objects)
        TransportToSpeckle(self.speckleserver,streamid,speckleobj,commitstring)

    def toFreeCAD(self):
        translateObjectsToFreeCAD(self.objects)

    def toIFC(self):
        translateObjectsToIFC(self.objects)




project = BuildingPy("Project", "0")




class CoordinateSystem:
    # UNITY VECTORS REQUIRED #TOdo organize resic
    def __init__(self, origin: Point, xaxis, yaxis, zaxis):
        self.id = generateID()
        self.type = __class__.__name__
        self.Origin = origin
        self.Xaxis = Vector3.normalize(xaxis)
        self.Yaxis = Vector3.normalize(yaxis)
        self.Zaxis = Vector3.normalize(zaxis)

    def serialize(self):
        id_value = str(self.id) if not isinstance(
            self.id, (str, int, float)) else self.id
        return {
            'id': id_value,
            'type': self.type,
            'Origin': self.Origin.serialize(),
            'Xaxis': self.Xaxis.serialize(),
            'Yaxis': self.Yaxis.serialize(),
            'Zaxis': self.Zaxis.serialize()
        }

    @staticmethod
    def deserialize(data):
        origin = Point.deserialize(data['Origin'])
        xaxis = Vector3.deserialize(data['Xaxis'])
        yaxis = Vector3.deserialize(data['Yaxis'])
        zaxis = Vector3.deserialize(data['Zaxis'])
        return CoordinateSystem(origin, xaxis, yaxis, zaxis)

    # @classmethod
    # def by_origin(self, origin: Point):
    #     self.Origin = origin
    #     self.Xaxis = XAxis
    #     self.Yaxis = YAxis
    #     self.Zaxis = ZAxis
    #     return self

    @classmethod
    def by_origin(self, origin: Point):
        return self(origin, xaxis=XAxis, yaxis=YAxis, zaxis=ZAxis)

    # @staticmethod
    # def translate(CSOld, direction):
    #     CSNew = CoordinateSystem(CSOld.Origin, CSOld.Xaxis, CSOld.Yaxis, CSOld.Zaxis)
    #     new_origin = Point.translate(CSNew.Origin, direction)
    #     CSNew.Origin = new_origin
    #     return CSNew

    @staticmethod
    def translate(CSOld, direction: Vector3):
        pt = CSOld.Origin
        new_origin = Point.translate(pt, direction)

        XAxis = Vector3(1, 0, 0)

        YAxis = Vector3(0, 1, 0)

        ZAxis = Vector3(0, 0, 1)

        CSNew = CoordinateSystem(
            new_origin, xaxis=XAxis, yaxis=YAxis, zaxis=ZAxis)

        CSNew.Origin = new_origin
        return CSNew

    @staticmethod
    def transform(CS1, CS2):  # incorrect output
        """
        Transforms CS1 into the coordinate system defined by CS2.
        :param CS1: The original CoordinateSystem instance.
        :param CS2: The target CoordinateSystem instance.
        :return: A new CoordinateSystem instance aligned with CS2.
        """

        translation_vector = Vector3.subtract(CS2.Origin, CS1.Origin)

        rotation_matrix = CoordinateSystem.calculate_rotation_matrix(
            CS1.Xaxis, CS1.Yaxis, CS1.Zaxis, CS2.Xaxis, CS2.Yaxis, CS2.Zaxis)

        xaxis_transformed = Vector3.dot_product(rotation_matrix, CS1.Xaxis)
        yaxis_transformed = Vector3.dot_product(rotation_matrix, CS1.Yaxis)
        zaxis_transformed = Vector3.dot_product(rotation_matrix, CS1.Zaxis)

        xaxis_normalized = Vector3.normalize(
            Vector3.from_matrix(xaxis_transformed))
        yaxis_normalized = Vector3.normalize(
            Vector3.from_matrix(yaxis_transformed))
        zaxis_normalized = Vector3.normalize(
            Vector3.from_matrix(zaxis_transformed))

        new_origin = Point.translate(CS1.Origin, translation_vector)
        new_CS = CoordinateSystem(
            new_origin, xaxis_normalized, yaxis_normalized, zaxis_normalized)

        return new_CS

    @staticmethod
    def translate_origin(origin1: Point, origin2: Point):
        origin1_n = Point.to_matrix(origin1)
        origin2_n = Point.to_matrix(origin2)

        new_origin_n = origin1_n + (origin2_n - origin1_n)
        return Point(new_origin_n[0], new_origin_n[1], new_origin_n[2])

    @staticmethod
    def calculate_rotation_matrix(xaxis1: Vector3, yaxis1: Vector3, zaxis1: Vector3, xaxis2: Vector3, yaxis2: Vector3, zaxis2: Vector3):

        def transpose(matrix):
            return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]

        def matrix_multiply(matrix1, matrix2):
            result = []
            for i in range(len(matrix1)):
                row = []
                for j in range(len(matrix2[0])):
                    sum = 0
                    for k in range(len(matrix2)):
                        sum += matrix1[i][k] * matrix2[k][j]
                    row.append(sum)
                result.append(row)
            return result

        def matrix_inverse(matrix):
            determinant = matrix[0][0] * (matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[2][1]) - \
                matrix[0][1] * (matrix[1][0] * matrix[2][2] - matrix[1][2] * matrix[2][0]) + \
                matrix[0][2] * (matrix[1][0] * matrix[2][1] -
                                matrix[1][1] * matrix[2][0])
            if determinant == 0:
                raise ValueError("Matrix is not invertible")
            inv_det = 1.0 / determinant
            result = [[0] * 3 for _ in range(3)]
            result[0][0] = (matrix[1][1] * matrix[2][2] -
                            matrix[1][2] * matrix[2][1]) * inv_det
            result[0][1] = (matrix[0][2] * matrix[2][1] -
                            matrix[0][1] * matrix[2][2]) * inv_det
            result[0][2] = (matrix[0][1] * matrix[1][2] -
                            matrix[0][2] * matrix[1][1]) * inv_det
            result[1][0] = (matrix[1][2] * matrix[2][0] -
                            matrix[1][0] * matrix[2][2]) * inv_det
            result[1][1] = (matrix[0][0] * matrix[2][2] -
                            matrix[0][2] * matrix[2][0]) * inv_det
            result[1][2] = (matrix[0][2] * matrix[1][0] -
                            matrix[0][0] * matrix[1][2]) * inv_det
            result[2][0] = (matrix[1][0] * matrix[2][1] -
                            matrix[1][1] * matrix[2][0]) * inv_det
            result[2][1] = (matrix[0][1] * matrix[2][0] -
                            matrix[0][0] * matrix[2][1]) * inv_det
            result[2][2] = (matrix[0][0] * matrix[1][1] -
                            matrix[0][1] * matrix[1][0]) * inv_det
            return result

        R1_transpose = transpose([Vector3.to_matrix(
            xaxis1), Vector3.to_matrix(yaxis1), Vector3.to_matrix(zaxis1)])
        R2_transpose = transpose([Vector3.to_matrix(
            xaxis2), Vector3.to_matrix(yaxis2), Vector3.to_matrix(zaxis2)])

        return matrix_multiply(R2_transpose, matrix_inverse(R1_transpose))

    @staticmethod
    def normalize(self):
        """
        Normalizes the axes of the coordinate system to make them unit vectors.
        """
        self.Xaxis = Vector3.normalize(self.Xaxis)
        self.Yaxis = Vector3.normalize(self.Yaxis)
        self.Zaxis = Vector3.normalize(self.Zaxis)

    @staticmethod
    def move_local(CSOld, x: float, y: float, z: float):
        # move coordinatesystem by y in local coordinates(not global)
        xloc_vect_norm = CSOld.Xaxis
        xdisp = Vector3.scale(xloc_vect_norm, x)
        yloc_vect_norm = CSOld.Xaxis
        ydisp = Vector3.scale(yloc_vect_norm, y)
        zloc_vect_norm = CSOld.Xaxis
        zdisp = Vector3.scale(zloc_vect_norm, z)
        disp = Vector3.sum3(xdisp, ydisp, zdisp)
        CS = CoordinateSystem.translate(CSOld, disp)
        return CS

    @staticmethod
    def by_point_main_vector(self, NewOriginCoordinateSystem: Point, DirectionVectorZ: Vector3):
        vz = DirectionVectorZ  # LineVector and new Z-axis
        vz = Vector3.normalize(vz)  # NewZAxis
        vx = Vector3.perpendicular(vz)[0]  # NewXAxis
        try:
            vx = Vector3.normalize(vx)  # NewXAxisnormalized
        except:
            # In case of vertical element the length is zero
            vx = Vector3(1, 0, 0)
        vy = Vector3.perpendicular(vz)[1]  # NewYAxis
        try:
            vy = Vector3.normalize(vy)  # NewYAxisnormalized
        except:
            # In case of vertical element the length is zero
            vy = Vector3(0, 1, 0)
        CSNew = CoordinateSystem(NewOriginCoordinateSystem, vx, vy, vz)
        return CSNew

    def __str__(self):
        return f"{__class__.__name__}(Origin = " + f"{self.Origin}, XAxis = {self.Xaxis}, YAxis = {self.Yaxis}, ZAxis = {self.Zaxis})"


XAxis = Vector3(1, 0, 0)
Vector3(0, 1, 0)
Vector3(0, 0, 1)
CSGlobal = CoordinateSystem(Point(0, 0, 0), XAxis, YAxis, ZAxis)



class Line:  # add Line.bylenght (start and endpoint)
    def __init__(self, start: Point, end: Point) -> None:
        self.id = generateID()
        self.type = __class__.__name__
        self.start: Point = start
        self.end: Point = end
        self.x = [self.start.x, self.end.x]
        self.y = [self.start.y, self.end.y]
        try:
            self.z = [self.start.z, self.end.z]
        except:
            self.z = 0
        self.dx = self.end.x-self.start.x
        self.dy = self.end.y-self.start.y
        try:
            self.dz = self.end.z-self.start.z
        except:
            self.dz = 0
        self.length = self.length()
        self.vector: Vector3 = Vector3.by_two_points(start, end)
        self.vector_normalised = Vector3.normalize(self.vector)

    def serialize(self):
        id_value = str(self.id) if not isinstance(
            self.id, (str, int, float)) else self.id
        start_serialized = self.start.serialize() if hasattr(
            self.start, 'serialize') else str(self.start)
        end_serialized = self.end.serialize() if hasattr(
            self.end, 'serialize') else str(self.end)

        # Serialize vector if it has a serialize method, otherwise convert to string representation
        vector_serialized = self.vector.serialize() if hasattr(
            self.vector, 'serialize') else str(self.vector)
        vector_normalized_serialized = self.vector_normalised.serialize() if hasattr(
            self.vector_normalised, 'serialize') else str(self.vector_normalised)

        return {
            'id': id_value,
            'type': self.type,
            'start': start_serialized,
            'end': end_serialized,
            'x': self.x,
            'y': self.y,
            'z': self.z,
            'dx': self.dx,
            'dy': self.dy,
            'dz': self.dz,
            'length': self.length,
            'vector': vector_serialized,
            'vector_normalised': vector_normalized_serialized
        }

    @staticmethod
    def deserialize(data):
        start_point = Point.deserialize(data['start'])
        end_point = Point.deserialize(data['end'])

        instance = Line(start_point, end_point)

        instance.id = data.get('id')
        instance.type = data.get('type')
        instance.x = data.get('x')
        instance.y = data.get('y')
        instance.z = data.get('z')
        instance.dx = data.get('dx')
        instance.dy = data.get('dy')
        instance.dz = data.get('dz')
        instance.length = data.get('length')

        if 'vector' in data and hasattr(Vector3, 'deserialize'):
            instance.vector = Vector3.deserialize(data['vector'])
        else:
            instance.vector = data['vector']

        if 'vector_normalised' in data and hasattr(Vector3, 'deserialize'):
            instance.vector_normalised = Vector3.deserialize(
                data['vector_normalised'])
        else:
            instance.vector_normalised = data['vector_normalised']

        return instance

    @staticmethod
    def by_startpoint_direction_length(start: Point, direction: Vector3, length: float):
        norm = math.sqrt(direction.x ** 2 + direction.y **
                         2 + direction.z ** 2)
        normalized_direction = Vector3(
            direction.x / norm, direction.y / norm, direction.z / norm)

        end_x = start.x + normalized_direction.x * length
        end_y = start.y + normalized_direction.y * length
        end_z = start.z + normalized_direction.z * length
        end_point = Point(end_x, end_y, end_z)

        return Line(start, end_point)

    def translate(self, direction: Vector3):
        self.start = Point.translate(self.start, direction)
        self.end = Point.translate(self.end, direction)
        return self

    @staticmethod
    def translate_2(line, direction: Vector3):
        line.start = Point.translate(line.start, direction)
        line.end = Point.translate(line.end, direction)
        return line

    @staticmethod
    def transform(line, CSNew: CoordinateSystem):
        ln = Line(start=line.start, end=line.end)
        ln.start = transform_point_2(ln.start, CSNew)
        ln.end = transform_point_2(ln.end, CSNew)
        return ln

    def offset(line, vector):
        start = Point(line.start.x + vector.x, line.start.y +
                      vector.y, line.start.z + vector.z)
        end = Point(line.end.x + vector.x, line.end.y +
                    vector.y, line.end.z + vector.z)
        return Line(start=start, end=end)

    # @classmethod
    def point_at_parameter(self, interval=None):
        if interval == None:
            interval = 0.0
        x1, y1, z1 = self.start.x, self.start.y, self.start.z
        x2, y2, z2 = self.end.x, self.end.y, self.end.z
        if float(interval) == 0.0:
            return self.start
        else:
            devBy = 1/interval
            return Point((x1 + x2) / devBy, (y1 + y2) / devBy, (z1 + z2) / devBy)

    def mid_point(self):
        vect = Vector3.scale(self.vector, 0.5)
        mid = Point.translate(self.start, vect)
        return mid

    def split(self, points: Point):
        lines = []
        if isinstance(points, list):
            points.extend([self.start, self.end])
            sorted_points = sorted(
                points, key=lambda p: p.distance(p, self.end))
            lines = create_lines(sorted_points)
            return lines
        elif isinstance(points, Point):
            point = points
            lines.append(Line(start=self.start, end=point))
            lines.append(Line(start=point, end=self.end))
            return lines

    def length(self):
        return math.sqrt(math.sqrt(self.dx * self.dx + self.dy * self.dy) * math.sqrt(self.dx * self.dx + self.dy * self.dy) + self.dz * self.dz)

    def __str__(self):
        return f"{__class__.__name__}(" + f"{self.start}, {self.end})"


def create_lines(points):
    lines = []
    for i in range(len(points)-1):
        line = Line(points[i], points[i+1])
        lines.append(line)
    return lines


class PolyCurve:
    def __init__(self):
        self.id = generateID()
        self.type = __class__.__name__
        self.curves = []
        self.points = []
        self.segmentcurves = None
        self.width = None
        self.height = None
        # Methods ()
        # self.close
        # pointonperimeter
        # Properties
        self.approximateLength = None
        self.graphicsStyleId = None
        self.isClosed = None
        self.isCyclic = None
        self.isElementGeometry = None
        self.isReadOnly = None
        self.length = self.length()
        self.period = None
        self.reference = None
        self.visibility = None

    def serialize(self):
        curves_serialized = [curve.serialize() if hasattr(
            curve, 'serialize') else str(curve) for curve in self.curves]
        points_serialized = [point.serialize() if hasattr(
            point, 'serialize') else str(point) for point in self.points]

        return {
            'type': self.type,
            'curves': curves_serialized,
            'points': points_serialized,
            'segmentcurves': self.segmentcurves,
            'width': self.width,
            'height': self.height,
            'approximateLength': self.approximateLength,
            'graphicsStyleId': self.graphicsStyleId,
            'id': self.id,
            'isClosed': self.isClosed,
            'isCyclic': self.isCyclic,
            'isElementGeometry': self.isElementGeometry,
            'isReadOnly': self.isReadOnly,
            'period': self.period,
            'reference': self.reference,
            'visibility': self.visibility
        }

    @staticmethod
    def deserialize(data):
        polycurve = PolyCurve()
        polycurve.segmentcurves = data.get('segmentcurves')
        polycurve.width = data.get('width')
        polycurve.height = data.get('height')
        polycurve.approximateLength = data.get('approximateLength')
        polycurve.graphicsStyleId = data.get('graphicsStyleId')
        polycurve.id = data.get('id')
        polycurve.isClosed = data.get('isClosed')
        polycurve.isCyclic = data.get('isCyclic')
        polycurve.isElementGeometry = data.get('isElementGeometry')
        polycurve.isReadOnly = data.get('isReadOnly')
        polycurve.period = data.get('period')
        polycurve.reference = data.get('reference')
        polycurve.visibility = data.get('visibility')

        # Deserialize curves and points
        if 'curves' in data:
            for curve_data in data['curves']:
                # Assuming a deserialize method exists for curve objects
                curve = Line.deserialize(curve_data)
                polycurve.curves.append(curve)

        if 'points' in data:
            for point_data in data['points']:
                # Assuming a deserialize method exists for point objects
                point = Point.deserialize(point_data)
                polycurve.points.append(point)

        return polycurve

    def scale(self, scalefactor):
        crvs = []
        for i in self.curves:
            if i.__class__.__name__ == "Arc":
                arcie = Arc(Point.product(scalefactor, i.start),
                            Point.product(scalefactor, i.end))
                arcie.mid = Point.product(scalefactor, i.mid)
                crvs.append(arcie)
            elif i.__class__.__name__ == "Line":
                crvs.append(Line(Point.product(scalefactor, i.start),
                            Point.product(scalefactor, i.end)))
            else:
                print("Curvetype not found")
        crv = PolyCurve.by_joined_curves(crvs)
        return crv

    def get_width(self) -> float:
        x_values = [point.x for point in self.points]
        y_values = [point.y for point in self.points]

        min_x = min(x_values)
        max_x = max(x_values)
        min_y = min(y_values)
        max_y = max(y_values)

        left_top = Point(x=min_x, y=max_y, z=self.z)
        left_bottom = Point(x=min_x, y=min_y, z=self.z)
        right_top = Point(x=max_x, y=max_y, z=self.z)
        right_bottom = Point(x=max_x, y=min_y, z=self.z)
        self.width = abs(Point.distance(left_top, right_top))
        self.height = abs(Point.distance(left_top, left_bottom))
        return self.width

    def centroid(self) -> Point:
        if self.isClosed:
            num_points = len(self.points)
            if num_points < 3:
                return "Polygon has less than 3 points!"

            A = 0.0
            for i in range(num_points):
                x0, y0 = self.points[i].x, self.points[i].y
                x1, y1 = self.points[(
                    i + 1) % num_points].x, self.points[(i + 1) % num_points].y
                A += x0 * y1 - x1 * y0
            A *= 0.5

            Cx, Cy = 0.0, 0.0
            for i in range(num_points):
                x0, y0 = self.points[i].x, self.points[i].y
                x1, y1 = self.points[(
                    i + 1) % num_points].x, self.points[(i + 1) % num_points].y
                factor = (x0 * y1 - x1 * y0)
                Cx += (x0 + x1) * factor
                Cy += (y0 + y1) * factor

            Cx /= (6.0 * A)
            Cy /= (6.0 * A)

            return Point(x=round(Cx, project.decimals), y=round(Cy, project.decimals), z=self.points[0].z)
        else:
            return None

    def area(self) -> float:  # shoelace formula
        if self.isClosed:
            if len(self.points) < 3:
                return "Polygon has less than 3 points!"

            num_points = len(self.points)
            S1, S2 = 0, 0

            for i in range(num_points):
                x, y = self.points[i].x, self.points[i].y
                if i == num_points - 1:
                    x_next, y_next = self.points[0].x, self.points[0].y
                else:
                    x_next, y_next = self.points[i + 1].x, self.points[i + 1].y

                S1 += x * y_next
                S2 += y * x_next

            area = 0.5 * abs(S1 - S2)
            return area
        else:
            print("Polycurve is not closed, no area!")
            return None

    def length(self) -> float:
        lst = []
        for line in self.curves:
            lst.append(line.length)

        return sum(i.length for i in self.curves)

    def close(self) -> bool:
        if self.curves[0] == self.curves[-1]:
            return self
        else:
            self.curves.append(self.curves[0])
            plycrv = PolyCurve()
            for curve in self.curves:
                plycrv.curves.append(curve)
        return plycrv

    @classmethod
    def by_joined_curves(self, curvelst: list[Line]):
        for crv in curvelst:
            if crv.length == 0:
                curvelst.remove(crv)
                # print("Error: Curve length cannot be zero.")
                # sys.exit()

        projectClosed = project.closed
        plycrv = PolyCurve()
        for index, curve in enumerate(curvelst):
            if index == 0:
                plycrv.curves.append(curve)
                plycrv.points.append(curve.start)
                plycrv.points.append(curve.end)
            else:
                plycrv.curves.append(curve)
                plycrv.points.append(curve.end)
        if projectClosed:
            if plycrv.points[0].value == plycrv.points[-1].value:
                plycrv.isClosed = True
            else:
                # plycrv.points.append(curvelst[0].start)
                plycrv.curves.append(curve)
                plycrv.isClosed = True
        elif projectClosed == False:
            if plycrv.points[0].value == plycrv.points[-1].value:
                plycrv.isClosed = True
            else:
                plycrv.isClosed = False
        if plycrv.points[-2].value == plycrv.points[0].value:
            plycrv.curves = plycrv.curves.pop(-1)

        return plycrv

    @classmethod
    def by_points(self, points: list[Point]):
        seen = set()
        unique_points = []

        for point in points:
            if point in seen:
                points.remove(point)
                print("Error: Polycurve cannot have multiple identical points.")
                sys.exit()

            seen.add(point)
            unique_points.append(point)

        plycrv = PolyCurve()
        for index, point in enumerate(points):
            plycrv.points.append(point)
            try:
                nextpoint = points[index+1]
                plycrv.curves.append(Line(start=point, end=nextpoint))
            except:
                firstpoint = points[0]
                plycrv.curves.append(Line(start=point, end=firstpoint))

        if project.closed:
            if plycrv.points[0].value == plycrv.points[-1].value:
                plycrv.isClosed = True
            else:
                plycrv.isClosed = True
                plycrv.points.append(points[0])

        elif project.closed == False:
            if plycrv.points[0].value == plycrv.points[-1].value:
                plycrv.isClosed = True
            else:
                plycrv.isClosed = False
                plycrv.points.append(points[0])

        return plycrv

    @classmethod
    def unclosed_by_points(self, points: list[Point]):
        plycrv = PolyCurve()
        for index, point in enumerate(points):
            plycrv.points.append(point)
            try:
                nextpoint = points[index + 1]
                plycrv.curves.append(Line(start=point, end=nextpoint))
            except:
                pass
        return plycrv

    @staticmethod
    # Create segmented polycurve. Arcs, elips will be translated to straight lines
    def segment(self, count):
        crvs = []  # add isClosed
        for i in self.curves:
            if i.__class__.__name__ == "Arc":
                crvs.append(Arc.segmented_arc(i, count))
            elif i.__class__.__name__ == "Line":
                crvs.append(i)
        crv = flatten(crvs)
        pc = PolyCurve.by_joined_curves(crv)
        return pc

    @staticmethod
    def by_polycurve_2D(PolyCurve2D):
        # by points,
        plycrv = PolyCurve()
        curves = []
        for i in PolyCurve2D.curves:
            if i.__class__.__name__ == "Arc2D":
                curves.append(Arc(Point(i.start.x, i.start.y, 0), Point(
                    i.mid.x, i.mid.y, 0), Point(i.end.x, i.end.y, 0)))
            elif i.__class__.__name__ == "Line2D":
                curves.append(Line(Point(i.start.x, i.start.y, 0),
                              Point(i.end.x, i.end.y, 0)))
            else:
                print("Curvetype not found")
        pnts = []
        for i in curves:
            pnts.append(i.start)
        pnts.append(curves[0].start)
        plycrv.points = pnts
        plycrv.curves = curves
        return plycrv

    # make sure that the lines start/stop already on the edge of the polycurve
    def split(self, line: Line, returnlines=None):

        allLines = self.curves.copy()

        # insect = Intersect2d().getIntersectLinePolyCurve(self, line, split=True, stretch=False)
        # for pt in insect["IntersectGridPoints"]:
        #     for index, line in enumerate(allLines):
        #         if is_point_on_line_segment(pt, line) == True:
        #             cuttedLines = line.split([pt])
        #             allLines = replace_at_index(allLines,index, cuttedLines)

        insect = Intersect2d().getIntersectLinePolyCurve(
            self, line, split=True, stretch=False)
        for pt in insect["IntersectGridPoints"]:
            for index, line in enumerate(allLines):
                if is_point_on_line_segment(pt, line) == True:
                    cuttedLines = line.split([pt])
                    allLines = replace_at_index(allLines, index, cuttedLines)

        if len(insect["IntersectGridPoints"]) == 2:
            part1 = []
            part2 = []

            for j in allLines:
                # part1
                if j.start == insect["IntersectGridPoints"][1]:
                    part1LineEnd = j.end
                    part1.append(j.start)
                if j.end == insect["IntersectGridPoints"][0]:
                    part1LineStart = j.start
                    part1.append(j.end)
                # part2
                if j.start == insect["IntersectGridPoints"][0]:
                    part2LineEnd = j.end
                    part2.append(j.start)
                if j.end == insect["IntersectGridPoints"][1]:
                    part2LineStart = j.start
                    part2.append(j.end)

            s2 = self.points.index(part1LineStart)
            s1 = self.points.index(part1LineEnd)
            completelist = list(range(len(self.points)))
            partlist1 = flatten(completelist[s2:s1+1])
            partlist2 = flatten([completelist[s1+1:]] + [completelist[:s2]])

            SplittedPolyCurves = []
            # part1
            if part1LineStart != None and part1LineEnd != None:
                for i, index in enumerate(partlist1):
                    pts = self.points[index]
                    part1.insert(i+1, pts)
                if returnlines:
                    SplittedPolyCurves.append(PolyCurve.by_points(part1))
                else:
                    project.objects.append(PolyCurve.by_points(part1))

            # part2 -> BUGG?
            if part2LineStart != None and part2LineEnd != None:
                for index in partlist2:
                    pts = self.points[index]
                    part2.insert(index, pts)
                if returnlines:
                    SplittedPolyCurves.append(PolyCurve.by_points(part2))
                else:
                    project.objects.append(PolyCurve.by_points(part2))

            if returnlines:  # return lines while using multi_split
                return SplittedPolyCurves

        else:
            print(
                f"Must need 2 points to split PolyCurve into PolyCurves, got now {len(insect['IntersectGridPoints'])} points.")

    def multi_split(self, lines: Line):  # SOOOO SLOW, MUST INCREASE SPEAD
        lines = flatten(lines)
        new_polygons = []
        for index, line in enumerate(lines):
            if index == 0:
                n_p = self.split(line, returnlines=True)
                if n_p != None:
                    for nxp in n_p:
                        if nxp != None:
                            new_polygons.append(n_p)
            else:
                for new_poly in flatten(new_polygons):
                    n_p = new_poly.split(line, returnlines=True)
                    if n_p != None:
                        for nxp in n_p:
                            if nxp != None:
                                new_polygons.append(n_p)
        project.objects.append(flatten(new_polygons))
        return flatten(new_polygons)

    def translate(self, vector3d: Vector3):
        crvs = []
        v1 = vector3d
        for i in self.curves:
            if i.__class__.__name__ == "Arc":
                crvs.append(Arc(Point.translate(i.start, v1), Point.translate(
                    i.middle, v1), Point.translate(i.end, v1)))
            elif i.__class__.__name__ == "Line":
                crvs.append(Line(Point.translate(i.start, v1),
                            Point.translate(i.end, v1)))
            else:
                print("Curvetype not found")
        pc = PolyCurve()
        pc.curves = crvs
        return pc

    @staticmethod
    def copy_translate(pc, vector3d: Vector3):
        crvs = []
        v1 = vector3d
        for i in pc.curves:
            # if i.__class__.__name__ == "Arc":
            #    crvs.append(Arc(Point.translate(i.start, v1), Point.translate(i.middle, v1), Point.translate(i.end, v1)))
            if i.__class__.__name__ == "Line":
                crvs.append(Line(Point.translate(i.start, v1),
                            Point.translate(i.end, v1)))
            else:
                print("Curvetype not found")

        PCnew = PolyCurve.by_joined_curves(crvs)
        return PCnew

    def rotate(self, angle, dz):
        # angle in degrees
        # dz = displacement in z-direction
        crvs = []
        for i in self.curves:
            if i.__class__.__name__ == "Arc":
                crvs.append(Arc(Point.rotate_XY(i.start, angle, dz), Point.rotate_XY(
                    i.middle, angle, dz), Point.rotate_XY(i.end, angle, dz)))
            elif i.__class__.__name__ == "Line":
                crvs.append(Line(Point.rotate_XY(i.start, angle, dz),
                            Point.rotate_XY(i.end, angle, dz)))
            else:
                print("Curvetype not found")
        crv = PolyCurve.by_joined_curves(crvs)
        return crv

    def to_polycurve_2D(self):
        # by points,

        p1 = PolyCurve2D()
        count = 0
        curves = []
        for i in self.curves:
            if i.__class__.__name__ == "Arc":
                curves.append(Arc2D(Point2D(i.start.x, i.start.y), Point2D(i.middle.x, i.middle.y),
                                    Point2D(i.end.x, i.end.y)))
            elif i.__class__.__name__ == "Line":
                curves.append(
                    Line2D(Point2D(i.start.x, i.start.y), Point2D(i.end.x, i.end.y)))
            else:
                print("Curvetype not found")
        pnts = []
        for i in curves:
            pnts.append(i.start)
        pnts.append(curves[0].start)
        p1.points = pnts
        p1.curves = curves
        return p1

    @staticmethod
    def transform_from_origin(polycurve, startpoint: Point, directionvector: Vector3):
        crvs = []
        if polycurve.type == "PolyCurve2D":
            for i in polycurve.curves:
                if i.__class__.__name__ == "Arc":
                    crvs.append(Arc(transform_point(i.start, CSGlobal, startpoint, directionvector),
                                    transform_point(
                                        i.mid, CSGlobal, startpoint, directionvector),
                                    transform_point(
                                        i.end, CSGlobal, startpoint, directionvector)
                                    ))
                elif i.__class__.__name__ == "Line":
                    crvs.append(Line(start=transform_point(i.start, CSGlobal, startpoint, directionvector),
                                     end=transform_point(
                                         i.end, CSGlobal, startpoint, directionvector)
                                     ))
                elif i.__class__.__name__ == "Arc2D":
                    # print(Point.point_2D_to_3D(i.start),CSGlobal, startpoint, directionvector)
                    crvs.append(Arc(transform_point(Point.point_2D_to_3D(i.start), CSGlobal, startpoint, directionvector),
                                    transform_point(Point.point_2D_to_3D(
                                        i.mid), CSGlobal, startpoint, directionvector),
                                    transform_point(Point.point_2D_to_3D(
                                        i.end), CSGlobal, startpoint, directionvector)
                                    ))
                elif i.__class__.__name__ == "Line2D":
                    crvs.append(Line(start=transform_point(Point.point_2D_to_3D(i.start), CSGlobal, startpoint, directionvector),
                                     end=transform_point(Point.point_2D_to_3D(
                                         i.end), CSGlobal, startpoint, directionvector)
                                     ))
                else:
                    print(i.__class__.__name__ + "Curvetype not found")
        elif polycurve.type == "PolyCurve":
            for i in polycurve.curves:
                if i.__class__.__name__ == "Arc":
                    crvs.append(Arc(transform_point(i.start, CSGlobal, startpoint, directionvector),
                                    transform_point(
                                        i.mid, CSGlobal, startpoint, directionvector),
                                    transform_point(
                                        i.end, CSGlobal, startpoint, directionvector)
                                    ))
                elif i.__class__.__name__ == "Line":
                    crvs.append(Line(start=transform_point(i.start, CSGlobal, startpoint, directionvector),
                                     end=transform_point(
                                         i.end, CSGlobal, startpoint, directionvector)
                                     ))
                elif i.__class__.__name__ == "Arc2D":
                    # print(Point.point_2D_to_3D(i.start),CSGlobal, startpoint, directionvector)
                    crvs.append(Arc(transform_point(Point.point_2D_to_3D(i.start), CSGlobal, startpoint, directionvector),
                                    transform_point(Point.point_2D_to_3D(
                                        i.mid), CSGlobal, startpoint, directionvector),
                                    transform_point(Point.point_2D_to_3D(
                                        i.end), CSGlobal, startpoint, directionvector)
                                    ))
                elif i.__class__.__name__ == "Line2D":
                    crvs.append(Line(start=transform_point(Point.point_2D_to_3D(i.start), CSGlobal, startpoint, directionvector),
                                     end=transform_point(Point.point_2D_to_3D(
                                         i.end), CSGlobal, startpoint, directionvector)
                                     ))
                else:
                    print(i.__class__.__name__ + "Curvetype not found")

        pc = PolyCurve()
        pc.curves = crvs
        return pc

    def __str__(self):
        l = len(self.points)
        return f"{__class__.__name__}, ({l} points)"

# 2D PolyCurve to 3D PolyGon


def Rect(vector: Vector3, width: float, height: float):
    # Rectangle in XY-plane with translation of vector
    p1 = Point(0, 0, 0).translate(Point(0, 0, 0), vector)
    p2 = Point(0, 0, 0).translate(Point(width, 0, 0), vector)
    p3 = Point(0, 0, 0).translate(Point(width, height, 0), vector)
    p4 = Point(0, 0, 0).translate(Point(0, height, 0), vector)
    crv = PolyCurve.by_points([p1, p2, p3, p4, p1])
    return crv


def Rect_XY(vector: Vector3, width: float, height: float):
    # Rectangle in XY-plane
    p1 = Point(0, 0, 0).translate(Point(0, 0, 0), vector)
    p2 = Point(0, 0, 0).translate(Point(width, 0, 0), vector)
    p3 = Point(0, 0, 0).translate(Point(width, 0, height), vector)
    p4 = Point(0, 0, 0).translate(Point(0, 0, height), vector)
    crv = PolyCurve.by_points([p1, p2, p3, p4])
    return crv


def Rect_YZ(vector: Vector3, width: float, height: float):
    # Rectangle in XY-plane
    p1 = Point(0, 0, 0).translate(Point(0, 0, 0), vector)
    p2 = Point(0, 0, 0).translate(Point(0, width, 0), vector)
    p3 = Point(0, 0, 0).translate(Point(0, width, height), vector)
    p4 = Point(0, 0, 0).translate(Point(0, 0, height), vector)
    crv = PolyCurve.by_points([p1, p2, p3, p4, p1])
    return crv


class PolyGon:
    def __init__(self, lines) -> None:
        self.type = __class__.__name__
        self.Lines = lines  # collect in list
        self.id = generateID()
        pass  # Lines

    @staticmethod
    def polygon(flatCurves: Line) -> Point:
        points = []
        for i in flatCurves:
            points.append(i.start)
            try:
                points.append(i.middle)
            except:
                pass
        points.append(points[0])
        points3D = []
        for i in points:
            points3D.append(Point.point_2D_to_3D(i))
        return points3D

    def __id__(self):
        return f"id:{self.id}"

    def __str__(self) -> str:
        return f"{__class__.__name__}({self})"


class Arc:
    def __init__(self, startPoint: Point, midPoint: Point, endPoint: Point):
        self.id = generateID()
        self.type = __class__.__name__
        self.start = startPoint
        self.mid = midPoint
        self.end = endPoint
        self.origin = self.origin_arc()
        v1 = Vector3(x=1, y=0, z=0)
        v2 = Vector3(x=0, y=1, z=0)
        self.plane = Plane.by_two_vectors_origin(
            v1,
            v2,
            self.origin
        )
        self.radius = self.radius_arc()
        self.startAngle = 0
        self.endAngle = 0
        self.angle_radian = self.angle_radian()
        self.area = 0
        self.length = self.length()
        self.units = project.units
        self.coordinatesystem = self.coordinatesystem_arc()

    def distance(self, p1, p2):
        return math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2 + (p2.z - p1.z) ** 2)

    def coordinatesystem_arc(self):
        vx = Vector3.by_two_points(self.origin, self.start)  # Local X-axe
        v2 = Vector3.by_two_points(self.end, self.origin)
        vz = Vector3.cross_product(vx, v2)  # Local Z-axe
        vy = Vector3.cross_product(vx, vz)  # Local Y-axe
        self.coordinatesystem = CoordinateSystem(self.origin, Vector3.normalize(vx), Vector3.normalize(vy),
                                                 Vector3.normalize(vz))
        return self.coordinatesystem

    def radius_arc(self):
        a = self.distance(self.start, self.mid)
        b = self.distance(self.mid, self.end)
        c = self.distance(self.end, self.start)
        s = (a + b + c) / 2
        A = math.sqrt(s * (s - a) * (s - b) * (s - c))
        R = (a * b * c) / (4 * A)
        return R

    def origin_arc(self):
        # calculation of origin of arc #Todo can be simplified for sure
        Vstartend = Vector3.by_two_points(self.start, self.end)
        halfVstartend = Vector3.scale(Vstartend, 0.5)
        # half distance between start and end
        b = 0.5 * Vector3.length(Vstartend)
        # distance from start-end line to origin
        x = math.sqrt(Arc.radius_arc(self) * Arc.radius_arc(self) - b * b)
        mid = Point.translate(self.start, halfVstartend)
        v2 = Vector3.by_two_points(self.mid, mid)
        v3 = Vector3.normalize(v2)
        tocenter = Vector3.scale(v3, x)
        center = Point.translate(mid, tocenter)
        return center

    def angle_radian(self):
        v1 = Vector3.by_two_points(self.origin, self.end)
        v2 = Vector3.by_two_points(self.origin, self.start)
        v3 = Vector3.by_two_points(self.origin, self.mid)
        v4 = Vector3.sum(v1, v2)
        try:
            v4b = Vector3.new_length(v4, self.radius)
            if Vector3.value(v3) == Vector3.value(v4b):
                angle = Vector3.angle_radian_between(v1, v2)
            else:
                angle = 2*math.pi-Vector3.angle_radian_between(v1, v2)
            return angle
        except:
            angle = 2*math.pi-Vector3.angle_radian_between(v1, v2)
            return angle

    def length(self):
        x1, y1, z1 = self.start.x, self.start.y, self.start.z
        x2, y2, z2 = self.mid.x, self.mid.y, self.mid.z
        x3, y3, z3 = self.end.x, self.end.y, self.end.z

        r1 = ((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2) ** 0.5 / 2
        a = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)
        b = math.sqrt((x3 - x2) ** 2 + (y3 - y2) ** 2 + (z3 - z2) ** 2)
        c = math.sqrt((x3 - x1) ** 2 + (y3 - y1) ** 2 + (z3 - z1) ** 2)
        cos_angle = (a ** 2 + b ** 2 - c ** 2) / (2 * a * b)
        m1 = math.acos(cos_angle)
        arc_length = r1 * m1

        return arc_length

    @staticmethod
    def points_at_parameter(arc, count: int):
        # Create points at parameter on an arc based on an interval
        d_alpha = arc.angle_radian / (count - 1)
        alpha = 0
        pnts = []
        for i in range(count):
            pnts.append(Point(arc.radius * math.cos(alpha),
                        arc.radius * math.sin(alpha), 0))
            alpha = alpha + d_alpha
        CSNew = arc.coordinatesystem
        pnts2 = []  # transformed points
        for i in pnts:
            pnts2.append(transform_point_2(i, CSNew))
        return pnts2

    @staticmethod
    def segmented_arc(arc, count):
        pnts = Arc.points_at_parameter(arc, count)
        i = 0
        lines = []
        for j in range(len(pnts) - 1):
            lines.append(Line(pnts[i], pnts[i + 1]))
            i = i + 1
        return lines

    def __str__(self) -> str:
        return f"{__class__.__name__}()"


def transform_arc(Arcold, CSNew: CoordinateSystem):
    start = transform_point_2(Arcold.start, CSNew)
    mid = transform_point_2(Arcold.mid, CSNew)
    end = transform_point_2(Arcold.end, CSNew)
    Arcnew = Arc(startPoint=start, midPoint=mid, endPoint=end)

    return Arcnew


class Circle:  # auto calculate length!
    def __init__(self, radius, plane, length) -> None:
        self.type = __class__.__name__
        self.radius = radius
        self.plane = plane
        self.length = length
        self.id = generateID()
        pass  # Curve

    def __id__(self):
        return f"id:{self.id}"

    def __str__(self) -> str:
        return f"{__class__.__name__}({self})"


class Ellipse:
    def __init__(self, firstRadius, secondRadius, plane) -> None:
        self.type = __class__.__name__
        self.firstRadius = firstRadius
        self.secondRadius = secondRadius
        self.plane = plane
        self.id = generateID()
        pass  # Curve
    pass

    def __id__(self):
        return f"id:{self.id}"

    def __str__(self) -> str:
        return f"{__class__.__name__}({self})"




class Node:
    def __init__(self, point=None, vector=None, number=None, distance=0.0, diameter=None, comments=None):
        self.id = generateID()
        self.type = __class__.__name__
        self.point = point if isinstance(point, Point) else None
        self.vector = vector if isinstance(vector, Vector3) else None
        self.number = number
        self.distance = distance
        self.diameter = diameter
        self.comments = comments

    def serialize(self):
        id_value = str(self.id) if not isinstance(
            self.id, (str, int, float)) else self.id
        return {
            'id': id_value,
            'type': self.type,
            'point': self.point.serialize() if self.point else None,
            'vector': self.vector.serialize() if self.vector else None,
            'number': self.number,
            'distance': self.distance,
            'diameter': self.diameter,
            'comments': self.comments
        }

    @staticmethod
    def deserialize(data):
        node = Node()
        node.id = data.get('id')
        node.type = data.get('type')
        node.point = Point.deserialize(
            data['point']) if data.get('point') else None
        node.vector = Vector3.deserialize(
            data['vector']) if data.get('vector') else None
        node.number = data.get('number')
        node.distance = data.get('distance')
        node.diameter = data.get('diameter')
        node.comments = data.get('comments')

        return node

    # merge
    def merge(self):
        if project.node_merge == True:
            pass
        else:
            pass

    # snap
    def snap(self):
        pass

    def __str__(self) -> str:
        return f"{self.type}"




class Color:
    """Documentation: output returns [r, g, b]"""

    def __init__(self, colorInput=None):
        self.colorInput = colorInput

    red = [255, 0, 0]
    green = [0, 255, 0]
    blue = [0, 0, 255]

    def Components(self, colorInput=None):
        """1"""
        if colorInput is None:
            return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}('green')"
        else:
            try:
                JSONfile = "library/color/colorComponents.json"
                with open(JSONfile, 'r') as file:
                    components_dict = json.load(file)
                    checkExist = components_dict.get(str(colorInput))
                    if checkExist is not None:
                        r, g, b, a = components_dict[colorInput]
                        return [r, g, b]
                    else:
                        return f"Invalid {sys._getframe(0).f_code.co_name}-color, check '{JSONfile}' for available {sys._getframe(0).f_code.co_name}-colors."
            except:
                return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"

    def Hex(self, colorInput=None):
        """NAN"""
        if colorInput is None:
            return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}('#2ba4ff')"
        else:
            # validate if value is correct/found
            try:
                colorInput = colorInput.split("#")[1]
                rgb_color = list(int(colorInput[i:i+2], 16) for i in (1, 3, 5))
                return [rgb_color[0], rgb_color[1], rgb_color[2], 255]

                # colorInput = colorInput.lstrip('#')
                # return list(int(colorInput[i:i+2], 16) for i in (0, 2, 4))
            except:
                return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"

    def rgba_to_hex(self, colorInput=None):
        """NAN"""
        if colorInput is None:
            return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}('#2ba4ff')"
        else:
            # validate if value is correct/found
            try:
                red_i = int(colorInput[0] * 255)
                green_i = int(colorInput[1] * 255)
                blue_i = int(colorInput[2] * 255)
                alpha_i = int(colorInput[3] * 255)

                red_hex = hex(red_i)[2:].zfill(2)
                green_hex = hex(green_i)[2:].zfill(2)
                blue_hex = hex(blue_i)[2:].zfill(2)
                alpha_hex = hex(alpha_i)[2:].zfill(2)

                colorInput = "#" + red_hex + green_hex + blue_hex + alpha_hex

                return colorInput.upper()

            except:
                return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"

    def hex_to_rgba(self, colorInput=None):
        """NAN"""
        if colorInput is None:
            return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}('#2ba4ff')"
        else:
            # validate if value is correct/found
            try:
                colorInput = colorInput.lstrip('#')
                red_int = int(colorInput[0:2], 16)
                green_int = int(colorInput[2:4], 16)
                blue_int = int(colorInput[4:6], 16)

                if len(colorInput) == 8:
                    alpha_int = int(colorInput[6:8], 16)
                    alpha = round(alpha_int / 255, 2)
                else:
                    alpha = 1.0

                red = round(red_int / 255, 2)
                green = round(green_int / 255, 2)
                blue = round(blue_int / 255, 2)

                return [red, green, blue, alpha]

            except:
                return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"

    def CMYK(self, colorInput=None):
        """NAN"""
        if colorInput is None:
            return f"Error: Example usage Color().CMYK([0.5, 0.25, 0, 0.2])"
        else:
            try:
                c, m, y, k = colorInput
                r = int((1-c) * (1-k) * 255)
                g = int((1-m) * (1-k) * 255)
                b = int((1-y) * (1-k) * 255)
                return [r, g, b]
            except:
                # add check help attribute
                return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"

    def Alpha(self, colorInput=None):
        """NAN"""
        if colorInput is None:
            return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}([255, 0, 0, 128])"
        else:
            try:
                r, g, b, a = colorInput
                return [r, g, b]
            except:
                return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"

    def Brightness(self, colorInput=None):
        """Expected value is int(0) - int(1)"""
        if colorInput is None:
            return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}([255, 0, 0, 128])"
        else:
            try:
                if colorInput >= 0 and colorInput <= 1:
                    r = g = b = int(255 * colorInput)
                    return [r, g, b]
                else:
                    return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"
            except:
                return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"

    def RGB(self, colorInput=None):
        """NAN"""
        if colorInput is None:
            return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}([255, 0, 0])"
        else:
            try:
                r, g, b = colorInput
                return [r, g, b]
            except:
                return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"

    def HSV(self, colorInput=None):
        """NAN"""
        if colorInput is None:
            return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}()"
        else:
            try:
                h, s, v = colorInput
                h /= 60.0
                c = v * s
                x = c * (1 - abs(h % 2 - 1))
                m = v - c
                if 0 <= h < 1:
                    r, g, b = c, x, 0
                elif 1 <= h < 2:
                    r, g, b = x, c, 0
                elif 2 <= h < 3:
                    r, g, b = 0, c, x
                elif 3 <= h < 4:
                    r, g, b = 0, x, c
                elif 4 <= h < 5:
                    r, g, b = x, 0, c
                else:
                    r, g, b = c, 0, x
                return [int((r + m) * 255), int((g + m) * 255), int((b + m) * 255)]
            except:
                return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"

    def HSL(self, colorInput=None):
        """NAN"""
        if colorInput is None:
            return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}()"
        else:
            try:
                h, s, l = colorInput
                c = (1 - abs(2 * l - 1)) * s
                x = c * (1 - abs(h / 60 % 2 - 1))
                m = l - c / 2
                if h < 60:
                    r, g, b = c, x, 0
                elif h < 120:
                    r, g, b = x, c, 0
                elif h < 180:
                    r, g, b = 0, c, x
                elif h < 240:
                    r, g, b = 0, x, c
                elif h < 300:
                    r, g, b = x, 0, c
                else:
                    r, g, b = c, 0, x
                r, g, b = int((r + m) * 255), int((g + m)
                                                  * 255), int((b + m) * 255)
                return [r, g, b]
            except:
                return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"

    def RAL(self, colorInput=None):
        """NAN"""
        if colorInput is None:
            return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}(1000)"
        else:
            try:
                # validate if value is correct/found
                JSONfile = "library/color/colorRAL.json"
                with open(JSONfile, 'r') as file:
                    ral_dict = json.load(file)
                    checkExist = ral_dict.get(str(colorInput))
                    if checkExist is not None:
                        r, g, b = ral_dict[str(colorInput)]["rgb"].split("-")
                        return [int(r), int(g), int(b), 100]
                    else:
                        return f"Invalid {sys._getframe(0).f_code.co_name}-color, check '{JSONfile}' for available {sys._getframe(0).f_code.co_name}-colors."
            except:
                return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"

    def Pantone(self, colorInput=None):
        """NAN"""
        if colorInput is None:
            return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}()"
        else:
            try:
                JSONfile = "library/color/colorPantone.json"
                with open(JSONfile, 'r') as file:
                    pantone_dict = json.load(file)
                    checkExist = pantone_dict.get(str(colorInput))
                    if checkExist is not None:
                        PantoneHex = pantone_dict[str(colorInput)]['hex']
                        return Color().Hex(PantoneHex)
                    else:
                        return f"Invalid {sys._getframe(0).f_code.co_name}-color, check '{JSONfile}' for available {sys._getframe(0).f_code.co_name}-colors."
            except:
                return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"

    def LRV(self, colorInput=None):
        """NAN"""
        if colorInput is None:
            return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}()"
        else:
            try:
                b = (colorInput - 0.2126 * 255 - 0.7152 * 255) / 0.0722
                b = int(max(0, min(255, b)))
                return [255, 255, b]
            except:
                return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"

    def rgb_to_int(rgb):
        r, g, b = [max(0, min(255, c)) for c in rgb]
        return (255 << 24) | (r << 16) | (g << 8) | b

    def __str__(self, colorInput=None):
        colorattributes = ["Components", "Hex", "rgba_to_hex", "hex_to_rgba", "CMYK",
                           "Alpha", "Brightness", "RGB", "HSV", "HSL", "RAL", "Pantone", "LRV"]
        if colorInput is None:
            header = "Available attributes: \n"
            footer = "\nColor().red | Color().green | Color().blue"
            return header + '\n'.join([f"Color().{func}()" for func in colorattributes]) + footer
        return f"Color().{colorInput}"

    def Info(self, colorInput=None):
        pass




class Interval:
    def __init__(self, start: float, end: float):
        self.start = start
        self.end = end
        self.interval = None

    def serialize(self):
        return {
            'start': self.start,
            'end': self.end,
            'interval': self.interval
        }

    @staticmethod
    def deserialize(data):
        start = data.get('start')
        end = data.get('end')
        interval = Interval(start, end)
        interval.interval = data.get('interval')
        return interval

    @classmethod
    def by_start_end_count(self, start: float, end: float, count: int):
        intval = []
        numb = start
        delta = end-start
        for i in range(count):
            intval.append(numb)
            numb = numb + (delta / (count - 1))
        self.interval = intval
        return self

    def __str__(self):
        return f"{__class__.__name__}"




class Plane:
    # Plane is an infinite element in space defined by a point and a normal
    def __init__(self):
        self.Origin = Point(0, 0, 0)
        self.Normal = Vector3(x=0, y=0, z=1)
        self.v1 = Vector3(x=1, y=0, z=0)
        self.v2 = Vector3(x=0, y=1, z=0)

    def serialize(self):
        return {
            'Origin': self.Origin.serialize(),
            'Normal': self.Normal.serialize(),
            'v1': self.v1.serialize(),
            'v2': self.v2.serialize()
        }

    @staticmethod
    def deserialize(data):
        plane = Plane()
        plane.Origin = Point.deserialize(data['Origin'])
        plane.Normal = Vector3.deserialize(data['Normal'])
        plane.v1 = Vector3.deserialize(data['v1'])
        plane.v2 = Vector3.deserialize(data['v2'])

        return plane

    @classmethod
    def by_two_vectors_origin(cls, v1, v2, origin):
        p1 = Plane()
        p1.Normal = Vector3.normalize(Vector3.cross_product(v1, v2))
        p1.Origin = origin
        p1.v1 = v1
        p1.v2 = v2
        return p1

    def __str__(self):
        return f"{__class__.__name__}(" + f"{self.Origin}, {self.Normal}, {self.v1}, {self.v2})"

    # TODO
    # byLineAndPoint
    # byOriginNormal
    # byThreePoints




class Text:
    def __init__(self, text: str = None, font_family: str = None, cs=CoordinateSystem, height=None):
        self.id = generateID()
        self.type = __class__.__name__
        self.text = text
        self.font_family = font_family or "arial"
        self.xyz = cs.Origin
        self.csglobal = cs
        self.x, self.y, self.z = 0, 0, 0
        self.scale = None
        self.height = height or project.font_height
        self.bbHeight = None
        self.width = None
        self.character_offset = 150
        self.space = 850
        self.curves = []
        self.points = []
        self.path_list = self.load_path()
        self.load_o_example = self.load_o()

    def serialize(self):
        id_value = str(self.id) if not isinstance(
            self.id, (str, int, float)) else self.id
        return {
            'id': id_value,
            'type': self.type,
            'text': self.text,
            'font_family': self.font_family,
            'xyz': self.xyz,
            'csglobal': self.csglobal.serialize(),
            'x': self.x,
            'y': self.y,
            'z': self.z,
            'scale': self.scale,
            'height': self.height,
            'bbHeight': self.bbHeight,
            'width': self.width,
            'character_offset': self.character_offset,
            'space': self.space,
            'curves': [curve.serialize() for curve in self.curves],
            'points': self.points,
            'path_list': self.path_list,
        }

    def load_path(self) -> str:
        url = 'https://raw.githubusercontent.com/3BMLabs/building.py/main/library/text/json/Calibri.json'
        response = requests.get(url)
        if response.status_code == 200:
            glyph_data = json.loads(response.text)
            output = []
            for letter in self.text:
                if letter in glyph_data:
                    output.append(glyph_data[letter]["glyph-path"])
                elif letter == " ":
                    output.append("space")
            return output

    def load_o(self) -> str:
        url = 'https://raw.githubusercontent.com/3BMLabs/building.py/main/library/text/json/Calibri.json'
        response = requests.get(url)
        if response.status_code == 200:
            glyph_data = json.loads(response.text)
            load_o = []
            letter = "o"
            if letter in glyph_data:
                load_o.append(glyph_data[letter]["glyph-path"])
            return load_o

    def write(self) -> List[List[PolyCurve]]:
        # start ref_symbol
        path = self.load_o_example
        ref_points = []
        ref_allPoints = []
        for segment in path:
            pathx = parse_path(segment)
            for segment in pathx:
                segment_type = segment.__class__.__name__
                if segment_type == 'Line':
                    ref_points.extend(
                        [(segment.start.real, segment.start.imag), (segment.end.real, segment.end.imag)])
                    ref_allPoints.extend(
                        [(segment.start.real, segment.start.imag), (segment.end.real, segment.end.imag)])
                elif segment_type == 'CubicBezier':
                    ref_points.extend(segment.sample(10))
                    ref_allPoints.extend(segment.sample(10))
                elif segment_type == 'QuadraticBezier':
                    for i in range(11):
                        t = i / 10.0
                        point = segment.point(t)
                        ref_points.append((point.real, point.imag))
                        ref_allPoints.append((point.real, point.imag))
                elif segment_type == 'Arc':
                    ref_points.extend(segment.sample(10))
                    ref_allPoints.extend(segment.sample(10))
        height = self.calculate_bounding_box(ref_allPoints)[2]
        self.scale = self.height / height
        # end ref_symbol

        output_list = []
        for letter_path in self.path_list:
            points = []
            allPoints = []
            if letter_path == "space":
                self.x += self.space + self.character_offset
                pass
            else:
                path = parse_path(letter_path)
                for segment in path:
                    segment_type = segment.__class__.__name__
                    if segment_type == 'Move':
                        if len(points) > 0:
                            points = []
                            allPoints.append("M")
                        subpath_started = True
                    elif subpath_started:
                        if segment_type == 'Line':
                            points.extend(
                                [(segment.start.real, segment.start.imag), (segment.end.real, segment.end.imag)])
                            allPoints.extend(
                                [(segment.start.real, segment.start.imag), (segment.end.real, segment.end.imag)])
                        elif segment_type == 'CubicBezier':
                            points.extend(segment.sample(10))
                            allPoints.extend(segment.sample(10))
                        elif segment_type == 'QuadraticBezier':
                            for i in range(11):
                                t = i / 10.0
                                point = segment.point(t)
                                points.append((point.real, point.imag))
                                allPoints.append((point.real, point.imag))
                        elif segment_type == 'Arc':
                            points.extend(segment.sample(10))
                            allPoints.extend(segment.sample(10))
                if points:
                    output_list.append(
                        self.convert_points_to_polyline(allPoints))
                    width = self.calculate_bounding_box(allPoints)[1]
                    self.x += width + self.character_offset

                height = self.calculate_bounding_box(allPoints)[2]
                self.bbHeight = height
        pList = []
        for ply in flatten(output_list):
            translated = self.translate(ply)
            pList.append(translated)

        for pl in pList:
            for pt in pl.points:
                self.points.append(pt)

        # print(f'Object text naar objects gestuurd.')
        return pList

    def translate(self, polyCurve):
        trans = []
        for pt in polyCurve.points:
            pscale = Point.product(self.scale, pt)
            pNew = transform_point_2(pscale, self.csglobal)
            trans.append(pNew)
        return polyCurve.by_points(trans)

    def calculate_bounding_box(self, points):
        points = [elem for elem in points if elem != 'M']
        ptList = [Point2D(pt[0], pt[1]) for pt in points]
        bounding_box_polyline = BoundingBox2d().by_points(ptList)
        return bounding_box_polyline, bounding_box_polyline.width, bounding_box_polyline.height

    def convert_points_to_polyline(self, points: Point) -> PolyCurve:  # move
        output_list = []
        sub_lists = [[]]
        tempPoints = [elem for elem in points if elem != 'M']
        x_values = [point[0] for point in tempPoints]
        y_values = [point[1] for point in tempPoints]

        xmin = min(x_values)
        ymin = min(y_values)

        for item in points:
            if item == 'M':
                sub_lists.append([])
            else:
                x = item[0] + self.x - xmin
                y = item[1] + self.y - ymin
                z = self.xyz.z
                eput = x, y, z
                sub_lists[-1].append(eput)
        output_list = [[Point(point[0], point[1], self.xyz.z)
                        for point in element] for element in sub_lists]

        polyline_list = [
            PolyCurve.by_points(
                [Point(coord.x, coord.y, self.xyz.z) for coord in pts])
            for pts in output_list
        ]
        return polyline_list




class Vector2:
    def __init__(self, x, y) -> None:
        self.id = generateID()
        self.type = __class__.__name__
        self.x: float = 0.0
        self.y: float = 0.0
        self.x = x
        self.y = y

    def serialize(self):
        id_value = str(self.id) if not isinstance(
            self.id, (str, int, float)) else self.id
        return {
            'id': id_value,
            'type': self.type,
            'x': self.x,
            'y': self.y
        }

    @staticmethod
    def deserialize(data):
        x = data['x']
        y = data['y']
        return Vector2(x, y)

    @staticmethod
    def by_two_points(p1, p2):
        return Vector2(
            p2.x-p1.x,
            p2.y-p1.y
        )

    @staticmethod
    def length(v1):
        return math.sqrt(v1.x * v1.x + v1.y * v1.y)

    @staticmethod
    def scale(v1, scalefactor):
        return Vector2(
            v1.x * scalefactor,
            v1.y * scalefactor
        )

    @staticmethod
    def normalize(v1, axis=-1, order=2):
        v1_mat = Vector2.to_matrix(v1)
        l2_norm = math.sqrt(v1_mat[0]**2 + v1_mat[1]**2)
        if l2_norm == 0:
            l2_norm = 1

        normalized_v = [v1_mat[0] / l2_norm, v1_mat[1] / l2_norm]

        return Vector2(normalized_v[0], normalized_v[1])

    @staticmethod
    def to_matrix(self):
        return [self.x, self.y]

    @staticmethod
    def from_matrix(self):
        return Vector2(self[0], self[1])

    @staticmethod  # inwendig product, if zero, then vectors are perpendicular
    def dot_product(v1, v2):
        return v1.x*v2.x+v1.y*v2.y

    @staticmethod
    def angle_between(v1, v2):
        return math.degrees(math.acos((Vector2.dot_product(v1, v2)/(Vector2.length(v1) * Vector2.length(v2)))))

    @staticmethod
    def angle_radian_between(v1, v2):
        return math.acos((Vector2.dot_product(v1, v2)/(Vector2.length(v1) * Vector2.length(v2))))

    @staticmethod  # Returns vector perpendicular on the two vectors
    def cross_product(v1, v2):
        return Vector3(
            v1.y - v2.y,
            v2.x - v1.x,
            v1.x*v2.y - v1.y*v2.x
        )

    @staticmethod
    def reverse(v1):
        return Vector2(
            v1.x*-1,
            v1.y*-1
        )

    def __id__(self):
        return f"id:{self.id}"

    def __str__(self) -> str:
        return f"{__class__.__name__}(X = {self.x:.3f}, Y = {self.y:.3f})"


class Point2D:
    def __init__(self, x: float, y: float) -> None:
        self.id = generateID()
        self.type = __class__.__name__
        self.x = x
        self.y = y
        self.x = float(x)
        self.y = float(y)
        self.value = self.x, self.y
        self.units = "mm"

    def serialize(self):
        id_value = str(self.id) if not isinstance(
            self.id, (str, int, float)) else self.id
        return {
            'id': id_value,
            'type': self.type,
            'x': self.x,
            'y': self.y
        }

    @staticmethod
    def deserialize(data):
        x = data['x']
        y = data['y']
        return Point2D(x, y)

    def __id__(self):
        return f"id:{self.id}"

    def translate(self, vector: Vector2):
        x = self.x + vector.x
        y = self.y + vector.y
        p1 = Point2D(x, y)
        return p1

    @staticmethod
    def dot_product(p1, p2):
        return p1.x*p2.x+p1.y*p2.y

    def rotate(self, rotation):
        x = self.x
        y = self.y
        r = math.sqrt(x * x + y * y)
        rotationstart = math.degrees(math.atan2(y, x))
        rotationtot = rotationstart + rotation
        xn = round(math.cos(math.radians(rotationtot)) * r, 3)
        yn = round(math.sin(math.radians(rotationtot)) * r, 3)
        p1 = Point2D(xn, yn)
        return p1

    def __str__(self) -> str:
        return f"{__class__.__name__}(X = {self.x:.3f}, Y = {self.y:.3f})"

    @staticmethod
    def distance(point1, point2):
        return math.sqrt((point1.x - point2.x)**2 + (point1.y - point2.y)**2)

    @staticmethod
    def midpoint(point1, point2):
        return Point2D((point2.x-point1.x)/2, (point2.y-point1.y)/2)

    @staticmethod
    def to_pixel(point1, Xmin, Ymin, TotalWidth, TotalHeight, ImgWidthPix: int, ImgHeightPix: int):
        # Convert Point to pixel on a image given a deltaX, deltaY, Width of the image etc.
        x = point1.x
        y = point1.y
        xpix = math.floor(((x - Xmin) / TotalWidth) * ImgWidthPix)
        # min vanwege coord stelsel Image.Draw
        ypix = ImgHeightPix - \
            math.floor(((y - Ymin) / TotalHeight) * ImgHeightPix)
        return xpix, ypix


def transform_point_2D(PointLocal1: Point2D, CoordinateSystemNew: CoordinateSystem):
    # Transform point from Global Coordinatesystem to a new Coordinatesystem
    # CSold = CSGlobal
    PointLocal = Point(PointLocal1.x, PointLocal1.y, 0)
    # pn = Point.translate(CoordinateSystemNew.Origin, Vector3.scale(CoordinateSystemNew.Xaxis, PointLocal.x))
    # pn2 = Point2D.translate(pn, Vector3.scale(CoordinateSystemNew.Yaxis, PointLocal.y))
    pn3 = Point2D.translate(PointLocal, Vector2(
        CoordinateSystemNew.Origin.x, CoordinateSystemNew.Origin.y))
    # pn3 = Point2D(pn.x,pn.y)
    return pn3


class Line2D:
    def __init__(self, start, end) -> None:
        self.type = __class__.__name__
        self.start: Point2D = start
        self.end: Point2D = end
        self.x = [self.start.x, self.end.x]
        self.y = [self.start.y, self.end.y]
        self.dx = self.start.x-self.end.x
        self.dy = self.start.y-self.end.y
        self.vector2: Vector2 = Vector2.by_two_points(self.start, self.end)
        self.vector2_normalised = Vector2.normalize(self.vector2)
        self.length = self.length()
        self.id = generateID()

    def serialize(self):
        return {
            'type': self.type,
            'start': self.start.serialize(),
            'end': self.end.serialize(),
            'x': self.x,
            'y': self.y,
            'dx': self.dx,
            'dy': self.dy,
            'length': self.length,
            'id': self.id
        }

    @staticmethod
    def deserialize(data):
        start_point = Point2D.deserialize(data['start'])
        end_point = Point2D.deserialize(data['end'])
        return Line2D(start_point, end_point)

    def __id__(self):
        return f"id:{self.id}"

    def mid_point(self):
        vect = Vector2.scale(self.vector2, 0.5)
        mid = Point2D.translate(self.start, vect)
        return mid

    def length(self):
        return math.sqrt(math.sqrt(self.dx * self.dx + self.dy * self.dy) * math.sqrt(self.dx * self.dx + self.dy * self.dy))

    def f_line(self):
        # returns line for Folium(GIS)
        return [[self.start.y, self.start.x], [self.end.y, self.end.x]]

    def __str__(self):
        return f"{__class__.__name__}(" + f"Start: {self.start}, End: {self.end})"


class Arc2D:
    def __init__(self, pntxy1, pntxy2, pntxy3) -> None:
        self.id = generateID()
        self.type = __class__.__name__
        self.start: Point2D = pntxy1
        self.mid: Point2D = pntxy2
        self.end: Point2D = pntxy3
        self.origin = self.origin_arc()
        self.angle_radian = self.angle_radian()
        self.radius = self.radius_arc()
        # self.radius = self.radius_arc()
        self.coordinatesystem = self.coordinatesystem_arc()
        # self.length

    def serialize(self):
        id_value = str(self.id) if not isinstance(
            self.id, (str, int, float)) else self.id
        return {
            'id': id_value,
            'type': self.type,
            'start': self.start.serialize(),
            'mid': self.mid.serialize(),
            'end': self.end.serialize(),
            'origin': self.origin,
            'angle_radian': self.angle_radian,
            'coordinatesystem': self.coordinatesystem
        }

    @staticmethod
    def deserialize(data):
        start_point = Point2D.deserialize(data['start'])
        mid_point = Point2D.deserialize(data['mid'])
        end_point = Point2D.deserialize(data['end'])
        arc = Arc2D(start_point, mid_point, end_point)

        arc.origin = data.get('origin')
        arc.angle_radian = data.get('angle_radian')
        arc.coordinatesystem = data.get('coordinatesystem')

        return arc

    def __id__(self):
        return f"id:{self.id}"

    def points(self):
        # returns point on the curve
        return (self.start, self.mid, self.end)

    def coordinatesystem_arc(self):
        vx2d = Vector2.by_two_points(self.origin, self.start)  # Local X-axe
        vx = Vector3(vx2d.x, vx2d.y, 0)
        vy = Vector3(vx.y, vx.x * -1, 0)
        vz = Vector3(0, 0, 1)
        self.coordinatesystem = CoordinateSystem(self.origin, Vector3.normalize(
            vx), Vector3.normalize(vy), Vector3.normalize(vz))
        return self.coordinatesystem

    def angle_radian(self):
        v1 = Vector2.by_two_points(self.origin, self.end)
        v2 = Vector2.by_two_points(self.origin, self.start)
        angle = Vector2.angle_radian_between(v1, v2)
        return angle

    def origin_arc(self):
        # calculation of origin of arc #Todo can be simplified for sure
        Vstartend = Vector2.by_two_points(self.start, self.end)
        halfVstartend = Vector2.scale(Vstartend, 0.5)
        # half distance between start and end
        b = 0.5 * Vector2.length(Vstartend)
        try:
            # distance from start-end line to origin
            x = math.sqrt(Arc2D.radius_arc(self) *
                          Arc2D.radius_arc(self) - b * b)
        except:
            x = 0
        mid = Point2D.translate(self.start, halfVstartend)
        v2 = Vector2.by_two_points(self.mid, mid)
        v3 = Vector2.normalize(v2)
        tocenter = Vector2.scale(v3, x)
        center = Point2D.translate(mid, tocenter)
        self.origin = center
        return center

    def radius_arc(self):
        a = Vector2.length(Vector2.by_two_points(self.start, self.mid))
        b = Vector2.length(Vector2.by_two_points(self.mid, self.end))
        c = Vector2.length(Vector2.by_two_points(self.end, self.start))
        s = (a + b + c) / 2
        A = math.sqrt(s * (s-a) * (s-b) * (s-c))
        R = (a * b * c) / (4 * A)
        return R

    @staticmethod
    def points_at_parameter(arc, count: int):
        # ToDo can be simplified. Now based on the 3D variant
        d_alpha = arc.angle_radian / (count - 1)
        alpha = 0
        pnts = []
        for i in range(count):
            pnts.append(Point2D(arc.radius * math.cos(alpha),
                        arc.radius * math.sin(alpha)))
            alpha = alpha + d_alpha
        CSNew = arc.coordinatesystem
        pnts2 = []
        for i in pnts:
            pnts2.append(transform_point_2D(i, CSNew))
        return pnts2

    @staticmethod
    def segmented_arc(arc, count):
        pnts = Arc2D.points_at_parameter(arc, count)
        i = 0
        lines = []
        for j in range(len(pnts)-1):
            lines.append(Line2D(pnts[i], pnts[i+1]))
            i = i + 1
        return lines

    def __str__(self):
        return f"{__class__.__name__}({self.start},{self.mid},{self.end})"


class PolyCurve2D:
    def __init__(self) -> None:
        self.id = generateID()
        self.type = __class__.__name__
        self.curves = []
        self.points2D = []
        self.segmentcurves = None
        self.width = None
        self.height = None
        self.approximateLength = None
        self.graphicsStyleId = None
        self.isClosed = None
        self.isCyclic = None
        self.isElementGeometry = None
        self.isReadOnly = None
        self.length = self.length()
        self.period = None
        self.reference = None
        self.visibility = None

    def serialize(self):
        curves_serialized = [curve.serialize() if hasattr(
            curve, 'serialize') else str(curve) for curve in self.curves]
        points_serialized = [point.serialize() if hasattr(
            point, 'serialize') else str(point) for point in self.points2D]

        return {
            'type': self.type,
            'curves': curves_serialized,
            'points2D': points_serialized,
            'segmentcurves': self.segmentcurves,
            'width': self.width,
            'height': self.height,
            'approximateLength': self.approximateLength,
            'graphicsStyleId': self.graphicsStyleId,
            'id': self.id,
            'isClosed': self.isClosed,
            'isCyclic': self.isCyclic,
            'isElementGeometry': self.isElementGeometry,
            'isReadOnly': self.isReadOnly,
            'period': self.period,
            'reference': self.reference,
            'visibility': self.visibility
        }

    @staticmethod
    def deserialize(data):
        polycurve = PolyCurve2D()
        polycurve.segmentcurves = data.get('segmentcurves')
        polycurve.width = data.get('width')
        polycurve.height = data.get('height')
        polycurve.approximateLength = data.get('approximateLength')
        polycurve.graphicsStyleId = data.get('graphicsStyleId')
        polycurve.id = data.get('id')
        polycurve.isClosed = data.get('isClosed')
        polycurve.isCyclic = data.get('isCyclic')
        polycurve.isElementGeometry = data.get('isElementGeometry')
        polycurve.isReadOnly = data.get('isReadOnly')
        polycurve.period = data.get('period')
        polycurve.reference = data.get('reference')
        polycurve.visibility = data.get('visibility')

        if 'curves' in data:
            for curve_data in data['curves']:
                curve = Line2D.deserialize(curve_data)
                polycurve.curves.append(curve)

        if 'points2D' in data:
            for point_data in data['points2D']:
                point = Point2D.deserialize(point_data)
                polycurve.points2D.append(point)

        return polycurve

    def __id__(self):
        return f"id:{self.id}"

    @classmethod  # curves or curves?
    def by_joined_curves(cls, curves):
        if not curves or len(curves) < 1:
            raise ValueError(
                "At least one curve is required to create a PolyCurve2D.")

        polycurve = cls()
        for curve in curves:
            if not polycurve.points2D or polycurve.points2D[-1] != curve.start:
                polycurve.points2D.append(curve.start)
            polycurve.curves.append(curve)
            polycurve.points2D.append(curve.end)

        polycurve.isClosed = polycurve.points2D[0].value == polycurve.points2D[-1].value
        if project.autoclose == True and polycurve.isClosed == False:
            polycurve.curves.append(
                Line2D(start=curves[-1].end, end=curves[0].start))
            polycurve.points2D.append(curves[0].start)
            polycurve.isClosed = True
        return polycurve

    def points(self):
        for i in self.curves:
            self.points2D.append(i.start)
            self.points2D.append(i.end)
        return self.points2D

    def centroid(self) -> Point2D:
        if not self.isClosed or len(self.points2D) < 3:
            return "Polygon has less than 3 points or is not closed!"

        num_points = len(self.points2D)
        signed_area = 0
        centroid_x = 0
        centroid_y = 0

        for i in range(num_points):
            x0, y0 = self.points2D[i].x, self.points2D[i].y
            if i == num_points - 1:
                x1, y1 = self.points2D[0].x, self.points2D[0].y
            else:
                x1, y1 = self.points2D[i + 1].x, self.points2D[i + 1].y

            cross = x0 * y1 - x1 * y0
            signed_area += cross
            centroid_x += (x0 + x1) * cross
            centroid_y += (y0 + y1) * cross

        signed_area *= 0.5
        centroid_x /= (6.0 * signed_area)
        centroid_y /= (6.0 * signed_area)

        return Point2D(x=round(centroid_x, project.decimals), y=round(centroid_y, project.decimals))

    @staticmethod
    def from_polycurve_3D(PolyCurve):
        points = []
        for pt in PolyCurve.points:
            points.append(Point2D.toPoint2D(pt))
        plycrv = PolyCurve2D.by_points(points)
        return plycrv

    def area(self) -> float:  # shoelace formula
        if not self.isClosed or len(self.points2D) < 3:
            return "Polygon has less than 3 points or is not closed!"

        num_points = len(self.points2D)
        area = 0

        for i in range(num_points):
            x0, y0 = self.points2D[i].x, self.points2D[i].y
            if i == num_points - 1:
                x1, y1 = self.points2D[0].x, self.points2D[0].y
            else:
                x1, y1 = self.points2D[i + 1].x, self.points2D[i + 1].y

            area += x0 * y1 - x1 * y0

        area = abs(area) / 2.0
        return area

    def close(self) -> bool:
        if self.curves[0] == self.curves[-1]:
            return self
        else:
            self.curves.append(self.curves[0])
            plycrv = PolyCurve2D()
            for curve in self.curves:
                plycrv.curves.append(curve)
        return plycrv

    def scale(self, scalefactor):
        crvs = []
        for i in self.curves:
            if i.__class__.__name__ == "Arc":
                arcie = Arc2D(Point2D.product(scalefactor, i.start),
                              Point2D.product(scalefactor, i.end))
                arcie.mid = Point2D.product(scalefactor, i.mid)
                crvs.append(arcie)
            elif i.__class__.__name__ == "Line":
                crvs.append(Line2D(Point2D.product(
                    scalefactor, i.start), Point2D.product(scalefactor, i.end)))
            else:
                print("Curvetype not found")
        crv = PolyCurve2D.by_joined_curves(crvs)
        return crv

    @classmethod
    def by_points(cls, points):
        if not points or len(points) < 2:
            pass

        polycurve = cls()
        for i in range(len(points)):
            polycurve.points2D.append(points[i])
            if i < len(points) - 1:
                polycurve.curves.append(
                    Line2D(start=points[i], end=points[i+1]))

        polycurve.isClosed = points[0] == points[-1]
        if project.autoclose == True:
            polycurve.curves.append(Line2D(start=points[-1], end=points[0]))
            polycurve.points2D.append(points[0])
            polycurve.isClosed = True
        return polycurve

    def get_width(self) -> float:
        x_values = [point.x for point in self.points2D]
        y_values = [point.y for point in self.points2D]

        min_x = min(x_values)
        max_x = max(x_values)
        min_y = min(y_values)
        max_y = max(y_values)

        left_top = Point2D(x=min_x, y=max_y)
        left_bottom = Point2D(x=min_x, y=min_y)
        right_top = Point2D(x=max_x, y=max_y)
        right_bottom = Point2D(x=max_x, y=min_y)
        self.width = abs(Point2D.distance(left_top, right_top))
        self.height = abs(Point2D.distance(left_top, left_bottom))
        return self.width

    def length(self) -> float:
        lst = []
        for line in self.curves:
            lst.append(line.length)

        return sum(i.length for i in self.curves)

    @staticmethod
    def by_polycurve_2D(PolyCurve2D):
        plycrv = PolyCurve2D()
        curves = []
        for i in PolyCurve2D.curves:
            if i.__class__.__name__ == "Arc2D":
                curves.append(Arc2D(Point2D(i.start.x, i.start.y), Point2D(
                    i.mid.x, i.mid.y), Point2D(i.end.x, i.end.y)))
            elif i.__class__.__name__ == "Line2D":
                curves.append(
                    Line2D(Point2D(i.start.x, i.start.y), Point2D(i.end.x, i.end.y)))
            else:
                print("Curvetype not found")
        pnts = []
        for i in curves:
            pnts.append(i.start)
        pnts.append(curves[0].start)
        plycrv.points = pnts
        plycrv.curves = curves
        return plycrv

    def multi_split(self, lines: Line2D):
        lines = flatten(lines)
        new_polygons = []
        for index, line in enumerate(lines):
            if index == 0:
                n_p = self.split(line, returnlines=True)
                if n_p != None:
                    for nxp in n_p:
                        if nxp != None:
                            new_polygons.append(n_p)
            else:
                for new_poly in flatten(new_polygons):
                    n_p = new_poly.split(line, returnlines=True)
                    if n_p != None:
                        for nxp in n_p:
                            if nxp != None:
                                new_polygons.append(n_p)
        project.objects.append(flatten(new_polygons))
        return flatten(new_polygons)

    def translate(self, vector2d: Vector2):
        crvs = []
        v1 = vector2d
        for i in self.curves:
            if i.__class__.__name__ == "Arc2D":
                crvs.append(Arc2D(i.start.translate(v1),
                            i.mid.translate(v1), i.end.translate(v1)))
            elif i.__class__.__name__ == "Line2D":
                crvs.append(Line2D(i.start.translate(v1), i.end.translate(v1)))
            else:
                print("Curvetype not found")
        crv = PolyCurve2D.by_joined_curves(crvs)
        return crv

    @staticmethod
    def copy_translate(pc, vector3d: Vector3):
        crvs = []
        v1 = vector3d
        for i in pc.curves:
            if i.__class__.__name__ == "Line":
                crvs.append(Line2D(Point2D.translate(i.start, v1),
                            Point2D.translate(i.end, v1)))
            else:
                print("Curvetype not found")

        PCnew = PolyCurve2D.by_joined_curves(crvs)
        return PCnew

    def rotate(self, rotation):
        crvs = []
        for i in self.curves:
            if i.__class__.__name__ == "Arc2D":
                crvs.append(Arc2D(i.start.rotate(rotation),
                            i.mid.rotate(rotation), i.end.rotate(rotation)))
            elif i.__class__.__name__ == "Line2D":
                crvs.append(Line2D(i.start.rotate(
                    rotation), i.end.rotate(rotation)))
            else:
                print("Curvetype not found")
        crv = PolyCurve2D.by_joined_curves(crvs)
        return crv

    @staticmethod
    def boundingbox_global_CS(PC):
        x = []
        y = []
        for i in PC.curves():
            x.append(i.start.x)
            y.append(i.start.y)
        xmin = min(x)
        xmax = max(x)
        ymin = min(y)
        ymax = max(y)
        bbox = PolyCurve2D.by_points([Point2D(xmin, ymin), Point2D(
            xmax, ymin), Point2D(xmax, ymax), Point2D(xmin, ymax), Point2D(xmin, ymin)])
        return bbox

    @staticmethod
    def bounds(PC):
        # returns xmin,xmax,ymin,ymax,width,height of polycurve 2D
        x = []
        y = []
        for i in PC.curves:
            x.append(i.start.x)
            y.append(i.start.y)
        xmin = min(x)
        xmax = max(x)
        ymin = min(y)
        ymax = max(y)
        width = xmax-xmin
        height = ymax-ymin
        return xmin, xmax, ymin, ymax, width, height

    @classmethod
    def unclosed_by_points(self, points: Point2D):
        plycrv = PolyCurve2D()
        for index, point in enumerate(points):
            plycrv.points2D.append(point)
            try:
                nextpoint = points[index + 1]
                plycrv.curves.append(Line2D(start=point, end=nextpoint))
            except:
                pass
        return plycrv

    @staticmethod
    def polygon(self):
        points = []
        for i in self.curves:
            if i == Arc2D:
                points.append(i.start, i.mid)
            else:
                points.append(i.start)
        points.append(points[0])
        return points

    @staticmethod
    def segment(self, count):
        crvs = []
        for i in self.curves:
            if i.__class__.__name__ == "Arc2D":
                crvs.append(Arc2D.segmented_arc(i, count))
            elif i.__class__.__name__ == "Line2D":
                crvs.append(i)
        crv = flatten(crvs)
        pc = PolyCurve2D.by_joined_curves(crv)
        return pc

    def to_polycurve_2D(self):

        p1 = PolyCurve2D()
        curves = []
        for i in self.curves:
            if i.__class__.__name__ == "Arc":
                curves.append(Arc2D(Point2D(i.start.x, i.start.y), Point2D(i.middle.x, i.middle.y),
                                    Point2D(i.end.x, i.end.y)))
            elif i.__class__.__name__ == "Line":
                curves.append(
                    Line2D(Point2D(i.start.x, i.start.y), Point2D(i.end.x, i.end.y)))
            else:
                print("Curvetype not found")
        pnts = []
        for i in curves:
            pnts.append(i.start)
        pnts.append(curves[0].start)
        p1.points2D = pnts
        p1.curves = curves
        return p1

    @staticmethod
    def transform_from_origin(polycurve, startpoint: Point2D, directionvector: Vector3):
        crvs = []
        for i in polycurve.curves:
            if i.__class__.__name__ == "Arc2D":
                crvs.append(Arc2D(transform_point_2D(i.start, project.CSGlobal, startpoint, directionvector),
                                  transform_point_2D(
                                      i.mid, project.CSGlobal, startpoint, directionvector),
                                  transform_point_2D(
                                      i.end, project.CSGlobal, startpoint, directionvector)
                                  ))
            elif i.__class__.__name__ == "Line2D":
                crvs.append(Line2D(start=transform_point_2D(i.start, project.CSGlobal, startpoint, directionvector),
                                   end=transform_point_2D(
                                       i.end, project.CSGlobal, startpoint, directionvector)
                                   ))
            else:
                print(i.__class__.__name__ + "Curvetype not found")
        pc = PolyCurve2D()
        pc.curves = crvs
        return pc

    def __str__(self):
        l = len(self.points2D)
        return f"{__class__.__name__}, ({l} points)"


class Surface2D:
    def __init__(self) -> None:
        pass  # PolyCurve2D
        self.id = generateID()
        self.type = __class__.__name__

    def __id__(self):
        return f"id:{self.id}"

    def __str__(self) -> str:
        return f"{__class__.__name__}({self})"


class Profile2D:
    def __init__(self) -> None:
        self.id = generateID()
        self.type = __class__.__name__

    def __id__(self):
        return f"id:{self.id}"

    def __str__(self) -> str:
        return f"{__class__.__name__}({self})"


class ParametricProfile2D:
    def __init__(self) -> None:
        self.type = __class__.__name__
        self.id = generateID()

    def __id__(self):
        return f"id:{self.id}"

    def __str__(self) -> str:
        return f"{__class__.__name__}({self})"




class Intersect:
    def __init__(self):
        pass

    def get_line_intersect(line1: Line, line2: Line) -> Point:
        p1, p2 = line1.start, line1.end
        p1X, p1Y, P1Z = p1.x, p1.y, p1.z
        p2X, p2Y, P2Z = p2.x, p2.y, p2.z

        p3, p4 = line2.start, line2.end
        p3X, p3Y, P3Z = p3.x, p3.y, p3.z
        p4X, p4Y, P4Z = p4.x, p4.y, p4.z

        print(p1X, p1Y, P1Z)




def perp(a):
    b = [None] * len(a)
    b[0] = -a[1]
    b[1] = a[0]
    return b


def get_line_intersect(line_1, line_2):
    if line_1.start == line_1.end or line_2.start == line_2.end:
        return None

    p1, p2 = line_1.start, line_1.end
    p1X, p1Y = p1.x, p1.y
    p2X, p2Y = p2.x, p2.y

    p3, p4 = line_2.start, line_2.end
    p3X, p3Y = p3.x, p3.y
    p4X, p4Y = p4.x, p4.y

    da = [p2X - p1X, p2Y - p1Y]
    db = [p4X - p3X, p4Y - p3Y]
    dp = [p1X - p3X, p1Y - p3Y]
    dap = perp(da)
    denom = dap[0] * db[0] + dap[1] * db[1]
    if abs(denom) < 1e-6:
        return None
    num = dap[0] * dp[0] + dap[1] * dp[1]
    t = num / denom
    nX, nY = p3X + t * db[0], p3Y + t * db[1]

    return Point2D(nX, nY)


def get_multi_lines_intersect(lines: list[Line2D]) -> list[Point2D]:
    pts = []
    for i in range(len(lines)):
        line1 = lines[i]
        for j in range(i+1, len(lines)):
            line2 = lines[j]
            intersection = get_line_intersect(line1, line2)
            if intersection not in pts and intersection != None and is_point_on_line_segment(intersection, line2) == True:
                pts.append(intersection)
    return pts


def get_intersect_polycurve_lines(polycurve: PolyCurve2D, lines: list[Line2D], split: bool = False, stretch: bool = False):
    dict = {}
    intersectionsPointsList = []
    splitedLinesList = []
    InnerGridLines = []
    OuterGridLines = []
    if isinstance(lines, Line2D):
        lines = [lines]
    elif lines.type == "Line":
        print("Convert Line(s) to Line2D")
        sys.exit()
    else:
        print(f"Incorrect input: {lines}")
    for line in lines:
        IntersectGridPoints = []
        for i in range(len(polycurve.points2D) - 1):
            genLine = Line2D(polycurve.points2D[i], polycurve.points2D[i+1])
            checkIntersect = get_line_intersect(genLine, line)
            if stretch == False:
                if checkIntersect != None:
                    if is_point_on_line_segment(checkIntersect, line) == False:
                        checkIntersect = None
                    else:
                        minX = min(
                            polycurve.points2D[i].x, polycurve.points2D[i+1].x)
                        maxX = max(
                            polycurve.points2D[i].x, polycurve.points2D[i+1].x)
                        minY = min(
                            polycurve.points2D[i].y, polycurve.points2D[i+1].y)
                        maxY = max(
                            polycurve.points2D[i].y, polycurve.points2D[i+1].y)
                    if checkIntersect != None:
                        if minX <= checkIntersect.x <= maxX and minY <= checkIntersect.y <= maxY:
                            intersectionsPointsList.append(checkIntersect)
                            IntersectGridPoints.append(checkIntersect)

            elif stretch == True:
                minX = min(polycurve.points2D[i].x, polycurve.points2D[i+1].x)
                maxX = max(polycurve.points2D[i].x, polycurve.points2D[i+1].x)
                minY = min(polycurve.points2D[i].y, polycurve.points2D[i+1].y)
                maxY = max(polycurve.points2D[i].y, polycurve.points2D[i+1].y)
                if checkIntersect != None:
                    if minX <= checkIntersect.x <= maxX and minY <= checkIntersect.y <= maxY:
                        intersectionsPointsList.append(checkIntersect)
                        IntersectGridPoints.append(checkIntersect)

        if split == True:
            if len(IntersectGridPoints) > 0:
                splitedLinesList.append(line.split(IntersectGridPoints))

    for splittedLines in splitedLinesList:
        for line in splittedLines:
            centerLinePoint = line.point_at_parameter(0.5)
            if is_point_in_polycurve(centerLinePoint, polycurve) == True:
                InnerGridLines.append(line)
            else:
                OuterGridLines.append(line)

    dict["IntersectGridPoints"] = intersectionsPointsList
    dict["SplittedLines"] = flatten(splitedLinesList)
    dict["InnerGridLines"] = InnerGridLines
    dict["OuterGridLines"] = OuterGridLines

    return dict


def is_point_on_line_segment(point: Point2D, line: Line2D) -> bool:
    x_min = min(line.start.x, line.end.x)
    x_max = max(line.start.x, line.end.x)
    y_min = min(line.start.y, line.end.y)
    y_max = max(line.start.y, line.end.y)

    if x_min <= point.x <= x_max and y_min <= point.y <= y_max:
        try:
            distance = abs((line.end.y - line.start.y) * point.x
                           - (line.end.x - line.start.x) * point.y
                           + line.end.x * line.start.y
                           - line.end.y * line.start.x) \
                / line.length
            return distance < 1e-9
        except:
            return False
    return False


def get_intersection_polycurve_polycurve(polycurve_1: PolyCurve2D, polycurve_2: PolyCurve2D) -> list[Point2D]:
    points = []
    for i in range(len(polycurve_1.points2D) - 1):
        line1 = Line2D(polycurve_1.points2D[i], polycurve_1.points2D[i+1])
        for j in range(len(polycurve_2.points2D) - 1):
            line2 = Line2D(polycurve_2.points2D[j], polycurve_2.points2D[j+1])
            intersection = get_line_intersect(line1, line2)
            if intersection and is_point_on_line_segment(intersection, line1) and is_point_on_line_segment(intersection, line2):
                points.append(intersection)
    return points


def split_polycurve_at_intersections(polycurve: PolyCurve2D, points: list[Point2D]) -> list[PolyCurve2D]:
    points.sort(key=lambda pt: Point2D.distance(polycurve.points2D[0], pt))

    current_polycurve_points = [polycurve.points2D[0]]
    created_polycurves = []

    for i in range(1, len(polycurve.points2D)):
        segment_start = polycurve.points2D[i - 1]
        segment_end = polycurve.points2D[i]

        segment_intersections = [pt for pt in points if is_point_on_line_segment(
            pt, Line2D(segment_start, segment_end))]

        segment_intersections.sort(
            key=lambda pt: Point2D.distance(segment_start, pt))

        for intersect in segment_intersections:
            current_polycurve_points.append(intersect)
            created_polycurves.append(
                polycurve.by_points(current_polycurve_points))
            current_polycurve_points = [intersect]
            points.remove(intersect)

        current_polycurve_points.append(segment_end)

    if len(current_polycurve_points) > 1:
        created_polycurves.append(
            polycurve.by_points(current_polycurve_points))

    ptlist = []
    for index, pc in enumerate(created_polycurves):
        if index == 0:
            for pt in pc.points2D:
                ptlist.append(pt)
        elif index == 2:
            for pt in pc.points2D:
                ptlist.append(pt)
                ptlist.append(ptlist[1])

    pcurve = polycurve().by_points(ptlist)

    try:
        return [created_polycurves[1], pcurve]
    except:
        return [created_polycurves[0]]


# extend to if on edge, then accept
def is_point_in_polycurve(point: Point2D, polycurve: PolyCurve2D) -> bool:
    x, y = point.x, point.y
    intersections = 0
    for curve in polycurve.curves:
        p1, p2 = curve.start, curve.end
        if (y > min(p1.y, p2.y)) and (y <= max(p1.y, p2.y)) and (x <= max(p1.x, p2.x)):
            if p1.y != p2.y:
                x_inters = (y - p1.y) * (p2.x - p1.x) / (p2.y - p1.y) + p1.x
                if (p1.x == p2.x) or (x <= x_inters):
                    intersections += 1
    return intersections % 2 != 0


def is_polycurve_in_polycurve(polycurve_1: PolyCurve2D, polycurve_2: PolyCurve2D) -> bool:
    colList = []
    for pt in polycurve_1.points2D:
        if is_point_in_polycurve(pt, polycurve_2):
            colList.append(True)
        else:
            colList.append(False)

    if all_true(colList):
        return True
    else:
        return False


def plane_line_intersection():
    line_dir = [1, 2, 3]
    line_pt = [0, 0, 0]

    plane_norm = [4, 5, 6]
    plane_pt = [1, 1, 1]

    dot_prod = sum([a*b for a, b in zip(line_dir, plane_norm)])

    if dot_prod == 0:
        print("The line is parallel to the plane. No intersection point.")
    else:
        t = sum([(a-b)*c for a, b, c in zip(plane_pt,
                line_pt, plane_norm)]) / dot_prod

        inter_pt = [a + b*t for a, b in zip(line_pt, line_dir)]

        print("The intersection point is", inter_pt)


def split_polycurve_by_points(polycurve: PolyCurve2D, points: list[Point2D]) -> list[PolyCurve2D]:

    def splitCurveAtPoint(curve, point):
        if is_point_on_line_segment(point, curve):
            return curve.split([point])
        return [curve]

    split_curves = []
    for curve in polycurve.curves:
        current_curves = [curve]
        for point in points:
            new_curves = []
            for c in current_curves:
                new_curves.extend(splitCurveAtPoint(c, point))
            current_curves = new_curves
        split_curves.extend(current_curves)

    return split_curves


def is_on_line(line: Line2D, point: Point2D) -> bool:
    if line.start == Point2D or line.end == Point2D:
        return True
    return False


def split_polycurve_by_line(polycurve: PolyCurve2D, line: Line2D) -> dict[PolyCurve2D]:
    dict = {}
    pcList = []
    nonsplitted = []
    intersect = get_intersect_polycurve_lines(
        polycurve, line, split=False, stretch=False)
    intersect_points = intersect["IntersectGridPoints"]
    if len(intersect_points) != 2:
        nonsplitted.append(polycurve)
        dict["inputPolycurve"] = [polycurve]
        dict["splittedPolycurve"] = pcList
        dict["nonsplittedPolycurve"] = nonsplitted
        dict["IntersectGridPoints"] = intersect_points
        return dict

    SegsandPoints = []

    for Line in polycurve.curves:
        for intersect_point in intersect_points:
            if is_point_on_line_segment(intersect_point, Line):
                SegsandPoints.append(intersect_point)
                SegsandPoints.append(intersect_point)

        SegsandPoints.append(Line)

    elementen = []
    for item in SegsandPoints:
        elementen.append(item)

    split_lists = []
    current_list = []

    for element in elementen:
        current_list.append(element)

        if len(current_list) > 1 and current_list[-1].type == current_list[-2].type == 'Point2D':
            split_lists.append(current_list[:-1])
            current_list = [element]

    if current_list:
        split_lists.append(current_list)

    merged_list = split_lists[-1] + split_lists[0]

    lijsten = [merged_list, split_lists[1]]

    for lijst in lijsten:
        q = []
        for i in lijst:
            if i.type == "Line2D":
                q.append(i.end)
            elif i.type == "Point2D":
                q.append(i)
        pc = PolyCurve2D.by_points(q)
        pcList.append(pc)

    dict["inputPolycurve"] = [polycurve]
    dict["splittedPolycurve"] = pcList
    dict["nonsplittedPolycurve"] = nonsplitted
    dict["IntersectGridPoints"] = intersect_points

    return dict



# Rule: line, whitespace, line whitespace etc., scale
HiddenLine1 = ["Hidden Line 1", [1, 1], 100]
# Rule: line, whitespace, line whitespace etc., scale
HiddenLine2 = ["Hidden Line 2", [2, 1], 100]
# Rule: line, whitespace, line whitespace etc., scale
Centerline = ["Center Line 1", [8, 2, 2, 2], 100]


def line_to_pattern(baseline, patternobj):
    # this converts a line to list of lines based on a pattern
    origin = baseline.start
    dir = Vector3.by_two_points(baseline.start, baseline.end)
    unityvect = Vector3.normalize(dir)

    Pattern = patternobj
    l = baseline.length
    patternlength = sum(Pattern[1]) * Pattern[2]
    # number of whole lengths of the pattern
    count = math.floor(l / patternlength)
    lines = []

    startpoint = origin
    ll = 0
    rl = 10000
    for i in range(count + 1):
        n = 0
        for i in Pattern[1]:
            deltaV = Vector3.product(i * Pattern[2], unityvect)
            dl = Vector3.length(deltaV)
            if rl < dl:  # this is the last line segment on the line where the pattern is going to be cut into pieces.
                endpoint = baseline.end
            else:
                endpoint = Point.translate(startpoint, deltaV)
            if n % 2:
                a = 1 + 1
            else:
                lines.append(Line(start=startpoint, end=endpoint))
            if rl < dl:
                break  # end of line reached
            startpoint = endpoint
            n = n + 1
            ll = ll + dl  # total length
            rl = l - ll  # remaining length within the pattern
        startpoint = startpoint
    return lines




class Extrusion:
    # Extrude a 2D profile to a 3D mesh or solid
    def __init__(self):
        self.id = generateID()
        self.type = __class__.__name__
        self.parameters = []
        self.verts = []
        self.faces = []
        self.numberFaces = 0
        # total number of verts per face (not the same as total verts)
        self.countVertsFaces = 0
        self.name = None
        self.color = (255, 255, 0)
        self.colorlst = []
        self.topface = None  # return polycurve -> surface
        self.bottomface = None  # return polycurve -> surface
        self.polycurve_3d_translated = None
        self.bottomshape = []

    def serialize(self):
        id_value = str(self.id) if not isinstance(
            self.id, (str, int, float)) else self.id
        return {
            'id': id_value,
            'type': self.type,
            'verts': self.verts,
            'faces': self.faces,
            'numberFaces': self.numberFaces,
            'countVertsFaces': self.countVertsFaces,
            'name': self.name,
            'color': self.color,
            'colorlst': self.colorlst,
            'topface': self.topface.serialize() if self.topface else None,
            'bottomface': self.bottomface.serialize() if self.bottomface else None,
            'polycurve_3d_translated': self.polycurve_3d_translated.serialize() if self.polycurve_3d_translated else None
        }

    @staticmethod
    def deserialize(data):
        extrusion = Extrusion()
        extrusion.id = data.get('id')
        extrusion.verts = data.get('verts', [])
        extrusion.faces = data.get('faces', [])
        extrusion.numberFaces = data.get('numberFaces', 0)
        extrusion.countVertsFaces = data.get('countVertsFaces', 0)
        extrusion.name = data.get('name', "none")
        extrusion.color = data.get('color', (255, 255, 0))
        extrusion.colorlst = data.get('colorlst', [])

        if data.get('topface'):
            extrusion.topface = PolyCurve.deserialize(data['topface'])

        if data.get('bottomface'):
            extrusion.bottomface = PolyCurve.deserialize(data['bottomface'])

        if data.get('polycurve_3d_translated'):
            extrusion.polycurve_3d_translated = PolyCurve.deserialize(
                data['polycurve_3d_translated'])

        return extrusion

    def set_parameter(self, data):
        self.parameters = data
        return self

    @classmethod
    def merge(self, extrusions: list, name=None):
        Outrus = Extrusion()
        if isinstance(extrusions, list):
            Outrus.verts = []
            Outrus.faces = []
            Outrus.colorlst = []
            for ext in extrusions:
                Outrus.verts.append(ext.verts)
                Outrus.faces.append(ext.faces)
                Outrus.colorlst.append(ext.colorlst)
            Outrus.verts = flatten(Outrus.verts)
            Outrus.faces = flatten(Outrus.faces)
            Outrus.colorlst = flatten(Outrus.colorlst)
            return Outrus

        elif isinstance(extrusions, Extrusion):
            return extrusions

    @classmethod
    def by_polycurve_height_vector(self, polycurve2d: PolyCurve2D, height, CSOld, startpoint, DirectionVector: Vector3):
        Extrus = Extrusion()
        # 2D PolyCurve @ Global origin
        count = 0

        Extrus.polycurve_3d_translated = PolyCurve.transform_from_origin(
            polycurve2d, startpoint, DirectionVector)

        try:
            for i in polycurve2d.curves:
                startpointLow = transform_point(
                    Point(i.start.x, i.start.y, 0), CSOld, startpoint, DirectionVector)
                endpointLow = transform_point(
                    Point(i.end.x, i.end.y, 0), CSOld, startpoint, DirectionVector)
                endpointHigh = transform_point(
                    Point(i.end.x, i.end.y, height), CSOld, startpoint, DirectionVector)
                startpointHigh = transform_point(
                    Point(i.start.x, i.start.y, height), CSOld, startpoint, DirectionVector)

                # Construct faces perpendicular on polycurve
                Extrus.faces.append(4)
                Extrus.verts.append(startpointLow.x)
                Extrus.verts.append(startpointLow.y)
                Extrus.verts.append(startpointLow.z)
                Extrus.faces.append(count)
                count += 1
                Extrus.verts.append(endpointLow.x)
                Extrus.verts.append(endpointLow.y)
                Extrus.verts.append(endpointLow.z)
                Extrus.faces.append(count)
                count += 1
                Extrus.verts.append(endpointHigh.x)
                Extrus.verts.append(endpointHigh.y)
                Extrus.verts.append(endpointHigh.z)
                Extrus.faces.append(count)
                count += 1
                Extrus.verts.append(startpointHigh.x)
                Extrus.verts.append(startpointHigh.y)
                Extrus.verts.append(startpointHigh.z)
                Extrus.faces.append(count)
                count += 1
                Extrus.numberFaces = Extrus.numberFaces + 1

            # bottomface
            Extrus.faces.append(len(polycurve2d.curves))

            count = 0
            for i in polycurve2d.curves:
                Extrus.faces.append(count)
                Extrus.bottomshape.append(i)
                count = count + 4

            # topface
            Extrus.faces.append(len(polycurve2d.curves))
            count = 3
            for i in polycurve2d.curves:
                Extrus.faces.append(count)
                count = count + 4
        except:
            for i in polycurve2d.curves:
                startpointLow = transform_point(
                    Point(i.start.x, i.start.y, 0), CSOld, startpoint, DirectionVector)
                endpointLow = transform_point(
                    Point(i.end.x, i.end.y, 0), CSOld, startpoint, DirectionVector)
                endpointHigh = transform_point(
                    Point(i.end.x, i.end.y, height), CSOld, startpoint, DirectionVector)
                startpointHigh = transform_point(
                    Point(i.start.x, i.start.y, height), CSOld, startpoint, DirectionVector)

                # Construct faces perpendicular on polycurve
                Extrus.faces.append(4)
                Extrus.verts.append(startpointLow.x)
                Extrus.verts.append(startpointLow.y)
                Extrus.verts.append(startpointLow.z)
                Extrus.faces.append(count)
                count += 1
                Extrus.verts.append(endpointLow.x)
                Extrus.verts.append(endpointLow.y)
                Extrus.verts.append(endpointLow.z)
                Extrus.faces.append(count)
                count += 1
                Extrus.verts.append(endpointHigh.x)
                Extrus.verts.append(endpointHigh.y)
                Extrus.verts.append(endpointHigh.z)
                Extrus.faces.append(count)
                count += 1
                Extrus.verts.append(startpointHigh.x)
                Extrus.verts.append(startpointHigh.y)
                Extrus.verts.append(startpointHigh.z)
                Extrus.faces.append(count)
                count += 1
                Extrus.numberFaces = Extrus.numberFaces + 1

            # bottomface
            Extrus.faces.append(len(polycurve2d.curves))

            count = 0
            for i in polycurve2d.curves:
                Extrus.faces.append(count)
                Extrus.bottomshape.append(i)
                count = count + 4

            # topface
            Extrus.faces.append(len(polycurve2d.curves))
            count = 3
            for i in polycurve2d.curves:
                Extrus.faces.append(count)
                count = count + 4

        Extrus.countVertsFaces = (4 * Extrus.numberFaces)

        Extrus.countVertsFaces = Extrus.countVertsFaces + \
            len(polycurve2d.curves)*2
        Extrus.numberFaces = Extrus.numberFaces + 2

        for j in range(int(len(Extrus.verts) / 3)):
            Extrus.colorlst.append(Extrus.color)

        return Extrus

    @classmethod
    def by_polycurve_height(self, polycurve: PolyCurve, height, dzloc: float):
        # global len
        Extrus = Extrusion()
        Points = polycurve.points
        V1 = Vector3.by_two_points(Points[0], Points[1])
        V2 = Vector3.by_two_points(Points[-2], Points[-1])

        p1 = Plane.by_two_vectors_origin(
            V1, V2, Points[0])  # Workplane of PolyCurve
        norm = p1.Normal

        pnts = []
        faces = []

        Extrus.polycurve_3d_translated = polycurve

        # allverts
        for pnt in Points:
            # Onderzijde verplaatst met dzloc
            pnts.append(Point.translate(pnt, Vector3.product(dzloc, norm)))
        for pnt in Points:
            # Bovenzijde verplaatst met dzloc
            pnts.append(Point.translate(
                pnt, Vector3.product((dzloc+height), norm)))

        numPoints = len(Points)

        # Bottomface
        count = 0
        face = []
        for x in range(numPoints):
            face.append(count)
            count = count + 1
        faces.append(face)

        # Topface
        count = 0
        face = []
        for x in range(numPoints):
            face.append(count+numPoints)
            count = count + 1
        faces.append(face)

        # Sides
        count = 0
        length = len(faces[0])
        for i, j in zip(faces[0], faces[1]):
            face = []
            face.append(i)
            face.append(faces[0][count + 1])
            face.append(faces[1][count + 1])
            face.append(j)
            count = count + 1
            if count == length-1:
                face.append(i)
                face.append(faces[0][0])
                face.append(faces[1][0])
                face.append(j)
                faces.append(face)
                break
            else:
                pass
            faces.append(face)

        # toMeshStructure
        for i in pnts:
            Extrus.verts.append(i.x)
            Extrus.verts.append(i.y)
            Extrus.verts.append(i.z)

        for x in faces:
            Extrus.faces.append(len(x))  # Number of verts in face
            for y in x:
                Extrus.faces.append(y)

        Extrus.numberFaces = len(faces)
        Extrus.countVertsFaces = (4 * len(faces))

        for j in range(int(len(Extrus.verts) / 3)):
            Extrus.colorlst.append(Extrus.color)
        return Extrus


# check if there are innercurves inside the outer curve.


class Surface:
    def __init__(self, PolyCurves: PolyCurve, color=None) -> None:
        # self.outerPolyCurve
        # self.innerPolyCurves
        if isinstance(PolyCurves, PolyCurve):
            PolyCurves = [PolyCurves]
        self.type = __class__.__name__
        self.mesh = []
        self.length = 0
        self.area = 0  # return the same area of the polyCurve but remove the innerpolycurves
        self.offset = 0
        self.name = "test2"
        self.id = generateID()
        self.PolyCurveList = PolyCurves
        self.origincurve = None
        if color is None:
            self.color = Color.rgb_to_int(Color().Components("gray"))
        else:
            self.color = color

        self.colorlst = []
        self.fill(self.PolyCurveList)

    def serialize(self):
        return {
            'type': self.type,
            'mesh': self.mesh,
            'length': self.length,
            'area': self.area,
            'offset': self.offset,
            'name': self.name,
            'id': self.id,
            'PolyCurveList': [polycurve.serialize() for polycurve in self.PolyCurveList],
            'origincurve': self.origincurve.serialize() if self.origincurve else None,
            'color': self.color,
            'colorlst': self.colorlst
        }

    @staticmethod
    def deserialize(data):
        polycurves = [PolyCurve.deserialize(
            pc_data) for pc_data in data.get('PolyCurveList', [])]
        surface = Surface(polycurves, data.get('color'))

        surface.mesh = data.get('mesh', [])
        surface.length = data.get('length', 0)
        surface.area = data.get('area', 0)
        surface.offset = data.get('offset', 0)
        surface.name = data.get('name', "test2")
        surface.id = data.get('id')
        surface.colorlst = data.get('colorlst', [])

        if data.get('origincurve'):
            surface.origincurve = PolyCurve.deserialize(data['origincurve'])

        return surface

    def fill(self, PolyCurveList):
        if isinstance(PolyCurveList, PolyCurve):
            plycColorList = []
            p = Extrusion.by_polycurve_height(PolyCurveList, 0, self.offset)
            self.mesh.append(p)
            for j in range(int(len(p.verts) / 3)):
                plycColorList.append(self.color)
            self.colorlst.append(plycColorList)

        elif isinstance(PolyCurveList, list):
            for polyCurve in PolyCurveList:
                plycColorList = []
                p = Extrusion.by_polycurve_height(polyCurve, 0, self.offset)
                self.mesh.append(p)
                for j in range(int(len(p.verts) / 3)):
                    plycColorList.append(self.color)
                self.colorlst.append(plycColorList)

    def void(self, polyCurve):
        # Find the index of the extrusion that intersects with the polyCurve
        idx = None
        for i, extr in enumerate(self.mesh):
            if extr.intersects(polyCurve):
                idx = i
                break

        if idx is not None:
            # Remove the intersected extrusion from the extrusion list
            removed = self.mesh.pop(idx)

            # Remove the corresponding color list from the colorlst list
            removed_colors = self.colorlst.pop(idx)

            # Create a new list of colors for the remaining extrusions
            new_colors = []
            for colors in self.colorlst:
                new_colors.extend(colors)

            # Fill the hole with a new surface
            hole_surface = Surface([polyCurve], color=self.color)
            hole_surface.fill([polyCurve])
            hole_extrusion = hole_surface.extrusion[0]

            # Add the hole extrusion to the extrusion list
            self.mesh.append(hole_extrusion)

            # Add the hole colors to the colorlst list
            hole_colors = [Color.rgb_to_int(Color().Components(
                "red"))] * int(len(hole_extrusion.verts) / 3)
            self.colorlst.append(hole_colors)

            # Add the remaining colors to the colorlst list
            self.colorlst.extend(new_colors)

            # Update the origin curve
            self.origincurve = self.PolyCurveList[0]

    def __id__(self):
        return f"id:{self.id}"

    # def __str__(self) -> str:
    #     return f"{__class__.__name__}({self})"


class NurbsSurface:  # based on point data / degreeU&countU / degreeV&countV?
    def __init__(self) -> None:
        pass
        self.id = generateID()
        self.type = __class__.__name__
    pass

    def __id__(self):
        return f"id:{self.id}"

    def __str__(self) -> str:
        return f"{__class__.__name__}({self})"


class PolySurface:
    def __init__(self) -> None:
        pass
        self.id = generateID()
        self.type = __class__.__name__
    pass

    def __id__(self):
        return f"id:{self.id}"

    def __str__(self) -> str:
        return f"{__class__.__name__}({self})"




class Panel:
    # Panel
    def __init__(self):
        self.id = generateID()
        self.type = __class__.__name__
        self.extrusion = None
        self.thickness = 0
        self.name = None
        self.perimeter: float = 0
        self.coordinatesystem: CoordinateSystem = CSGlobal
        self.colorint = None
        self.colorlst = []
        self.origincurve = None

    def serialize(self):
        id_value = str(self.id) if not isinstance(
            self.id, (str, int, float)) else self.id
        return {
            'id': id_value,
            'type': self.type,
            'extrusion': self.extrusion,
            'thickness': self.thickness,
            'name': self.name,
            'perimeter': self.perimeter,
            'coordinatesystem': self.coordinatesystem.serialize(),
            'color': self.color,
            'colorlst': self.colorlst,
            'origincurve': self.origincurve
        }

    @staticmethod
    def deserialize(data):
        panel = Panel()
        panel.id = data.get('id')
        panel.type = data.get('type')
        panel.extrusion = data.get('extrusion')
        panel.thickness = data.get('thickness', 0)
        panel.name = data.get('name', "none")
        panel.perimeter = data.get('perimeter', 0)
        panel.coordinatesystem = CoordinateSystem.deserialize(
            data['coordinatesystem'])
        panel.color = data.get('color')
        panel.colorlst = data.get('colorlst', [])
        panel.origincurve = data.get('origincurve')

        return panel

    @classmethod
    def by_polycurve_thickness(self, polycurve: PolyCurve, thickness: float, offset: float, name: str, colorrgbint):
        # Create panel by polycurve
        p1 = Panel()
        p1.name = name
        p1.thickness = thickness
        p1.extrusion = Extrusion.by_polycurve_height(
            polycurve, thickness, offset)
        p1.origincurve = polycurve
        p1.colorint = colorrgbint
        for j in range(int(len(p1.extrusion.verts) / 3)):
            p1.colorlst.append(colorrgbint)
        return p1

    @classmethod
    def by_baseline_height(self, baseline: Line, height: float, thickness: float, name: str, colorrgbint):
        # place panel vertical from baseline
        p1 = Panel()
        p1.name = name
        p1.thickness = thickness
        polycurve = PolyCurve.by_points(
            [baseline.start,
             baseline.end,
             Point.translate(baseline.end, Vector3(0, 0, height)),
             Point.translate(baseline.start, Vector3(0, 0, height))])
        p1.extrusion = Extrusion.by_polycurve_height(polycurve, thickness, 0)
        p1.origincurve = polycurve
        for j in range(int(len(p1.extrusion.verts) / 3)):
            p1.colorlst.append(colorrgbint)
        return p1



class BoundingBox2d:
    def __init__(self):
        self.id = generateID()
        self.type = __class__.__name__
        self.points = []
        self.corners = []
        self.isClosed = True
        self.length = 0
        self.width = 0
        self.z = 0

    def serialize(self):
        id_value = str(self.id) if not isinstance(
            self.id, (str, int, float)) else self.id
        return {
            'id': id_value,
            'points': self.points,
            'corners': self.corners,
            'isClosed': self.isClosed,
            'length': self.length,
            'width': self.width,
            'z': self.z
        }

    @staticmethod
    def deserialize(data):
        bounding_box = BoundingBox2d()
        bounding_box.id = data.get('id')
        bounding_box.points = data.get('points', [])
        bounding_box.corners = data.get('corners', [])
        bounding_box.isClosed = data.get('isClosed', True)
        bounding_box.length = data.get('length', 0)
        bounding_box.width = data.get('width', 0)
        bounding_box.z = data.get('z', 0)

        return bounding_box

    def _length(self):
        return 0

    def area(self):
        return 0

    def by_points(self, points=Point):
        self.points = points
        x_values = [point.x for point in self.points]
        y_values = [point.y for point in self.points]

        min_x = min(x_values)
        max_x = max(x_values)
        min_y = min(y_values)
        max_y = max(y_values)

        left_top = Point(x=min_x, y=max_y, z=self.z)
        left_bottom = Point(x=min_x, y=min_y, z=self.z)
        right_top = Point(x=max_x, y=max_y, z=self.z)
        right_bottom = Point(x=max_x, y=min_y, z=self.z)
        self.length = abs(Point.distance(left_top, left_bottom))
        self.width = abs(Point.distance(left_top, right_top))
        self.corners.append(left_top)
        self.corners.append(left_bottom)
        self.corners.append(right_bottom)
        self.corners.append(right_top)
        return self

    def by_dimensions(self, length: float, width: float):
        # startpoint = Point2D(0,0)
        # widthpoint = Point2D(0,width)
        # widthlengthpoint = Point2D(length,width)
        # lengthpoint = Point2D(length,0)

        half_length = length / 2
        half_width = width / 2

        startpoint = Point2D(-half_length, -half_width)
        widthpoint = Point2D(-half_length, half_width)
        widthlengthpoint = Point2D(half_length, half_width)
        lengthpoint = Point2D(half_length, -half_width)

        self.points.append(startpoint)
        self.corners.append(startpoint)
        self.points.append(widthpoint)
        self.corners.append(widthpoint)
        self.points.append(widthlengthpoint)
        self.corners.append(widthlengthpoint)
        self.points.append(lengthpoint)
        self.corners.append(lengthpoint)

        self.length = length
        self.width = width
        return self


class BoundingBox3d:
    def __init__(self, points=Point):
        self.id = generateID()
        self.type = __class__.__name__
        self.points = points
        self.boundingbox2d = None
        self.coordinatesystem = None
        self.height = None

    def serialize(self):
        id_value = str(self.id) if not isinstance(
            self.id, (str, int, float)) else self.id
        return {
            'id': id_value,
            'type': self.type,
            'points': [point.serialize() for point in self.points]
        }

    @staticmethod
    def deserialize(data):
        points = [Point.deserialize(point_data)
                  for point_data in data.get('points', [])]
        return BoundingBox3d(points)

    def corners(self):
        x_values = [point.x for point in self.points]
        y_values = [point.y for point in self.points]
        z_values = [point.z for point in self.points]

        min_x = min(x_values)
        max_x = max(x_values)
        min_y = min(y_values)
        max_y = max(y_values)
        min_z = min(z_values)
        max_z = max(z_values)

        left_top_bottom = Point(x=min_x, y=max_y, z=min_z)
        left_bottom_bottom = Point(x=min_x, y=min_y, z=min_z)
        right_top_bottom = Point(x=max_x, y=max_y, z=min_z)
        right_bottom_bottom = Point(x=max_x, y=min_y, z=min_z)

        left_top_top = Point(x=min_x, y=max_y, z=max_z)
        left_bottom_top = Point(x=min_x, y=min_y, z=max_z)
        right_top_top = Point(x=max_x, y=max_y, z=max_z)
        right_bottom_top = Point(x=max_x, y=min_y, z=max_z)

        return [left_top_bottom, left_top_top, right_top_top, right_top_bottom, left_top_bottom, left_bottom_bottom, left_bottom_top, left_top_top, left_bottom_top, right_bottom_top, right_bottom_bottom, left_bottom_bottom, right_bottom_bottom, right_top_bottom, right_top_top, right_bottom_top]

    def perimeter(self):
        return PolyCurve.by_points(self.corners(self.points))

    def convert_boundingbox_2d(self, boundingbox2d: BoundingBox2d, coordinatesystem: CoordinateSystem, height=float):
        self.boundingbox2d = boundingbox2d
        self.coordinatesystem = coordinatesystem
        self.height = height
        return self

    def to_cuboid(self) -> Extrusion:
        pts = self.boundingbox2d.corners
        pc = PolyCurve2D.by_points(pts)
        height = self.height
        cs = self.coordinatesystem
        dirXvector = Vector3.angle_between(CSGlobal.Yaxis, cs.Yaxis)
        pcrot = pc.rotate(dirXvector)  # bug multi direction
        cuboid = Extrusion.by_polycurve_height_vector(
            pcrot, height, CSGlobal, cs.Origin, cs.Zaxis)
        return cuboid

    def to_axis(self, length: int = None) -> Line:
        if length == None:
            length = 1000
        cs = self.coordinatesystem
        lnX = Line.by_startpoint_direction_length(cs.Origin, cs.Xaxis, length)
        lnY = Line.by_startpoint_direction_length(cs.Origin, cs.Yaxis, length)
        lnZ = Line.by_startpoint_direction_length(cs.Origin, cs.Zaxis, length)
        return [lnX, lnY, lnZ]




class System:
    # Generic class for systems
    def __init__(self):
        self.type = __class__.__name__
        self.name = None
        self.id = generateID()
        self.polycurve = None
        self.direction: Vector3 = Vector3(1, 0, 0)


class DivisionSystem:
    # This class provides divisionsystems. It returns lists with floats based on a length.

    def __init__(self):
        self.type = __class__.__name__
        self.name = None
        self.id = generateID()
        self.system_length: float = 100
        self.spacing: float = 10
        self.distance_first: float = 5
        self.width_stud: float = 10
        self.fixed_number: int = 2
        self.modifier: int = 0
        self.distances = []  # List with sum of distances
        self.spaces = []  # List with spaces between every divison
        self.system: str = "fixed_distance_unequal_division"

    def __fixed_number_equal_spacing(self):
        self.name = "fixed_number_equal_spacing"
        self.distances = Interval.by_start_end_count(
            0, self.system_length, self.fixed_number)
        self.spacing = self.system_length / self.fixed_number
        self.modifier = 0
        self.distance_first = self.spacing

    def __fixed_distance_unequal_division(self):
        self.name = "fixed_distance_unequal_division"
        rest_length = self.system_length - self.distance_first
        number_of_studs = int(rest_length / self.spacing)
        number_of_studs = number_of_studs + self.modifier
        distance = self.distance_first
        for i in range(number_of_studs+1):
            if distance < self.system_length:
                self.distances.append(distance)
            else:
                break
            distance = distance + self.spacing

    def __fixed_distance_equal_division(self):
        self.name = "fixed_distance_equal_division"
        number_of_studs = int(self.system_length / self.spacing)
        number_of_studs = number_of_studs + self.modifier
        sum_length_studs_x_spacing = (number_of_studs - 1) * self.spacing
        rest_length = self.system_length - sum_length_studs_x_spacing
        distance = rest_length / 2
        for i in range(number_of_studs):
            self.distances.append(distance)
            distance = distance + self.spacing

    def by_fixed_distance_unequal_division(self, length, spacing, distance_first, modifier):
        self.system_length = length
        self.modifier = modifier
        self.spacing = spacing
        self.distance_first = distance_first
        self.system = "fixed_distance_unequal_division"
        self.__fixed_distance_unequal_division()
        return self

    def by_fixed_distance_equal_division(self, length, spacing, modifier):
        self.system_length = length
        self.modifier = modifier
        self.spacing = spacing
        self.system = "fixed_distance_equal_division"
        self.__fixed_distance_equal_division()
        return self

    def by_fixed_number_equal_spacing(self, length, number):
        self.system_length = length
        self.system = "fixed_number_equal_spacing"
        self.spacing = length/number
        self.modifier = 0
        distance = self.spacing
        for i in range(number-1):
            self.distances.append(distance)
            distance = distance + self.spacing
        self.distance_first = self.spacing
        return self

        #  fixed_number_equal_interior_fill
        #  maximum_spacing_equal_division
        #  maximum_spacing_unequal_division
        #  minimum_spacing_equal_division
        #  minimum_spacing_unequal_division


class RectangleSystem:
    # Reclangle Left Bottom is in Local XYZ. Main direction parallel to height direction vector. Top is z=0
    def __init__(self):
        self.type = __class__.__name__
        self.name = None
        self.id = generateID()
        self.height = 3000
        self.width = 2000
        self.bottom_frame_type = Rectangle("bottom_frame_type", 38, 184)
        self.top_frame_type = Rectangle("top_frame_type", 38, 184)
        self.left_frame_type = Rectangle("left_frame_type", 38, 184)
        self.right_frame_type = Rectangle("left_frame_type", 38, 184)
        self.inner_frame_type = Rectangle("inner_frame_type", 38, 184)

        self.material = BaseTimber
        self.inner_width: float = 0
        self.inner_height: float = 0
        self.coordinatesystem = CSGlobal
        self.local_coordinate_system = CSGlobal
        # self.openings = []
        # self.subsystems = []
        self.division_system = None
        self.inner_frame_objects = []
        self.outer_frame_objects = []
        self.panel_objects = []
        self.symbolic_inner_mother_surface = None
        self.symbolic_inner_panels = None
        self.symbolic_outer_grids = []
        self.symbolic_inner_grids = []

    def __inner_panels(self):
        # First Inner panel
        i = self.division_system.distances[0]
        point1 = self.mother_surface_origin_point_x_zero
        point2 = Point.translate(self.mother_surface_origin_point_x_zero, Vector3(
            i - self.inner_frame_type.b * 0.5, 0, 0))
        point3 = Point.translate(self.mother_surface_origin_point_x_zero,
                                 Vector3(i - self.inner_frame_type.b * 0.5, self.inner_height, 0))
        point4 = Point.translate(
            self.mother_surface_origin_point_x_zero, Vector3(0, self.inner_height, 0))
        self.panel_objects.append(
            Panel.by_polycurve_thickness(
                PolyCurve.by_points(
                    [point1, point2, point3, point4, point1]), 184, 0, "innerpanel",
                rgb_to_int([255, 240, 160]))
        )
        count = 0
        # In between
        for i in self.division_system.distances:
            try:
                point1 = Point.translate(self.mother_surface_origin_point_x_zero, Vector3(
                    self.division_system.distances[count]+self.inner_frame_type.b*0.5, 0, 0))
                point2 = Point.translate(self.mother_surface_origin_point_x_zero, Vector3(
                    self.division_system.distances[count+1]-self.inner_frame_type.b*0.5, 0, 0))
                point3 = Point.translate(self.mother_surface_origin_point_x_zero, Vector3(
                    self.division_system.distances[count+1]-self.inner_frame_type.b*0.5, self.inner_height, 0))
                point4 = Point.translate(self.mother_surface_origin_point_x_zero, Vector3(
                    self.division_system.distances[count]+self.inner_frame_type.b*0.5, self.inner_height, 0))
                self.panel_objects.append(
                    Panel.by_polycurve_thickness(
                        PolyCurve.by_points([point1, point2, point3, point4, point1]), 184, 0, "innerpanel", rgb_to_int([255, 240, 160]))
                )
                count = count + 1
            except:
                # Last panel
                point1 = Point.translate(self.mother_surface_origin_point_x_zero, Vector3(
                    self.division_system.distances[count]+self.inner_frame_type.b*0.5, 0, 0))
                point2 = Point.translate(self.mother_surface_origin_point_x_zero, Vector3(
                    self.inner_width+self.left_frame_type.b, 0, 0))
                point3 = Point.translate(self.mother_surface_origin_point_x_zero, Vector3(
                    self.inner_width+self.left_frame_type.b, self.inner_height, 0))
                point4 = Point.translate(self.mother_surface_origin_point_x_zero, Vector3(
                    self.division_system.distances[count]+self.inner_frame_type.b*0.5, self.inner_height, 0))
                self.panel_objects.append(
                    Panel.by_polycurve_thickness(
                        PolyCurve.by_points([point1, point2, point3, point4, point1]), 184, 0, "innerpanel", rgb_to_int([255, 240, 160]))
                )
                count = count + 1

    def __inner_mother_surface(self):
        # Inner mother surface is the surface within the outer frames dependent on the width of the outer frametypes.
        self.inner_width = self.width-self.left_frame_type.b-self.right_frame_type.b
        self.inner_height = self.height-self.top_frame_type.b-self.bottom_frame_type.b
        self.mother_surface_origin_point = Point(
            self.left_frame_type.b, self.bottom_frame_type.b, 0)
        self.mother_surface_origin_point_x_zero = Point(
            0, self.bottom_frame_type.b, 0)
        self.symbolic_inner_mother_surface = PolyCurve.by_points(
            [self.mother_surface_origin_point,
             Point.translate(self.mother_surface_origin_point,
                             Vector3(self.inner_width, 0, 0)),
             Point.translate(self.mother_surface_origin_point, Vector3(
                 self.inner_width, self.inner_height, 0)),
             Point.translate(self.mother_surface_origin_point,
                             Vector3(0, self.inner_height, 0)),
             self.mother_surface_origin_point]
        )

    def __inner_frames(self):
        for i in self.division_system.distances:
            start_point = Point.translate(
                self.mother_surface_origin_point_x_zero, Vector3(i, 0, 0))
            end_point = Point.translate(
                self.mother_surface_origin_point_x_zero, Vector3(i, self.inner_height, 0))
            self.inner_frame_objects.append(
                Frame.by_startpoint_endpoint_curve_justifiction(
                    start_point, end_point, self.inner_frame_type.curve, "innerframe", "center", "top", 0, self.material)
            )
            self.symbolic_inner_grids.append(
                Line(start=start_point, end=end_point))

    def __outer_frames(self):
        bottomframe = Frame.by_startpoint_endpoint_curve_justifiction(Point(0, 0, 0), Point(
            self.width, 0, 0), self.bottom_frame_type.curve, "bottomframe", "left", "top", 0, self.material)
        self.symbolic_outer_grids.append(
            Line(start=Point(0, 0, 0), end=Point(self.width, 0, 0)))

        topframe = Frame.by_startpoint_endpoint_curve_justifiction(Point(0, self.height, 0), Point(
            self.width, self.height, 0), self.top_frame_type.curve, "bottomframe", "right", "top", 0, self.material)
        self.symbolic_outer_grids.append(
            Line(start=Point(0, self.height, 0), end=Point(self.width, self.height, 0)))

        leftframe = Frame.by_startpoint_endpoint_curve_justifiction(Point(0, self.bottom_frame_type.b, 0), Point(
            0, self.height-self.top_frame_type.b, 0), self.left_frame_type.curve, "leftframe", "right", "top", 0, self.material)
        self.symbolic_outer_grids.append(Line(start=Point(
            0, self.bottom_frame_type.b, 0), end=Point(0, self.height-self.top_frame_type.b, 0)))

        rightframe = Frame.by_startpoint_endpoint_curve_justifiction(Point(self.width, self.bottom_frame_type.b, 0), Point(
            self.width, self.height-self.top_frame_type.b, 0), self.right_frame_type.curve, "leftframe", "left", "top", 0, self.material)
        self.symbolic_outer_grids.append(Line(start=Point(self.width, self.bottom_frame_type.b, 0), end=Point(
            self.width, self.height-self.top_frame_type.b, 0)))

        self.outer_frame_objects.append(bottomframe)
        self.outer_frame_objects.append(topframe)
        self.outer_frame_objects.append(leftframe)
        self.outer_frame_objects.append(rightframe)

    def by_width_height_divisionsystem_studtype(self, width, height, framewidth, frameheight, division_system, filling):
        self.width = width
        self.height = height
        self.bottom_frame_type = Rectangle(
            "bottom_frame_type", framewidth, frameheight)
        self.top_frame_type = Rectangle(
            "top_frame_type", framewidth, frameheight)
        self.left_frame_type = Rectangle(
            "left_frame_type", framewidth, frameheight)
        self.right_frame_type = Rectangle(
            "left_frame_type", framewidth, frameheight)
        self.inner_frame_type = Rectangle(
            "inner_frame_type", framewidth, frameheight)
        self.division_system = division_system
        self.__inner_mother_surface()
        self.__inner_frames()
        self.__outer_frames()
        if filling:
            self.__inner_panels()
        else:
            pass
        return self


class PatternSystem:
    def __init__(self):
        self.type = __class__.__name__
        self.name = None
        self.id = generateID()
        self.pattern = None
        self.basepanels = []  # contains a list with basepanels of the system
        # contains a list sublists with Vector3 which represent the repetition of the system
        self.vectors = []

    def stretcher_bond_with_joint(self, name: str, brickwidth: float,  bricklength: float, brickheight: float, jointwidth: float, jointheight: float):
        self.name = name
        # Vectors of panel 1
        V1 = Vector3(0, (brickheight + jointheight)*2, 0)  # dy
        V2 = Vector3(bricklength+jointwidth, 0, 0)  # dx
        self.vectors.append([V1, V2])

        # Vectors of panel 2
        V3 = Vector3(0, (brickheight + jointheight) * 2, 0)  # dy
        V4 = Vector3(bricklength + jointwidth, 0, 0)  # dx
        self.vectors.append([V3, V4])

        dx = (bricklength+jointwidth)/2
        dy = brickheight+jointheight

        PC1 = PolyCurve().by_points([Point(0, 0, 0), Point(0, brickheight, 0), Point(
            bricklength, brickheight, 0), Point(bricklength, 0, 0), Point(0, 0, 0)])
        PC2 = PolyCurve().by_points([Point(dx, dy, 0), Point(dx, brickheight+dy, 0), Point(
            bricklength+dx, brickheight+dy, 0), Point(bricklength+dx, dy, 0), Point(dx, dy, 0)])
        BasePanel1 = Panel.by_polycurve_thickness(
            PC1, brickwidth, 0, "BasePanel1", BaseBrick.colorint)
        BasePanel2 = Panel.by_polycurve_thickness(
            PC2, brickwidth, 0, "BasePanel2", BaseBrick.colorint)

        self.basepanels.append(BasePanel1)
        self.basepanels.append(BasePanel2)
        return self

    def tile_bond_with_joint(self, name: str, tilewidth: float,  tileheight: float, tilethickness: float, jointwidth: float, jointheight: float):
        self.name = name
        # Vectors of panel 1
        V1 = Vector3(0, (tileheight + jointheight), 0)  # dy
        V2 = Vector3(tilewidth+jointwidth, 0, 0)  # dx
        self.vectors.append([V1, V2])

        PC1 = PolyCurve().by_points([Point(0, 0, 0), Point(0, tileheight, 0), Point(
            tilewidth, tileheight, 0), Point(tilewidth, 0, 0)])
        BasePanel1 = Panel.by_polycurve_thickness(
            PC1, tilethickness, 0, "BasePanel1", BaseBrick.colorint)

        self.basepanels.append(BasePanel1)
        return self

    def cross_bond_with_joint(self, name: str, brickwidth: float, bricklength: float, brickheight: float, jointwidth: float, jointheight: float):
        self.name = name
        lagenmaat = brickheight + jointheight
        # Vectors of panel 1 (strek)
        V1 = Vector3(0, (brickheight + jointheight) * 4, 0)  # dy spacing
        V2 = Vector3(bricklength + jointwidth, 0, 0)  # dx spacing
        self.vectors.append([V1, V2])

        # Vectors of panel 2 (koppen 1)
        V3 = Vector3(0, (brickheight + jointheight) * 2, 0)  # dy spacing
        V4 = Vector3(bricklength + jointwidth, 0, 0)  # dx spacing
        self.vectors.append([V3, V4])

        dx2 = (brickwidth + jointwidth)/2  # start x offset
        dy2 = lagenmaat  # start y offset

        # Vectors of panel 3 (strekken)
        V5 = Vector3(0, (brickheight + jointheight) * 4, 0)  # dy spacing
        V6 = Vector3(bricklength + jointwidth, 0, 0)  # dx spacing
        self.vectors.append([V5, V6])

        dx3 = (bricklength + jointwidth)/2  # start x offset
        dy3 = lagenmaat * 2  # start y offset

        # Vectors of panel 4 (koppen 2)
        V7 = Vector3(0, (brickheight + jointheight) * 2, 0)  # dy spacing
        V8 = Vector3(bricklength + jointwidth, 0, 0)  # dx spacing
        self.vectors.append([V7, V8])

        dx4 = (brickwidth + jointwidth)/2 + \
            (brickwidth + jointwidth)  # start x offset
        dy4 = lagenmaat  # start y offset

        PC1 = PolyCurve().by_points([Point(0, 0, 0), Point(0, brickheight, 0), Point(
            bricklength, brickheight, 0), Point(bricklength, 0, 0), Point(0, 0, 0)])
        PC2 = PolyCurve().by_points([Point(dx2, dy2, 0), Point(dx2, brickheight+dy2, 0), Point(
            brickwidth+dx2, brickheight+dy2, 0), Point(brickwidth+dx2, dy2, 0), Point(dx2, dy2, 0)])
        PC3 = PolyCurve().by_points([Point(dx3, dy3, 0), Point(dx3, brickheight+dy3, 0), Point(
            bricklength+dx3, brickheight+dy3, 0), Point(bricklength+dx3, dy3, 0), Point(dx3, dy3, 0)])
        PC4 = PolyCurve().by_points([Point(dx4, dy4, 0), Point(dx4, brickheight+dy4, 0), Point(
            brickwidth+dx4, brickheight+dy4, 0), Point(brickwidth+dx4, dy4, 0), Point(dx4, dy4, 0)])

        BasePanel1 = Panel.by_polycurve_thickness(
            PC1, brickwidth, 0, "BasePanel1", BaseBrick.colorint)
        BasePanel2 = Panel.by_polycurve_thickness(
            PC2, brickwidth, 0, "BasePanel2", BaseBrick.colorint)
        BasePanel3 = Panel.by_polycurve_thickness(
            PC3, brickwidth, 0, "BasePanel3", BaseBrick.colorint)
        BasePanel4 = Panel.by_polycurve_thickness(
            PC4, brickwidth, 0, "BasePanel4", BaseBrickYellow.colorint)

        self.basepanels.append(BasePanel1)
        self.basepanels.append(BasePanel2)
        self.basepanels.append(BasePanel3)
        self.basepanels.append(BasePanel4)

        return self


def pattern_geom(PatternSystem, width, height, startpoint: Point = None) -> list[Panel]:
    startpoint = startpoint or Point(0, 0, 0)
    test = PatternSystem
    panels = []

    for i, j in zip(test.basepanels, test.vectors):
        ny = int(height / (j[0].y))  # number of panels in y-direction
        nx = int(width / (j[1].x))  # number of panels in x-direction
        PC = i.origincurve
        thickness = i.thickness
        color = i.colorint

        # YX ARRAY
        yvectdisplacement = j[0]
        yvector = Point.to_vector(startpoint)
        xvectdisplacement = j[1]
        xvector = Vector3(0, 0, 0)

        ylst = []
        for k in range(ny):
            yvector = Vector3.sum(yvectdisplacement, yvector)
            for l in range(nx):
                # Copy in x-direction
                xvector = Vector3.sum(xvectdisplacement, xvector)
                xyvector = Vector3.sum(yvector, xvector)
                # translate curve in x and y-direction
                PCNew = PolyCurve.copy_translate(PC, xyvector)
                pan = Panel.by_polycurve_thickness(
                    PCNew, thickness, 0, "name", color)
                panels.append(pan)
            xvector = Vector3.sum(
                xvectdisplacement, Vector3(-test.basepanels[0].origincurve.curves[1].length, 0, 0))
    return panels


def fillin(perimeter: PolyCurve2D, pattern: pattern_geom) -> PatternSystem:

    bb = BoundingBox2d().by_points(perimeter.points)

    for pt in bb.corners:
        project.objects.append(pt)
    bb_perimeter = PolyCurve.by_points(bb.corners)

    # l = []

    # for q in pattern:
    #     l.append(q.origincurve)
    # print(q.origincurve)

    return [bb_perimeter]

# polycurve perimeter, pattern
# bbox, fill, trim



def rgb_to_int(rgb):
    r, g, b = [max(0, min(255, c)) for c in rgb]

    return (255 << 24) | (r << 16) | (g << 8) | b

class Material:
    def __init__(self):
        self.name = "none"
        self.color = None
        self.colorint = None

    @classmethod
    def byNameColor(cls, name, color):
        M1 = Material()
        M1.name = name
        M1.color = color
        M1.colorint = rgb_to_int(color)
        return M1


#Building Materials
BaseConcrete = Material.byNameColor("Concrete", Color().RGB([192, 192, 192]))
BaseTimber = Material.byNameColor("Timber", Color().RGB([191, 159, 116]))
BaseSteel = Material.byNameColor("Steel", Color().RGB([237, 28, 36]))
BaseOther = Material.byNameColor("Other", Color().RGB([150, 150, 150]))
BaseBrick = Material.byNameColor("Brick", Color().RGB([170, 77, 47]))
BaseBrickYellow = Material.byNameColor("BrickYellow", Color().RGB([208, 187, 147]))

#GIS Materials
BaseBuilding = Material.byNameColor("Building", Color().RGB([150, 28, 36]))
BaseWater = Material.byNameColor("Water", Color().RGB([205, 230, 237]))
BaseGreen = Material.byNameColor("Green", Color().RGB([223, 230, 208]))
BaseInfra = Material.byNameColor("Infra", Color().RGB([234, 234, 234]))
BaseRoads = Material.byNameColor("Infra", Color().RGB([140, 140, 140]))

#class Materialfinish

jsonFile = "https://raw.githubusercontent.com/3BMLabs/Project-Ocondat/master/steelprofile.json"
url = urllib.request.urlopen(jsonFile)
data = json.loads(url.read())


class searchProfile:
    def __init__(self, name):
        self.name = name
        self.shape_coords = None
        self.shape_name = None
        self.synonyms = None
        for item in data:
            for i in item.values():
                synonymList = i[0]["synonyms"]
                #if self.name in synonymList:
                #bools = [self.name.lower() in e for e in [synonym.lower() for synonym in synonymList]]
                #if True in bools:
                if self.name.lower() in [synonym.lower() for synonym in synonymList]:
                    self.shape_coords = i[0]["shape_coords"]
                    self.shape_name = i[0]["shape_name"]
                    self.synonyms = i[0]["synonyms"]


class profiledataToShape:
    def __init__(self, name1, segmented = False):
        profile_data = searchProfile(name1)
        if profile_data == None:
            print(f"profile {name1} not recognised")
        shape_name = profile_data.shape_name

        if shape_name == None:
            profile_data = searchProfile(project.structural_fallback_element)
            err = f"Error, profile '{name1}' not recognised, define in {jsonFile} | fallback: '{project.structural_fallback_element}'"
            print(err)
            shape_name = profile_data.shape_name
        self.profile_data = profile_data
        self.shape_name = shape_name
        name = profile_data.name
        self.d1 = profile_data.shape_coords
        #self.d1.insert(0,name)
        d1 = self.d1
        if shape_name == "C-channel parallel flange":
            prof = CChannelParallelFlange(name,d1[0],d1[1],d1[2],d1[3],d1[4],d1[5])
        elif shape_name == "C-channel sloped flange":
            prof = CChannelSlopedFlange(name,d1[0],d1[1],d1[2],d1[3],d1[4],d1[5],d1[6],d1[7],d1[8])
        elif shape_name == "I-shape parallel flange":
            prof = IShapeParallelFlange(name,d1[0],d1[1],d1[2],d1[3],d1[4])
        elif shape_name == "I-shape sloped flange":
            prof = IShapeParallelFlange(name, d1[0], d1[1], d1[2], d1[3], d1[4])
            #Todo: add sloped flange shape
        elif shape_name == "Rectangle":
            prof = Rectangle(name,d1[0], d1[1])
        elif shape_name == "Round":
            prof = Round(name, d1[1])
        elif shape_name == "Round tube profile":
            prof = Roundtube(name, d1[0], d1[1])
        elif shape_name == "LAngle":
            prof = LAngle(name,d1[0],d1[1],d1[2],d1[3],d1[4],d1[5],d1[6],d1[7])
        elif shape_name == "TProfile":
            prof = TProfile(name, d1[0], d1[1], d1[2], d1[3], d1[4], d1[5], d1[6], d1[7], d1[8])
        elif shape_name == "Rectangle Hollow Section":
            prof = RectangleHollowSection(name,d1[0],d1[1],d1[2],d1[3],d1[4])

        self.prof = prof
        self.data = d1
        pc2d = self.prof.curve  # 2D polycurve
        if segmented == True:
            pc3d = PolyCurve.by_polycurve_2D(pc2d)
            pcsegment = PolyCurve.segment(pc3d, 10)
            pc2d2 = pcsegment.to_polycurve_2D()
        else:
            pc2d2 = pc2d
        self.polycurve2d = pc2d2

def justifictionToVector(plycrv2D: PolyCurve2D, XJustifiction, Yjustification, ey=None, ez=None):
    
    # print(XJustifiction)
    xval = []
    yval = []
    for i in plycrv2D.curves:
        xval.append(i.start.x)
        yval.append(i.start.y)

    #Boundingbox2D
    xmin = min(xval)
    xmax = max(xval)
    ymin = min(yval)
    ymax = max(yval)

    b = xmax-xmin
    h = ymax-ymin

    # print(b, h)

    dxleft = -xmax
    dxright = -xmin
    dxcenter = dxleft - 0.5 * b #CHECK
    dxorigin = 0

    dytop = -ymax
    dybottom = -ymin
    dycenter = dytop - 0.5 * h #CHECK
    dyorigin = 0

    if XJustifiction == "center":
        dx = dxorigin #TODO
    elif XJustifiction == "left":
        dx = dxleft
    elif XJustifiction == "right":
        dx = dxright
    elif XJustifiction == "origin":
        dx = dxorigin #TODO
    else:
        dx = 0

    if Yjustification == "center":
        dy = dyorigin   #TODO
    elif Yjustification == "top":
        dy = dytop
    elif Yjustification == "bottom":
        dy = dybottom
    elif Yjustification == "origin":
        dy = dyorigin #TODO
    else:
        dy = 0

    # print(dx, dy)
    v1 = Vector2(dx, dy)
    # v1 = Vector2(0, 0)

    return v1



class Support:
    def __init__(self):
        self.Number = None
        self.Point: Point = Point(0, 0, 0)
        self.id = generateID()
        self.type = __class__.__name__
        self.Tx: str = " "  # A, P, N, S
        self.Ty: str = " "  # A, P, N, S
        self.Tz: str = " "  # A, P, N, S
        self.Rx: str = " "  # A, P, N, S
        self.Ry: str = " "  # A, P, N, S
        self.Rz: str = " "  # A, P, N, S
        self.Kx: float = 0  # kN/m
        self.Ky: float = 0  # kN/m
        self.Kz: float = 0  # kN/m
        self.Cx: float = 0  # kNm/rad
        self.Cy: float = 0  # kNm/rad
        self.Cz: float = 0  # kNm/rad
        self.dx: float = 0  # eccentricity in x
        self.dy: float = 0  # eccentricity in y
        self.dz: float = 0  # eccentricity in z

    def serialize(self):
        return {
            'Number': self.Number,
            'Point': self.Point.serialize(),
            'type': self.type,
            'Tx': self.Tx,
            'Ty': self.Ty,
            'Tz': self.Tz,
            'Rx': self.Rx,
            'Ry': self.Ry,
            'Rz': self.Rz,
            'Kx': self.Kx,
            'Ky': self.Ky,
            'Kz': self.Kz,
            'Cx': self.Cx,
            'Cy': self.Cy,
            'Cz': self.Cz,
            'dx': self.dx,
            'dy': self.dy,
            'dz': self.dz
        }

    @staticmethod
    def deserialize(data):
        support = Support()
        support.Number = data.get('Number')
        support.Point = Point.deserialize(data['Point'])
        support.Tx = data.get('Tx', " ")
        support.Ty = data.get('Ty', " ")
        support.Tz = data.get('Tz', " ")
        support.Rx = data.get('Rx', " ")
        support.Ry = data.get('Ry', " ")
        support.Rz = data.get('Rz', " ")
        support.Kx = data.get('Kx', 0)
        support.Ky = data.get('Ky', 0)
        support.Kz = data.get('Kz', 0)
        support.Cx = data.get('Cx', 0)
        support.Cy = data.get('Cy', 0)
        support.Cz = data.get('Cz', 0)
        support.dx = data.get('dx', 0)
        support.dy = data.get('dy', 0)
        support.dz = data.get('dz', 0)

        return support

    @staticmethod
    def pinned(PlacementPoint):
        sup = Support()
        sup.Point = PlacementPoint
        sup.Tx = "A"
        sup.Ty = "A"
        sup.Tz = "A"
        return (sup)

    @staticmethod
    def x_roller(PlacementPoint):
        sup = Support()
        sup.Point = PlacementPoint
        sup.Ty = "A"
        sup.Tz = "A"
        return (sup)

    @staticmethod
    def y_roller(PlacementPoint):
        sup = Support()
        sup.Point = PlacementPoint
        sup.Tx = "A"
        sup.Tz = "A"
        return (sup)

    @staticmethod
    def z_roller(PlacementPoint):
        sup = Support()
        sup.Point = PlacementPoint
        sup.Tx = "A"
        sup.Ty = "A"
        return (sup)

    @staticmethod
    def fixed(PlacementPoint):
        sup = Support()
        sup.Point = PlacementPoint
        sup.Tx = "A"
        sup.Ty = "A"
        sup.Tz = "A"
        sup.Rx = "A"
        sup.Ry = "A"
        sup.Rz = "A"
        return (sup)


class LoadCase:
    def __init__(self):
        self.Number = None
        self.Description: str = ""
        self.psi0 = 1
        self.psi1 = 1
        self.psi2 = 1
        self.Type = 0  # 0 = permanent, 1 = variabel


class SurfaceLoad:
    def __init__(self):
        self.LoadCase = None
        self.PolyCurve: PolyCurve = None
        self.Description: str = ""
        self.crs = "ccaa0435161960d4c7e436cf107a03f61"
        self.direction = "caf2b4ce743de1df30071f9566b1015c6"
        self.LoadBearingDirection = "cfebf3fce7063ab9a89d28a86508c0fb3"
        self.q1 = 0
        self.q2 = 0
        self.q3 = 0
        self.LoadConstantOrLinear = "cb81ae405e988f21166edf06d7fd646fb"
        self.iq1 = -1
        self.iq2 = -1
        self.iq3 = -1

    @staticmethod
    def by_load_case_polycurve_q(LoadCase, PolyCurve, q):
        SL = SurfaceLoad()
        SL.LoadCase = LoadCase
        SL.PolyCurve = PolyCurve
        SL.q1 = q
        SL.q2 = q
        SL.q3 = q
        return SL


class LoadPanel:
    def __init__(self):
        self.PolyCurve: PolyCurve = None
        self.Description: str = ""
        self.LoadBearingDirection = "X"
        # Wall, saddle_roof_positive_pitch #Wall, / Free-standing wall, Flat roof, Shed roof, Saddle roof, Unknown
        self.SurfaceType = ""


def chess_board_surface_loads_rectangle(startx, starty, dx, dy, nx, ny, width, height, LoadCase, q123, description: str):
    SurfaceLoads = []
    x = startx
    y = starty
    for j in range(ny):
        for i in range(nx):
            SL = SurfaceLoad()
            SL.Description = description
            SL.LoadCase = LoadCase
            SL.PolyCurve = PolyCurve.by_points(
                [Point(x, y, 0),
                 Point(x + width, y, 0),
                 Point(x, y + height, 0),
                 Point(x, y, 0)]
            )
            SL.q1 = SL.q2 = SL.q3 = q123  # [kN/m2]
            SurfaceLoads.append(SL)
            x = x + dx
        y = y + dy
    return SurfaceLoads




class TickMark:
    # Dimension Tick Mark
    def __init__(self):
        self.name = None
        self.id = generateID()
        self.curves = []

    @staticmethod
    def by_curves(name, curves):
        TM = TickMark()
        TM.name = name
        TM.curves = curves
        return TM


TMDiagonal = TickMark.by_curves(
    "diagonal", [Line(start=Point(-100, -100, 0), end=Point(100, 100, 0))])


class DimensionType:
    def __init__(self):
        self.name = None
        self.id = generateID()
        self.type = __class__.__name__
        self.font = None
        self.text_height = 2.5
        self.tick_mark: TickMark = TMDiagonal
        self.line_extension = 100

    def serialize(self):
        return {
            'name': self.name,
            'id': self.id,
            'type': self.type,
            'font': self.font,
            'text_height': self.text_height,
            'tick_mark': str(self.tick_mark),
            'line_extension': self.line_extension
        }

    @staticmethod
    def deserialize(data):
        dimension_type = DimensionType()
        dimension_type.name = data.get('name')
        dimension_type.id = data.get('id')
        dimension_type.type = data.get('type')
        dimension_type.font = data.get('font')
        dimension_type.text_height = data.get('text_height', 2.5)

        # Handle TickMark deserialization
        tick_mark_str = data.get('tick_mark')
        # Adjust according to your TickMark implementation
        dimension_type.tick_mark = TickMark(tick_mark_str)

        dimension_type.line_extension = data.get('line_extension', 100)

        return dimension_type

    @staticmethod
    def by_name_font_textheight_tick_mark_extension(name: str, font: str, text_height: float, tick_mark: TickMark, line_extension: float):
        DT = DimensionType()
        DT.name = name
        DT.font = font
        DT.text_height = text_height
        DT.tick_mark = tick_mark
        DT.line_extension = line_extension
        return DT


DT2_5_mm = DimensionType.by_name_font_textheight_tick_mark_extension(
    "2.5 mm", "calibri", 2.5, TMDiagonal, 100)

DT1_8_mm = DimensionType.by_name_font_textheight_tick_mark_extension(
    "1.8 mm", "calibri", 2.5, TMDiagonal, 100)


class Dimension:
    def __init__(self, start: Point, end: Point, dimension_type) -> None:
        self.id = generateID()
        self.type = __class__.__name__
        self.start: Point = start
        self.text_height = 100
        self.end: Point = end
        self.scale = 0.1  # text
        self.dimension_type: DimensionType = dimension_type
        self.curves = []
        self.length: float = Line(start=self.start, end=self.end).length
        self.text = None
        self.geom()

    def serialize(self):
        return {
            'type': self.type,
            'start': self.start.serialize(),
            'end': self.end.serialize(),
            'text_height': self.text_height,
            'id': self.id,
            'scale': self.scale,
            'dimension_type': self.dimension_type.serialize(),
            'curves': [curve.serialize() for curve in self.curves],
            'length': self.length,
            'text': self.text
        }

    @staticmethod
    def deserialize(data):
        start = Point.deserialize(data['start'])
        end = Point.deserialize(data['end'])
        dimension_type = DimensionType.deserialize(data['dimension_type'])
        dimension = Dimension(start, end, dimension_type)

        dimension.text_height = data.get('text_height', 100)
        dimension.id = data.get('id')
        dimension.scale = data.get('scale', 0.1)
        dimension.curves = [Line.deserialize(
            curve_data) for curve_data in data.get('curves', [])]
        dimension.length = data.get('length')
        dimension.text = data.get('text')

        return dimension

    @staticmethod
    def by_startpoint_endpoint_offset(start: Point, end: Point, dimension_type: DimensionType, offset: float):
        DS = Dimension()
        DS.start = start
        DS.end = end
        DS.dimension_type = dimension_type
        DS.geom()
        return DS

    def geom(self):
        # baseline
        baseline = Line(start=self.start, end=self.end)
        midpoint_text = baseline.mid_point()
        direction = Vector3.normalize(baseline.vector)
        tick_mark_extension_point_1 = Point.translate(self.start, Vector3.reverse(
            Vector3.scale(direction, self.dimension_type.line_extension)))
        tick_mark_extension_point_2 = Point.translate(
            self.end, Vector3.scale(direction, self.dimension_type.line_extension))
        x = direction
        y = Vector3.rotate_XY(x, math.radians(90))
        z = ZAxis
        cs_new_start = CoordinateSystem(self.start, x, y, z)
        cs_new_mid = CoordinateSystem(midpoint_text, x, y, z)
        cs_new_end = CoordinateSystem(self.end, x, y, z)
        self.curves.append(Line(tick_mark_extension_point_1,
                           self.start))  # extention_start
        self.curves.append(
            Line(tick_mark_extension_point_2, self.end))  # extention_end
        self.curves.append(Line(self.start, self.end))  # baseline
        # erg vieze oplossing. #Todo
        crvs = Line(
            start=self.dimension_type.tick_mark.curves[0].start, end=self.dimension_type.tick_mark.curves[0].end)

        self.curves.append(Line.transform(
            self.dimension_type.tick_mark.curves[0], cs_new_start))  # dimension tick start
        self.curves.append(Line.transform(crvs, cs_new_end)
                           )  # dimension tick end
        self.text = Text(text=str(round(self.length)), font_family=self.dimension_type.font,
                         cs=cs_new_mid, height=self.text_height).write()

    def write(self, project):
        for i in self.curves:
            project.objects.append(i)
        for j in self.text:
            project.objects.append(j)


class FrameTag:
    def __init__(self):
        # Dimensions in 1/100 scale
        self.id = generateID()
        self.type = __class__.__name__
        self.scale = 0.1
        self.cs: CoordinateSystem = CSGlobal
        self.offset_x = 500
        self.offset_y = 100
        self.font_family = "calibri"
        self.text: str = "text"
        self.text_curves = None
        self.text_height = 100

    def serialize(self):
        id_value = str(self.id) if not isinstance(
            self.id, (str, int, float)) else self.id
        return {
            'id': id_value,
            'type': self.type,
            'scale': self.scale,
            'cs': self.cs.serialize(),
            'offset_x': self.offset_x,
            'offset_y': self.offset_y,
            'font_family': self.font_family,
            'text': self.text,
            'text_curves': self.text_curves,
            'text_height': self.text_height
        }

    @staticmethod
    def deserialize(data):
        frame_tag = FrameTag()
        frame_tag.scale = data.get('scale', 0.1)
        frame_tag.cs = CoordinateSystem.deserialize(data['cs'])
        frame_tag.offset_x = data.get('offset_x', 500)
        frame_tag.offset_y = data.get('offset_y', 100)
        frame_tag.font_family = data.get('font_family', "calibri")
        frame_tag.text = data.get('text', "text")
        frame_tag.text_curves = data.get('text_curves')
        frame_tag.text_height = data.get('text_height', 100)

        return frame_tag

    def __textobject(self):
        cstext = self.cs
        # cstextnew = cstext.translate(self.textoff_vector_local)
        self.text_curves = Text(
            text=self.text, font_family=self.font_family, height=self.text_height, cs=cstext).write

    def by_cs_text(self, coordinate_system: CoordinateSystem, text):
        self.cs = coordinate_system
        self.text = text
        self.__textobject()
        return self

    def write(self, project):
        for x in self.text_curves():
            project.objects.append(x)
        return self

    @staticmethod
    def by_frame(frame):
        tag = FrameTag()
        frame_vector = frame.vector_normalised
        x = frame_vector
        y = Vector3.rotate_XY(x, math.radians(90))
        z = ZAxis
        vx = Vector3.scale(frame_vector, tag.offset_x)
        frame_width = PolyCurve2D.bounds(frame.curve)[4]
        vy = Vector3.scale(y, frame_width*0.5+tag.offset_y)
        origintext = Point.translate(frame.start, vx)
        origintext = Point.translate(origintext, vy)
        csnew = CoordinateSystem(origintext, x, y, z)
        tag.cs = csnew
        tag.text = frame.name
        tag.__textobject()
        return tag


class ColumnTag:
    def __init__(self):
        # Dimensions in 1/100 scale
        self.id = generateID()
        self.type = __class__.__name__
        self.width = 700
        self.height = 500
        self.factor = 3  # hellingsfacor leader
        self.scale = 0.1  # voor tekeningverschaling
        self.position = "TL"  # TL, TR, BL, BR Top Left Top Right Bottom Left Bottom Right
        self.cs: CoordinateSystem = CSGlobal

        # self.textoff_vector_local: Vector3 = Vector3(1,1,1)
        self.font_family = "calibri"
        self.curves = []
        # self.leadercurves()
        self.text: str = "text"
        self.text_height = 100
        self.text_offset_factor = 5
        self.textoff_vector_local: Vector3 = Vector3(
            self.height/self.factor, self.height+self.height/self.text_offset_factor, 0)
        self.text_curves = None
        # self.textobject()

    def serialize(self):
        id_value = str(self.id) if not isinstance(
            self.id, (str, int, float)) else self.id
        return {
            'id': id_value,
            'type': self.type,
            'width': self.width,
            'height': self.height,
            'factor': self.factor,
            'scale': self.scale,
            'position': self.position,
            'cs': self.cs.serialize(),
            'font_family': self.font_family,
            'curves': [curve.serialize() for curve in self.curves],
            'text': self.text,
            'text_height': self.text_height,
            'text_offset_factor': self.text_offset_factor,
            'textoff_vector_local': self.textoff_vector_local.serialize(),
            'text_curves': self.text_curves
        }

    @staticmethod
    def deserialize(data):
        column_tag = ColumnTag()
        column_tag.width = data.get('width', 700)
        column_tag.height = data.get('height', 500)
        column_tag.factor = data.get('factor', 3)
        column_tag.scale = data.get('scale', 0.1)
        column_tag.position = data.get('position', "TL")
        column_tag.cs = CoordinateSystem.deserialize(data['cs'])
        column_tag.font_family = data.get('font_family', "calibri")
        column_tag.curves = [Line.deserialize(
            curve_data) for curve_data in data.get('curves', [])]
        column_tag.text = data.get('text', "text")
        column_tag.text_height = data.get('text_height', 100)
        column_tag.text_offset_factor = data.get('text_offset_factor', 5)
        column_tag.textoff_vector_local = Vector3.deserialize(
            data['textoff_vector_local'])
        column_tag.text_curves = data.get('text_curves')

        return column_tag

    def __leadercurves(self):
        self.startpoint = Point(0, 0, 0)
        self.midpoint = Point.translate(self.startpoint, Vector3(
            self.height/self.factor, self.height, 0))
        self.endpoint = Point.translate(
            self.midpoint, Vector3(self.width, 0, 0))
        crves = [Line(start=self.startpoint, end=self.midpoint),
                 Line(start=self.midpoint, end=self.endpoint)]
        for i in crves:
            j = Line.transform(i, self.cs)
            self.curves.append(j)

    def __textobject(self):
        cstext = self.cs

        cstextnew = CoordinateSystem.translate(
            cstext, self.textoff_vector_local)
        self.text_curves = Text(text=self.text, font_family=self.font_family,
                                height=self.text_height, cs=cstextnew).write

    def by_cs_text(self, coordinate_system: CoordinateSystem, text):
        self.cs = coordinate_system
        self.text = text
        self.__leadercurves()
        self.__textobject()
        return self

    def write(self, project):
        for x in self.text_curves():
            project.objects.append(x)
        for y in self.curves:
            project.objects.append(y)

    @staticmethod
    def by_frame(frame, position="TL"):
        tag = ColumnTag()
        csold = CSGlobal
        tag.position = position
        tag.cs = CoordinateSystem.translate(csold, Vector3(
            frame.start.x, frame.start.y, frame.start.z))
        tag.text = frame.name
        tag.__leadercurves()
        tag.__textobject()
        return tag

# class Label:
# class LabelType:
# class TextType:


seqChar = "A B C D E F G H I J K L M N O P Q R S T U V W X Y Z AA AB AC"
seqNumber = "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24"


class GridheadType:
    def __init__(self):
        self.id = generateID()
        self.type = __class__.__name__
        self.name = None
        self.curves = []
        self.diameter = 150
        self.text_height = 200
        self.radius = self.diameter/2
        self.font_family = "calibri"

    def serialize(self):
        id_value = str(self.id) if not isinstance(
            self.id, (str, int, float)) else self.id
        return {
            'id': id_value,
            'type': self.type,
            'name': self.name,
            'curves': [curve.serialize() for curve in self.curves],
            'diameter': self.diameter,
            'text_height': self.text_height,
            'radius': self.radius,
            'font_family': self.font_family
        }

    @staticmethod
    def deserialize(data):
        gridhead_type = GridheadType()
        gridhead_type.id = data.get('id')
        gridhead_type.type = data.get('type')
        gridhead_type.name = data.get('name')
        gridhead_type.curves = [Line.deserialize(curve_data) for curve_data in data.get(
            'curves', [])]  # Adjust for your Curve class
        gridhead_type.diameter = data.get('diameter', 150)
        gridhead_type.text_height = data.get('text_height', 200)
        gridhead_type.radius = data.get('radius', gridhead_type.diameter / 2)
        gridhead_type.font_family = data.get('font_family', "calibri")

        return gridhead_type

    def by_diam(self, name, diameter: float, font_family, text_height):
        self.name = name
        self.diameter = diameter
        self.radius = self.diameter / 2
        self.font_family = font_family
        self.text_height = text_height
        self.geom()
        return self

    def geom(self):
        radius = self.radius
        self.curves.append(Arc(startPoint=Point(-radius, radius, 0),
                           midPoint=Point(0, radius*2, 0), endPoint=Point(radius, radius, 0)))
        self.curves.append(Arc(startPoint=Point(-radius, radius, 0),
                           midPoint=Point(0, 0, 0), endPoint=Point(radius, radius, 0)))
        # origin is at center of circle


GHT30 = GridheadType().by_diam("2.5 mm", 400, "calibri", 200)

GHT50 = GridheadType().by_diam("GHT50", 600, "calibri", 350)


class GridHead:
    def __init__(self):
        self.id = generateID()
        self.type = __class__.__name__
        self.grid_name: str = "A"
        self.grid_head_type = GHT50
        self.radius = GHT50.radius
        self.CS: CoordinateSystem = CSGlobal
        self.x: float = 0.5
        self.y: float = 0
        self.text_curves = []
        self.curves = []
        self.__textobject()
        self.__geom()

    def serialize(self):
        id_value = str(self.id) if not isinstance(
            self.id, (str, int, float)) else self.id
        return {
            'id': id_value,
            'type': self.type,
            'grid_name': self.grid_name,
            'grid_head_type': self.grid_head_type.serialize(),
            'radius': self.radius,
            'CS': self.CS.serialize(),
            'x': self.x,
            'y': self.y,
            'text_curves': [curve.serialize() for curve in self.text_curves],
            'curves': [curve.serialize() for curve in self.curves]
        }

    @staticmethod
    def deserialize(data):
        grid_head = GridHead()
        grid_head.id = data.get('id')
        grid_head.type = data.get('type')
        grid_head.grid_name = data.get('grid_name')
        grid_head.grid_head_type = GridheadType.deserialize(
            data['grid_head_type'])
        grid_head.radius = data.get('radius', GHT50.radius)
        grid_head.CS = CoordinateSystem.deserialize(data['CS'])
        grid_head.x = data.get('x', 0.5)
        grid_head.y = data.get('y', 0)
        grid_head.text_curves = [Line.deserialize(
            curve_data) for curve_data in data.get('text_curves', [])]
        grid_head.curves = [Line.deserialize(
            curve_data) for curve_data in data.get('curves', [])]

        return grid_head

    def __geom(self):
        # CStot = CoordinateSystem.translate(self.CS,Vector3(0,self.grid_head_type.radius,0))
        for i in self.grid_head_type.curves:
            self.curves.append(transform_arc(i, (self.CS)))

    def __textobject(self):
        cs_text = self.CS
        # to change after center text function is implemented
        cs_text_new = CoordinateSystem.move_local(cs_text, -100, 40, 0)
        self.text_curves = Text(text=self.grid_name, font_family=self.grid_head_type.font_family,
                                height=self.grid_head_type.text_height, cs=cs_text_new).write()

    @staticmethod
    def by_name_gridheadtype_y(name, cs: CoordinateSystem, gridhead_type, y: float):
        GH = GridHead()
        GH.grid_name = name
        GH.grid_head_type = gridhead_type
        GH.CS = cs
        GH.x = 0.5
        GH.y = y
        GH.__textobject()
        GH.__geom()
        return GH

    def write(self, project):
        for x in self.text_curves:
            project.objects.append(x)
        for y in self.curves:
            project.objects.append(y)


class Grid:
    def __init__(self):
        self.line = None
        self.start = None
        self.end = None
        self.direction: Vector3 = Vector3(0, 1, 0)
        self.grid_head_type = GHT50
        self.name = None
        self.bulbStart = False
        self.bulbEnd = True
        self.cs_end: CoordinateSystem = CSGlobal
        self.grid_heads = []

    def __cs(self, line):
        self.direction = line.vector_normalised
        vect3 = Vector3.rotate_XY(self.direction, math.radians(-90))
        self.cs_end = CoordinateSystem(line.end, vect3, self.direction, ZAxis)

    @classmethod
    def by_startpoint_endpoint(cls, line, name):
        # Create panel by polycurve
        g1 = Grid()
        g1.start = line.start
        g1.end = line.start
        g1.name = name
        g1.__cs(line)
        g1.line = line_to_pattern(line, Centerline)
        # g1.__grid_heads()
        return g1

    def __grid_heads(self):
        if self.bulbEnd == True:
            self.grid_heads.append(
                GridHead.by_name_gridheadtype_y(self.name, self.cs_end, self.grid_head_type, 0))

    def write(self, project):
        for x in self.line:
            project.objects.append(x)
        for y in self.grid_heads:
            y.write(project)
        return self


def get_grid_distances(Grids):
    # Function to create grids from the format 0, 4x5400, 4000, 4000 to absolute XYZ-values
    GridsNew = []
    GridsNew.append(0)
    distance = 0.0
    # GridsNew.append(distance)
    for i in Grids:
        # del Grids[0]
        if "x" in i:
            spl = i.split("x")
            count = int(spl[0])
            width = float(spl[1])
            for i in range(count):
                distance = distance + width
                GridsNew.append(distance)
        else:
            distance = distance + float(i)
            GridsNew.append(distance)
    return GridsNew


class GridSystem:
    # rectangle Gridsystem
    def __init__(self):
        self.id = generateID()
        self.type = __class__.__name__
        self.gridsX = None
        self.gridsY = None
        self.dimensions = []
        self.name = None

    def serialize(self):
        id_value = str(self.id) if not isinstance(
            self.id, (str, int, float)) else self.id
        return {
            'id': id_value,
            'type': self.type,
            'gridsX': self.gridsX,
            'gridsY': self.gridsY,
            'dimensions': [dimension.serialize() for dimension in self.dimensions],
            'name': self.name
        }

    @staticmethod
    def deserialize(data):
        grid_system = GridSystem()
        grid_system.id = data.get('id')
        grid_system.type = data.get('type')
        grid_system.gridsX = data.get('gridsX')
        grid_system.gridsY = data.get('gridsY')
        grid_system.dimensions = [Dimension.deserialize(dim_data) for dim_data in data.get(
            'dimensions', [])]  # Adjust for your Dimension class
        grid_system.name = data.get('name')

        return grid_system

    @classmethod
    def by_spacing_labels(cls, spacingX, labelsX, spacingY, labelsY, gridExtension):
        gs = GridSystem()
        # Create gridsystem
        # spacingXformat = "0 3000 3000 3000"
        GridEx = gridExtension

        GridsX = spacingX.split()
        GridsX = get_grid_distances(GridsX)
        Xmax = max(GridsX)
        GridsXLable = labelsX.split()
        GridsY = spacingY.split()
        GridsY = get_grid_distances(GridsY)
        Ymax = max(GridsY)
        GridsYLable = labelsY.split()

        gridsX = []
        dimensions = []
        count = 0
        ymaxdim1 = Ymax+GridEx-300
        ymaxdim2 = Ymax+GridEx-0
        xmaxdim1 = Xmax+GridEx-300
        xmaxdim2 = Xmax+GridEx-0
        for i in GridsX:
            gridsX.append(Grid.by_startpoint_endpoint(
                Line(Point(i, -GridEx, 0), Point(i, Ymax+GridEx, 0)), GridsXLable[count]))
            try:
                dim = Dimension(Point(i, ymaxdim1, 0), Point(
                    GridsX[count+1], ymaxdim1, 0), DT2_5_mm)
                gs.dimensions.append(dim)
            except:
                pass
            count = count + 1

        # Totaal maatvoering 1
        dim = Dimension(Point(GridsX[0], ymaxdim2, 0), Point(
            Xmax, ymaxdim2, 0), DT2_5_mm)
        gs.dimensions.append(dim)

        # Totaal maatvoering 2
        dim = Dimension(Point(xmaxdim2, GridsY[0], 0), Point(
            xmaxdim2, Ymax, 0), DT2_5_mm)
        gs.dimensions.append(dim)

        gridsY = []
        count = 0
        for i in GridsY:
            gridsY.append(Grid.by_startpoint_endpoint(
                Line(Point(-GridEx, i, 0), Point(Xmax+GridEx, i, 0)), GridsYLable[count]))
            try:
                dim = Dimension(Point(xmaxdim1, i, 0), Point(
                    xmaxdim1, GridsY[count+1], 0))  # ,DT3_5_mm)
                gs.dimensions.append(dim)
            except:
                pass
            count = count + 1
        gs.gridsX = gridsX
        gs.gridsY = gridsY
        return gs

    def write(self, project):
        for x in self.gridsX:
            project.objects.append(x)
            for i in x.grid_heads:
                i.write(project)
        for y in self.gridsY:
            project.objects.append(y)
            for j in y.grid_heads:
                j.write(project)
        for z in self.dimensions:
            z.write(project)
        return self



def colorlist(extrus, color):
    colorlst = []
    for j in range(int(len(extrus.verts) / 3)):
        colorlst.append(color)
    return (colorlst)


# ToDo Na update van color moet ook de colorlist geupdate worden
class Frame:
    def __init__(self):
        self.id = generateID()
        self.type = __class__.__name__
        self.name = "None"
        self.profileName = "None"
        self.extrusion = None
        self.comments = None
        self.structuralType = None
        self.start = None
        self.end = None
        self.curve = None  # 2D polycurve of the sectionprofile
        self.curve3d = None  # Translated 3D polycurve of the sectionprofile
        self.length = 0
        self.coordinateSystem: CoordinateSystem = CSGlobal
        self.YJustification = "Origin"  # Top, Center, Origin, Bottom
        self.ZJustification = "Origin"  # Left, Center, Origin, Right
        self.YOffset = 0
        self.ZOffset = 0
        self.rotation = 0
        self.material = None
        self.color = BaseOther.color
        self.profile_data = None
        self.colorlst = []
        self.vector = None
        self.vector_normalised = None
        self.centerbottom = None

    def serialize(self):
        id_value = str(self.id) if not isinstance(
            self.id, (str, int, float)) else self.id
        return {
            'id': id_value,
            'type': self.type,
            'name': self.name,
            'profileName': self.profileName,
            'extrusion': self.extrusion,
            'comments': self.comments,
            'structuralType': self.structuralType,
            'start': self.start,
            'end': self.end,
            'curve': self.curve,
            'curve3d': self.curve3d,
            'length': self.length,
            'coordinateSystem': self.coordinateSystem.serialize(),
            'YJustification': self.YJustification,
            'ZJustification': self.ZJustification,
            'YOffset': self.YOffset,
            'ZOffset': self.ZOffset,
            'rotation': self.rotation,
            'material': self.material,
            'color': self.color,
            'colorlst': self.colorlst,
            'vector': self.vector.serialize() if self.vector else None,
            'vector_normalised': self.vector_normalised.serialize() if self.vector_normalised else None
        }

    @staticmethod
    def deserialize(data):
        frame = Frame()
        frame.id = data.get('id')
        frame.type = data.get('type')
        frame.name = data.get('name', "None")
        frame.profileName = data.get('profileName', "None")
        frame.extrusion = data.get('extrusion')
        frame.comments = data.get('comments')
        frame.structuralType = data.get('structuralType')
        frame.start = data.get('start')
        frame.end = data.get('end')
        frame.curve = data.get('curve')
        frame.curve3d = data.get('curve3d')
        frame.length = data.get('length', 0)
        frame.coordinateSystem = CoordinateSystem.deserialize(
            data['coordinateSystem'])
        frame.YJustification = data.get('YJustification', "Origin")
        frame.ZJustification = data.get('ZJustification', "Origin")
        frame.YOffset = data.get('YOffset', 0)
        frame.ZOffset = data.get('ZOffset', 0)
        frame.rotation = data.get('rotation', 0)
        frame.material = data.get('material')
        frame.color = data.get('color', BaseOther.color)
        frame.colorlst = data.get('colorlst', [])
        frame.vector = Vector3.deserialize(
            data['vector']) if 'vector' in data else None
        frame.vector_normalised = Vector3.deserialize(
            data['vector_normalised']) if 'vector_normalised' in data else None

        return frame

    def props(self):
        self.vector = Vector3(self.end.x-self.start.x,
                              self.end.y-self.start.y, self.end.z-self.start.z)
        self.vector_normalised = Vector3.normalize(self.vector)
        self.length = Vector3.length(self.vector)

    @classmethod
    def by_startpoint_endpoint_profile_name(cls, start: Point | Node, end: Point | Node, profile_name: str, name: str, material: None, comments=None):
        
        f1 = Frame()
        f1.comments = comments

        if start.type == 'Point':
            f1.start = start
        elif start.type == 'Node':
            f1.start = start.point
        if end.type == 'Point':
            f1.end = end
        elif end.type == 'Node':
            f1.end = end.point

        f1.curve = profiledataToShape(profile_name).polycurve2d  # polycurve2d
        f1.directionVector = Vector3.by_two_points(f1.start, f1.end)
        f1.length = Vector3.length(f1.directionVector)
        f1.name = name
        f1.extrusion = Extrusion.by_polycurve_height_vector(
            f1.curve, f1.length, CSGlobal, f1.start, f1.directionVector)
        f1.extrusion.name = name
        f1.curve3d = f1.extrusion.polycurve_3d_translated
        f1.profileName = profile_name
        f1.material = material
        f1.color = material.colorint
        f1.colorlst = colorlist(f1.extrusion, f1.color)
        f1.props()
        return f1

    @classmethod
    def by_startpoint_endpoint_profile_name_shapevector(cls, start: Point | Node, end: Point | Node, profile_name: str, name: str, vector2d: Vector2, rotation: float, material: None, comments: None):
        f1 = Frame()
        f1.comments = comments

        if start.type == 'Point':
            f1.start = start
        elif start.type == 'Node':
            f1.start = start.point
        if end.type == 'Point':
            f1.end = end
        elif end.type == 'Node':
            f1.end = end.point

        try:
            curv = profiledataToShape(profile_name).polycurve2d
        except Exception as e:
            # Profile does not exist
            print(f"Profile does not exist: {profile_name}\nError: {e}")

        f1.rotation = rotation
        curvrot = curv.rotate(rotation)  # rotation in degrees
        f1.curve = curvrot.translate(vector2d)
        f1.XOffset = vector2d.x
        f1.YOffset = vector2d.y
        f1.directionVector = Vector3.by_two_points(f1.start, f1.end)
        f1.length = Vector3.length(f1.directionVector)
        f1.name = name
        f1.extrusion = Extrusion.by_polycurve_height_vector(
            f1.curve, f1.length, CSGlobal, f1.start, f1.directionVector)
        f1.extrusion.name = name
        f1.curve3d = f1.extrusion.polycurve_3d_translated
        f1.profileName = profile_name
        f1.material = material
        f1.color = material.colorint
        f1.colorlst = colorlist(f1.extrusion, f1.color)
        f1.props()
        return f1

    @classmethod
    def by_startpoint_endpoint_profile_name_justifiction(cls, start: Point | Node, end: Point | Node, profile_name: str, name: str, XJustifiction: str, YJustifiction: str, rotation: float, material=None, ey: None = float, ez: None = float, structuralType: None = str, comments=None):
        f1 = Frame()
        f1.comments = comments

        if start.type == 'Point':
            f1.start = start
        elif start.type == 'Node':
            f1.start = start.point
        if end.type == 'Point':
            f1.end = end
        elif end.type == 'Node':
            f1.end = end.point

        f1.structuralType = structuralType
        f1.rotation = rotation

        f1.profile_data = profiledataToShape(profile_name)
        curve = f1.profile_data.polycurve2d

        v1 = justifictionToVector(curve, XJustifiction, YJustifiction)  # 1
        f1.XOffset = v1.x
        f1.YOffset = v1.y
        curve = curve.translate(v1)
        curve = curve.translate(Vector2(ey, ez))  # 2
        curve = curve.rotate(f1.rotation)  # 3
        f1.curve = curve

        f1.directionVector = Vector3.by_two_points(f1.start, f1.end)
        f1.length = Vector3.length(f1.directionVector)
        f1.name = name
        f1.extrusion = Extrusion.by_polycurve_height_vector(
            f1.curve, f1.length, CSGlobal, f1.start, f1.directionVector)
        f1.extrusion.name = name
        f1.curve3d = f1.extrusion.polycurve_3d_translated

        try:
            pnew = PolyCurve.by_joined_curves(f1.curve3d.curves)
            f1.centerbottom = PolyCurve.centroid(pnew)
        except:
            pass

        f1.profileName = profile_name
        f1.material = material
        f1.color = material.colorint
        f1.colorlst = colorlist(f1.extrusion, f1.color)
        f1.props()
        return f1

    @classmethod
    def by_startpoint_endpoint(cls, start: Point | Node, end: Point | Node, polycurve: PolyCurve2D, name: str, rotation: float, material=None, comments=None):
        # 2D polycurve
        f1 = Frame()
        f1.comments = comments

        if start.type == 'Point':
            f1.start = start
        elif start.type == 'Node':
            f1.start = start.point
        if end.type == 'Point':
            f1.end = end
        elif end.type == 'Node':
            f1.end = end.point

        f1.directionVector = Vector3.by_two_points(f1.start, f1.end)
        f1.length = Vector3.length(f1.directionVector)
        f1.name = name
        curvrot = polycurve.rotate(rotation)
        f1.extrusion = Extrusion.by_polycurve_height_vector(
            curvrot, f1.length, CSGlobal, f1.start, f1.directionVector)
        f1.extrusion.name = name
        f1.curve3d = curvrot
        f1.profileName = name
        f1.material = material
        f1.color = material.colorint
        f1.colorlst = colorlist(f1.extrusion, f1.color)
        f1.props()
        return f1

    @classmethod
    def by_point_height_rotation(cls, start: Point | Node, height: float, polycurve: PolyCurve2D, frame_name: str, rotation: float, material=None, comments=None):
        # 2D polycurve
        f1 = Frame()
        f1.comments = comments

        if start.type == 'Point':
            f1.start = start
        elif start.type == 'Node':
            f1.start = start.point

        f1.end = Point.translate(f1.start, Vector3(0, 0.00001, height))

        # self.curve = Line(start, end)
        f1.directionVector = Vector3.by_two_points(f1.start, f1.end)
        f1.length = Vector3.length(f1.directionVector)
        f1.name = frame_name
        f1.profileName = frame_name
        curvrot = polycurve.rotate(rotation)  # rotation in degrees
        f1.extrusion = Extrusion.by_polycurve_height_vector(
            curvrot, f1.length, CSGlobal, f1.start, f1.directionVector)
        f1.extrusion.name = frame_name
        f1.curve3d = curvrot
        f1.material = material
        f1.color = material.colorint
        f1.colorlst = colorlist(f1.extrusion, f1.color)
        f1.props()
        return f1

    @classmethod
    def by_point_profile_height_rotation(cls, start: Point | Node, height: float, profile_name: str, rotation: float, material=None, comments=None):
        f1 = Frame()
        f1.comments = comments

        if start.type == 'Point':
            f1.start = start
        elif start.type == 'Node':
            f1.start = start.point
        # TODO vertical column not possible
        f1.end = Point.translate(f1.start, Vector3(0, height))

        # self.curve = Line(start, end)
        f1.directionVector = Vector3.by_two_points(f1.start, f1.end)
        f1.length = Vector3.length(f1.directionVector)
        f1.name = profile_name
        f1.profileName = profile_name
        curv = profiledataToShape(profile_name).polycurve2d
        curvrot = curv.rotate(rotation)  # rotation in degrees
        f1.extrusion = Extrusion.by_polycurve_height_vector(
            curvrot.curves, f1.length, CSGlobal, f1.start, f1.directionVector)
        f1.extrusion.name = profile_name
        f1.curve3d = curvrot
        f1.profileName = profile_name
        f1.material = material
        f1.color = material.colorint
        f1.colorlst = colorlist(f1.extrusion, f1.color)
        f1.props()
        return f1

    @classmethod
    def by_startpoint_endpoint_curve_justifiction(cls, start: Point | Node, end: Point | Node, polycurve: PolyCurve2D, name: str, XJustifiction: str, YJustifiction: str, rotation: float, material=None, comments=None):
        f1 = Frame()
        f1.comments = comments

        if start.type == 'Point':
            f1.start = start
        elif start.type == 'Node':
            f1.start = start.point
        if end.type == 'Point':
            f1.end = end
        elif end.type == 'Node':
            f1.end = end.point

        f1.rotation = rotation
        curv = polycurve
        curvrot = curv.rotate(rotation)  # rotation in degrees
        # center, left, right, origin / center, top bottom, origin
        v1 = justifictionToVector(curvrot, XJustifiction, YJustifiction)
        f1.XOffset = v1.x
        f1.YOffset = v1.y
        f1.curve = curv.translate(v1)
        f1.directionVector = Vector3.by_two_points(f1.start, f1.end)
        f1.length = Vector3.length(f1.directionVector)
        f1.name = name
        f1.extrusion = Extrusion.by_polycurve_height_vector(
            f1.curve.curves, f1.length, CSGlobal, f1.start, f1.directionVector)
        f1.extrusion.name = name
        f1.profileName = "none"
        f1.material = material
        f1.color = material.colorint
        f1.colorlst = colorlist(f1.extrusion, f1.color)
        f1.props()
        return f1

    def write(self, project):
        project.objects.append(self)
        return self


# EVERYWHERE FOR EACH OBJECT A ROTATION/POSITION
# Make sure that the objects can be merged!

class WurksRaster3d:
    def __init__(self):
        self.id = generateID()
        self.type = __class__.__name__
        self.bottom = None
        self.top = None
        self.name = "x"
        self.lines = None

    def serialize(self):
        id_value = str(self.id) if not isinstance(
            self.id, (str, int, float)) else self.id
        return {
            'id': id_value,
            'type': self.type,
            'bottom': self.bottom.serialize() if self.bottom else None,
            'top': self.top.serialize() if self.top else None,
            'name': self.name,
            'lines': [line.serialize() for line in self.lines] if self.lines else None
        }

    @staticmethod
    def deserialize(data):
        wurks_raster3d = WurksRaster3d()
        wurks_raster3d.id = data.get('id')
        wurks_raster3d.type = data.get('type')
        wurks_raster3d.bottom = Surface.deserialize(
            data['bottom']) if 'bottom' in data else None
        wurks_raster3d.top = Surface.deserialize(
            data['top']) if 'top' in data else None
        wurks_raster3d.name = data.get('name', "x")

        if 'lines' in data and data['lines'] is not None:
            wurks_raster3d.lines = [PolyCurve.deserialize(
                line_data) for line_data in data['lines']]
        else:
            wurks_raster3d.lines = None

        return wurks_raster3d

    def by_line(self, lines: Line, bottom: float, top: float):
        self.bottom = Vector3(0, 0, bottom)
        self.top = Vector3(0, 0, top)
        self.lines = lines

        surfList = []
        for line in self.lines:
            pts = []
            pts.append(Point.translate(line.start, self.bottom))
            pts.append(Point.translate(line.end, self.bottom))
            pts.append(Point.translate(line.end, self.top))
            pts.append(Point.translate(line.start, self.top))
            project.objects.append(Surface(PolyCurve.by_points(pts)))
            surfList.append(Surface(PolyCurve.by_points(pts)))

        print(f"{len(surfList)}* {self.__class__.__name__} {project.createdTxt}")


class WurksPedestal:
    def __init__(self):
        self.topfilename = "temp\\jonathan\\pedestal_top.dxf"
        self.basefilename = "temp\\jonathan\\pedestal_foot.dxf"
        self.diameter = 10
        self.topheight = 3
        self.baseheight = 3
        self.cache = {}
        self.top_dxf = None
        self.base_dxf = None

    def load_dxf(self, filename):
        if filename in self.cache:
            return self.cache[filename]
        else:
            dxf = ReadDXF(filename).polycurve
            self.cache[filename] = dxf
            return dxf

    def load_top_dxf(self):
        if self.top_dxf is None:
            self.top_dxf = self.load_dxf(self.topfilename)
        return self.top_dxf

    def load_base_dxf(self):
        if self.base_dxf is None:
            self.base_dxf = self.load_dxf(self.basefilename)
        return self.base_dxf

    def by_point(self, points, height, rotation=None):
        if isinstance(points, Point):
            points = [points]

        top = self.load_top_dxf()
        base = self.load_base_dxf()

        for point in points:
            topcenter = Point.difference(top.centroid(), point)
            translated_top = top.translate(Point.to_vector(topcenter))
            project.objects.append(Extrusion.by_polycurve_height(
                translated_top, self.topheight, 0))

            frame = Rect(
                Vector3(x=(translated_top.centroid().x) - (self.diameter / 2),
                        y=(translated_top.centroid().y) - (self.diameter / 2),
                        z=point.z - self.topheight),
                self.diameter, self.diameter
            )
            project.objects.append(Extrusion.by_polycurve_height(
                frame, height - self.baseheight - self.topheight, 0))

            basecenter = Point.difference(base.centroid(), point)
            translated_base = base.translate(Point.to_vector(basecenter))
            project.objects.append(Extrusion.by_polycurve_height(
                translated_base, self.baseheight, -height))

        print(f"{len(points)}* {self.__class__.__name__} {project.createdTxt}")

    pass  # pootje, voet diameter(vierkant), verstelbare hoogte inregelen,


class WurksComputerFloor():  # centerpoint / rotation / panel pattern / ply
    pass  # some type of floor object


class WurksFloorFinish():
    pass  # direction / pattern / ect


class WorkPlane():
    def __init__(self):
        self.length = None
        self.width = None
        self.points = []

    def create(self, length: float = None, width: float = None) -> str:
        self.length = length or 1000
        self.width = width or 1000
        rect = Rect(Vector3(0, 0, 0), self.length, self.width)
        for pt in rect.points:
            self.points.append(pt)
        project.objects.append(rect)
        print(f"1* {self.__class__.__name__} {project.createdTxt}")
        return Rect(Vector3(0, 0, 0), self.length, self.width)

    pass  # pootje, voet diameter(vierkant), verstelbare hoogte inregelen,


WorkPlane = WorkPlane()
# rotation(Vector3)/#volume/#scale



sqrt2 = math.sqrt(2)

class Tshape:
    def __init__(self, name, h, b, h1, b1):
        self.Description = "T-shape"
        self.ID = "T"

        # parameters
        self.id = generateID()
        self.type = __class__.__name__
        self.name = name
        self.curve = []
        self.h = h  # height
        self.b = b  # width
        self.h1 = h1
        self.b1 = b1

        # describe points
        p1 = Point2D(b1 / 2, -h / 2)  # right bottom
        p2 = Point2D(b1 / 2, h / 2 - h1)  # right middle 1
        p3 = Point2D(b / 2, h / 2 - h1)  # right middle 2
        p4 = Point2D(b / 2, h / 2)  # right top
        p5 = Point2D(-b / 2, h / 2)  # left top
        p6 = Point2D(-b / 2, h / 2 - h1)  # left middle 2
        p7 = Point2D(-b1 / 2, h / 2 - h1)  # left middle 1
        p8 = Point2D(-b1 / 2, -h / 2)  # left bottom

        # describe curves
        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Line2D(p3, p4)
        l4 = Line2D(p4, p5)
        l5 = Line2D(p5, p6)
        l6 = Line2D(p6, p7)
        l7 = Line2D(p7, p8)
        l8 = Line2D(p8, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8])

    def serialize(self):
        id_value = str(self.id) if not isinstance(
            self.id, (str, int, float)) else self.id
        return {
            'id': id_value,
            'type': self.type,
            'Description': self.Description,
            'ID': self.ID,
            'name': self.name,
            'h': self.h,
            'b': self.b,
            'h1': self.h1,
            'b1': self.b1,
            'curve': self.curve.serialize() if self.curve else None
        }

    @staticmethod
    def deserialize(data):
        tshape = Tshape(
            name=data.get('name'),
            h=data.get('h'),
            b=data.get('b'),
            h1=data.get('h1'),
            b1=data.get('b1')
        )

        tshape.Description = data.get('Description', "T-shape")
        tshape.ID = data.get('ID', "T")
        tshape.curve = PolyCurve2D.deserialize(
            data['curve']) if 'curve' in data else None

        return tshape

    def __str__(self):
        return "Profile(" + f"{self.name})"


class Lshape:
    def __init__(self, name, h, b, h1, b1):
        self.Description = "L-shape"
        self.ID = "L"

        # parameters
        self.id = generateID()
        self.type = __class__.__name__
        self.name = name
        self.curve = []
        self.h = h  # height
        self.b = b  # width
        self.h1 = h1
        self.b1 = b1

        # describe points
        p1 = Point2D(b / 2, -h / 2)  # right bottom
        p2 = Point2D(b / 2, -h / 2 + h1)  # right middle
        p3 = Point2D(-b / 2 + b1, -h / 2 + h1)  # middle
        p4 = Point2D(-b / 2 + b1, h / 2)  # middle top
        p5 = Point2D(-b / 2, h / 2)  # left top
        p6 = Point2D(-b / 2, -h / 2)  # left bottom

        # describe curves
        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Line2D(p3, p4)
        l4 = Line2D(p4, p5)
        l5 = Line2D(p5, p6)
        l6 = Line2D(p6, p1)

        self.curve = PolyCurve2D().by_joined_curves([l1, l2, l3, l4, l5, l6])

    def serialize(self):
        return {
            'Description': self.Description,
            'ID': self.ID,
            'id': self.id,
            'type': self.type,
            'name': self.name,
            'h': self.h,
            'b': self.b,
            'h1': self.h1,
            'b1': self.b1,
            'curve': self.curve.serialize() if self.curve else None
        }

    @staticmethod
    def deserialize(data):
        lshape = Lshape(
            name=data.get('name'),
            h=data.get('h'),
            b=data.get('b'),
            h1=data.get('h1'),
            b1=data.get('b1')
        )

        lshape.Description = data.get('Description', "L-shape")
        lshape.ID = data.get('ID', "L")
        lshape.id = data.get('id')
        lshape.type = data.get('type')
        lshape.curve = PolyCurve2D.deserialize(
            data['curve']) if 'curve' in data else None

        return lshape

    def __str__(self):
        return "Profile(" + f"{self.name})"


class Eshape:
    def __init__(self, name, h, b, h1):
        self.Description = "E-shape"
        self.ID = "E"

        # parameters
        self.id = generateID()
        self.type = __class__.__name__
        self.name = name
        self.curve = []
        self.h = h  # height
        self.b = b  # width
        self.h1 = h1

        # describe points
        p1 = Point2D(b / 2, -h / 2)  # right bottom
        p2 = Point2D(b / 2, -h / 2 + h1)
        p3 = Point2D(-b / 2 + h1, -h / 2 + h1)
        p4 = Point2D(-b / 2 + h1, -h1 / 2)
        p5 = Point2D(b / 2, -h1 / 2)
        p6 = Point2D(b / 2, h1 / 2)
        p7 = Point2D(-b / 2 + h1, h1 / 2)
        p8 = Point2D(-b / 2 + h1, h / 2 - h1)
        p9 = Point2D(b / 2, h / 2 - h1)
        p10 = Point2D(b / 2, h / 2)
        p11 = Point2D(-b / 2, h / 2)
        p12 = Point2D(-b / 2, -h / 2)

        # describe curves
        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Line2D(p3, p4)
        l4 = Line2D(p4, p5)
        l5 = Line2D(p5, p6)
        l6 = Line2D(p6, p7)
        l7 = Line2D(p7, p8)
        l8 = Line2D(p8, p9)
        l9 = Line2D(p9, p10)
        l10 = Line2D(p10, p11)
        l11 = Line2D(p11, p12)
        l12 = Line2D(p12, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12])

    def serialize(self):
        return {
            'Description': self.Description,
            'ID': self.ID,
            'id': self.id,
            'type': self.type,
            'name': self.name,
            'h': self.h,
            'b': self.b,
            'h1': self.h1,
            'curve': self.curve.serialize() if self.curve else None
        }

    @staticmethod
    def deserialize(data):
        eshape = Eshape(
            name=data.get('name'),
            h=data.get('h'),
            b=data.get('b'),
            h1=data.get('h1')
        )

        eshape.Description = data.get('Description', "E-shape")
        eshape.ID = data.get('ID', "E")
        eshape.id = data.get('id')
        eshape.type = data.get('type')
        eshape.curve = PolyCurve2D.deserialize(
            data['curve']) if 'curve' in data else None

        return eshape

    def __str__(self):
        return "Profile(" + f"{self.name})"


class Nshape:
    def __init__(self, name, h, b, b1):
        self.Description = "N-shape"
        self.ID = "N"

        # parameters
        self.id = generateID()
        self.type = __class__.__name__
        self.name = name
        self.curve = []
        self.h = h  # height
        self.b = b  # width
        self.b1 = b1

        # describe points
        p1 = Point2D(b / 2, -h / 2)  # right bottom
        p2 = Point2D(b / 2, h / 2)
        p3 = Point2D(b / 2 - b1, h / 2)
        p4 = Point2D(b / 2 - b1, -h / 2 + b1 * 2)
        p5 = Point2D(-b / 2 + b1, h / 2)
        p6 = Point2D(-b / 2, h / 2)
        p7 = Point2D(-b / 2, -h / 2)
        p8 = Point2D(-b / 2 + b1, -h / 2)
        p9 = Point2D(-b / 2 + b1, h / 2 - b1 * 2)
        p10 = Point2D(b / 2 - b1, -h / 2)

        # describe curves
        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Line2D(p3, p4)
        l4 = Line2D(p4, p5)
        l5 = Line2D(p5, p6)
        l6 = Line2D(p6, p7)
        l7 = Line2D(p7, p8)
        l8 = Line2D(p8, p9)
        l9 = Line2D(p9, p10)
        l10 = Line2D(p10, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10])

    def serialize(self):
        return {
            'Description': self.Description,
            'ID': self.ID,
            'id': self.id,
            'type': self.type,
            'name': self.name,
            'h': self.h,
            'b': self.b,
            'b1': self.b1,
            'curve': self.curve.serialize() if self.curve else None
        }

    @staticmethod
    def deserialize(data):
        nshape = Nshape(
            name=data.get('name'),
            h=data.get('h'),
            b=data.get('b'),
            b1=data.get('b1')
        )

        nshape.Description = data.get('Description', "N-shape")
        nshape.ID = data.get('ID', "N")
        nshape.id = data.get('id')
        nshape.type = data.get('type')
        nshape.curve = PolyCurve2D.deserialize(
            data['curve']) if 'curve' in data else None

        return nshape

    def __str__(self):
        return "Profile(" + f"{self.name})"


class Arrowshape:
    def __init__(self, name, l, b, b1, l1):
        self.Description = "Arrow-shape"
        self.ID = "Arrowshape"

        # parameters
        self.id = generateID()
        self.type = __class__.__name__
        self.name = name
        self.curve = []
        self.l = l  # length
        self.b = b  # width
        self.b1 = b1
        self.l1 = l1

        # describe points
        p1 = Point2D(0, l / 2)  # top middle
        p2 = Point2D(b / 2, -l / 2 + l1)
        # p3 = Point2D(b1 / 2, -l / 2 + l1)
        p3 = Point2D(b1 / 2, (-l / 2 + l1) + (l / 2) / 4)
        p4 = Point2D(b1 / 2, -l / 2)
        p5 = Point2D(-b1 / 2, -l / 2)
        # p6 = Point2D(-b1 / 2, -l / 2 + l1)
        p6 = Point2D(-b1 / 2, (-l / 2 + l1) + (l / 2) / 4)
        p7 = Point2D(-b / 2, -l / 2 + l1)

        # describe curves
        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Line2D(p3, p4)
        l4 = Line2D(p4, p5)
        l5 = Line2D(p5, p6)
        l6 = Line2D(p6, p7)
        l7 = Line2D(p7, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7])

    def serialize(self):
        return {
            'Description': self.Description,
            'ID': self.ID,
            'id': self.id,
            'type': self.type,
            'name': self.name,
            'l': self.l,
            'b': self.b,
            'b1': self.b1,
            'l1': self.l1,
            'curve': self.curve.serialize() if self.curve else None
        }

    @staticmethod
    def deserialize(data):
        arrowshape = Arrowshape(
            name=data.get('name'),
            l=data.get('l'),
            b=data.get('b'),
            b1=data.get('b1'),
            l1=data.get('l1')
        )

        arrowshape.Description = data.get('Description', "Arrow-shape")
        arrowshape.ID = data.get('ID', "Arrowshape")
        arrowshape.id = data.get('id')
        arrowshape.type = data.get('type')
        arrowshape.curve = PolyCurve2D.deserialize(
            data['curve']) if 'curve' in data else None

        return arrowshape

    def __str__(self):
        return "Profile(" + f"{self.name})"



sqrt2 = math.sqrt(2)

# Hierachie:
# point 2D
# line 2D
# PolyCurve2D 2D
# shape is een parametrische vorm heeft als resultaat een 2D curve
# section is een profiel met eigenschappen HEA200, 200,200,10,10,5 en eventuele rekenkundige eigenschappen.
# beam is een object wat in 3D zit met materiaal enz.


class CChannelParallelFlange:
    def __init__(self, name, h, b, tw, tf, r, ex):
        self.Description = "C-channel with parallel flange"
        self.ID = "C_PF"

        # parameters
        self.id = generateID()
        self.type = __class__.__name__
        self.name = name
        self.curve = []
        self.h = h  # height
        self.b = b  # width
        self.tw = tw  # web thickness
        self.tf = tf  # flange thickness
        self.r1 = r  # web fillet
        self.ex = ex  # centroid horizontal
        self.IfcProfileDef = "IfcUShapeProfileDef"

        # describe points
        p1 = Point2D(-ex, -h / 2)  # left bottom
        p2 = Point2D(b - ex, -h / 2)  # right bottom
        p3 = Point2D(b - ex, -h / 2 + tf)
        p4 = Point2D(-ex + tw + r, -h / 2 + tf)  # start arc
        p5 = Point2D(-ex + tw + r, -h / 2 + tf + r)  # second point arc
        p6 = Point2D(-ex + tw, -h / 2 + tf + r)  # end arc
        p7 = Point2D(-ex + tw, h / 2 - tf - r)  # start arc
        p8 = Point2D(-ex + tw + r, h / 2 - tf - r)  # second point arc
        p9 = Point2D(-ex + tw + r, h / 2 - tf)  # end arc
        p10 = Point2D(b - ex, h / 2 - tf)
        p11 = Point2D(b - ex, h / 2)  # right top
        p12 = Point2D(-ex, h / 2)  # left top

        # describe curves
        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Line2D(p3, p4)
        l4 = Arc2D(p4, p5, p6)
        l5 = Line2D(p6, p7)
        l6 = Arc2D(p7, p8, p9)
        l7 = Line2D(p9, p10)
        l8 = Line2D(p10, p11)
        l9 = Line2D(p11, p12)
        l10 = Line2D(p12, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10])

    def serialize(self):
        return {
            'id': self.id,
            'type': self.type,
            'Description': self.Description,
            'ID': self.ID,
            'name': self.name,
            'h': self.h,
            'b': self.b,
            'tw': self.tw,
            'tf': self.tf,
            'r1': self.r1,
            'ex': self.ex,
            'curve': self.curve.serialize() if self.curve else None
        }

    @staticmethod
    def deserialize(data):
        c_channel = CChannelParallelFlange(
            name=data.get('name'),
            h=data.get('h'),
            b=data.get('b'),
            tw=data.get('tw'),
            tf=data.get('tf'),
            r=data.get('r1'),
            ex=data.get('ex')
        )

        c_channel.Description = data.get(
            'Description', "C-channel with parallel flange")
        c_channel.ID = data.get('ID', "C_PF")
        c_channel.curve = PolyCurve2D.deserialize(
            data['curve']) if 'curve' in data else None

        return c_channel

    def __str__(self):
        return f"{self.type} ({self.name})"


class CChannelSlopedFlange:
    def __init__(self, name, h, b, tw, tf, r1, r2, tl, sa, ex):
        self.Description = "C-channel with sloped flange"
        self.ID = "C_SF"

        # parameters
        self.id = generateID()
        self.type = __class__.__name__
        self.name = name
        self.curve = []
        self.b = b  # width
        self.h = h  # height
        self.tf = tf  # flange thickness
        self.tw = tw  # web thickness
        self.r1 = r1  # web fillet
        self.r11 = r1 / sqrt2
        self.r2 = r2  # flange fillet
        self.r21 = r2 / sqrt2
        self.tl = tl  # flange thickness location from right
        self.sa = math.radians(sa)  # the angle of sloped flange in degrees
        self.ex = ex  # centroid horizontal
        self.IfcProfileDef = "IfcUShapeProfileDef"

        # describe points
        p1 = Point2D(-ex, -h / 2)  # left bottom
        p2 = Point2D(b - ex, -h / 2)  # right bottom
        p3 = Point2D(b - ex, -h / 2 + tf - math.tan(self.sa)
                     * tl - r2)  # start arc
        p4 = Point2D(b - ex - r2 + self.r21, -h / 2 + tf -
                     math.tan(self.sa) * tl - r2 + self.r21)  # second point arc
        p5 = Point2D(b - ex - r2 + math.sin(self.sa) * r2, -h /
                     2 + tf - math.tan(self.sa) * (tl - r2))  # end arc
        p6 = Point2D(-ex + tw + r1 - math.sin(self.sa) * r1, -h / 2 +
                     tf + math.tan(self.sa) * (b - tl - tw - r1))  # start arc
        p7 = Point2D(-ex + tw + r1 - self.r11, -h / 2 + tf + math.tan(self.sa)
                     * (b - tl - tw - r1) + r1 - self.r11)  # second point arc
        p8 = Point2D(-ex + tw, -h / 2 + tf + math.tan(self.sa)
                     * (b - tl - tw) + r1)  # end arc
        p9 = Point2D(p8.x, -p8.y)  # start arc
        p10 = Point2D(p7.x, -p7.y)  # second point arc
        p11 = Point2D(p6.x, -p6.y)  # end arc
        p12 = Point2D(p5.x, -p5.y)  # start arc
        p13 = Point2D(p4.x, -p4.y)  # second point arc
        p14 = Point2D(p3.x, -p3.y)  # end arc
        p15 = Point2D(p2.x, -p2.y)  # right top
        p16 = Point2D(p1.x, -p1.y)  # left top

        # describe curves
        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Arc2D(p3, p4, p5)
        l4 = Line2D(p5, p6)
        l5 = Arc2D(p6, p7, p8)
        l6 = Line2D(p8, p9)
        l7 = Arc2D(p9, p10, p11)
        l8 = Line2D(p11, p12)
        l9 = Arc2D(p12, p13, p14)
        l10 = Line2D(p14, p15)
        l11 = Line2D(p15, p16)
        l12 = Line2D(p16, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12])

    def serialize(self):
        return {
            'Description': self.Description,
            'ID': self.ID,
            'id': self.id,
            'type': self.type,
            'name': self.name,
            'h': self.h,
            'b': self.b,
            'tw': self.tw,
            'tf': self.tf,
            'r1': self.r1,
            'r11': self.r11,
            'r2': self.r2,
            'r21': self.r21,
            'tl': self.tl,
            'sa': self.sa,
            'ex': self.ex,
            'curve': self.curve.serialize() if self.curve else None
        }

    @staticmethod
    def deserialize(data):
        c_channel_sf = CChannelSlopedFlange(
            name=data.get('name'),
            h=data.get('h'),
            b=data.get('b'),
            tw=data.get('tw'),
            tf=data.get('tf'),
            r1=data.get('r1'),
            r2=data.get('r2'),
            tl=data.get('tl'),
            sa=data.get('sa'),
            ex=data.get('ex')
        )

        c_channel_sf.Description = data.get(
            'Description', "C-channel with sloped flange")
        c_channel_sf.ID = data.get('ID', "C_SF")
        c_channel_sf.id = data.get('id')
        c_channel_sf.type = data.get('type')
        c_channel_sf.curve = PolyCurve2D.deserialize(
            data['curve']) if 'curve' in data else None

        return c_channel_sf

    def __str__(self):
        return f"{self.type} ({self.name})"


class IShapeParallelFlange:
    def __init__(self, name, h, b, tw, tf, r):
        self.Description = "I Shape profile with parallel flange"
        self.ID = "I_PF"
        # HEA, IPE, HEB, HEM etc.

        # parameters
        self.id = generateID()
        self.type = __class__.__name__
        self.name = name
        self.h = h  # height
        self.b = b  # width
        self.tw = tw  # web thickness
        self.tf = tf  # flange thickness
        self.r = r  # web fillet
        self.r1 = r1 = r / sqrt2
        self.IfcProfileDef = "IfcIShapeProfileDef"

        # describe points
        p1 = Point2D(b / 2, -h / 2)  # right bottom
        p2 = Point2D(b / 2, -h / 2 + tf)
        p3 = Point2D(tw / 2 + r, -h / 2 + tf)  # start arc
        # second point arc
        p4 = Point2D(tw / 2 + r - r1, (-h / 2 + tf + r - r1))
        p5 = Point2D(tw / 2, -h / 2 + tf + r)  # end arc
        p6 = Point2D(tw / 2, h / 2 - tf - r)  # start arc
        p7 = Point2D(tw / 2 + r - r1, h / 2 - tf - r + r1)  # second point arc
        p8 = Point2D(tw / 2 + r, h / 2 - tf)  # end arc
        p9 = Point2D(b / 2, h / 2 - tf)
        p10 = Point2D((b / 2), (h / 2))  # right top
        p11 = Point2D(-p10.x, p10.y)  # left top
        p12 = Point2D(-p9.x, p9.y)
        p13 = Point2D(-p8.x, p8.y)  # start arc
        p14 = Point2D(-p7.x, p7.y)  # second point arc
        p15 = Point2D(-p6.x, p6.y)  # end arc
        p16 = Point2D(-p5.x, p5.y)  # start arc
        p17 = Point2D(-p4.x, p4.y)  # second point arc
        p18 = Point2D(-p3.x, p3.y)  # end arc
        p19 = Point2D(-p2.x, p2.y)
        p20 = Point2D(-p1.x, p1.y)

        # describe curves
        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Arc2D(p3, p4, p5)
        l4 = Line2D(p5, p6)
        l5 = Arc2D(p6, p7, p8)
        l6 = Line2D(p8, p9)
        l7 = Line2D(p9, p10)
        l8 = Line2D(p10, p11)
        l9 = Line2D(p11, p12)
        l10 = Line2D(p12, p13)
        l11 = Arc2D(p13, p14, p15)
        l12 = Line2D(p15, p16)
        l13 = Arc2D(p16, p17, p18)
        l14 = Line2D(p18, p19)
        l15 = Line2D(p19, p20)
        l16 = Line2D(p20, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16])

    def serialize(self):
        return {
            'Description': self.Description,
            'ID': self.ID,
            'id': self.id,
            'type': self.type,
            'name': self.name,
            'h': self.h,
            'b': self.b,
            'tw': self.tw,
            'tf': self.tf,
            'r': self.r,
            'r1': self.r1,
            'curve': self.curve.serialize() if self.curve else None
        }

    @staticmethod
    def deserialize(data):
        i_shape_pf = IShapeParallelFlange(
            name=data.get('name'),
            h=data.get('h'),
            b=data.get('b'),
            tw=data.get('tw'),
            tf=data.get('tf'),
            r=data.get('r')
        )

        i_shape_pf.Description = data.get(
            'Description', "I Shape profile with parallel flange")
        i_shape_pf.ID = data.get('ID', "I_PF")
        i_shape_pf.id = data.get('id')
        i_shape_pf.type = data.get('type')
        i_shape_pf.r1 = data.get('r1')
        i_shape_pf.curve = PolyCurve2D.deserialize(
            data['curve']) if 'curve' in data else None

        return i_shape_pf

    def __str__(self):
        return f"{self.type} ({self.name})"


class Rectangle:
    def __init__(self, name, b, h):
        self.Description = "Rectangle"
        self.ID = "Rec"

        # parameters
        self.id = generateID()
        self.type = __class__.__name__
        self.name = name
        self.curve = []
        self.h = h  # height
        self.b = b  # width
        self.IfcProfileDef = "IfcRectangleProfileDef"

        # describe points
        p1 = Point2D(b / 2, -h / 2)  # right bottom
        p2 = Point2D(b / 2, h / 2)  # right top
        p3 = Point2D(-b / 2, h / 2)  # left top
        p4 = Point2D(-b / 2, -h / 2)  # left bottom

        # describe curves
        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Line2D(p3, p4)
        l4 = Line2D(p4, p1)

        self.curve = PolyCurve2D().by_joined_curves([l1, l2, l3, l4])

    def serialize(self):
        return {
            'Description': self.Description,
            'ID': self.ID,
            'id': self.id,
            'type': self.type,
            'name': self.name,
            'h': self.h,
            'b': self.b,
            'curve': self.curve.serialize() if self.curve else None
        }

    @staticmethod
    def deserialize(data):
        rectangle = Rectangle(
            name=data.get('name'),
            b=data.get('b'),
            h=data.get('h')
        )

        rectangle.Description = data.get('Description', "Rectangle")
        rectangle.ID = data.get('ID', "Rec")
        rectangle.id = data.get('id')
        rectangle.type = data.get('type')
        rectangle.curve = PolyCurve2D.deserialize(
            data['curve']) if 'curve' in data else None

        return rectangle

    def __str__(self):
        return f"{self.type} ({self.name})"


class Round:
    def __init__(self, name, r):
        self.Description = "Round"
        self.ID = "Rnd"

        # parameters
        self.id = generateID()
        self.type = __class__.__name__
        self.name = name
        self.curve = []
        self.r = r  # radius
        self.data = (name, r, "Round")
        dr = r / sqrt2  # grootste deel
        self.IfcProfileDef = "IfcCircleProfileDef"

        # describe points
        p1 = Point2D(r, 0)  # right middle
        p2 = Point2D(dr, dr)
        p3 = Point2D(0, r)  # middle top
        p4 = Point2D(-dr, dr)
        p5 = Point2D(-r, 0)  # left middle
        p6 = Point2D(-dr, -dr)
        p7 = Point2D(0, -r)  # middle bottom
        p8 = Point2D(dr, -dr)

        # describe curves
        l1 = Arc2D(p1, p2, p3)
        l2 = Arc2D(p3, p4, p5)
        l3 = Arc2D(p5, p6, p7)
        l4 = Arc2D(p7, p8, p1)

        self.curve = PolyCurve2D().by_joined_curves([l1, l2, l3, l4])

    def serialize(self):
        return {
            'Description': self.Description,
            'ID': self.ID,
            'id': self.id,
            'type': self.type,
            'name': self.name,
            'r': self.r,
            'data': self.data,
            'curve': self.curve.serialize() if self.curve else None
        }

    @staticmethod
    def deserialize(data):
        round_shape = Round(
            name=data.get('name'),
            r=data.get('r')
        )

        round_shape.Description = data.get('Description', "Round")
        round_shape.ID = data.get('ID', "Rnd")
        round_shape.id = data.get('id')
        round_shape.type = data.get('type')
        round_shape.data = data.get(
            'data', (data.get('name'), data.get('r'), "Round"))
        round_shape.curve = PolyCurve2D.deserialize(
            data['curve']) if 'curve' in data else None

        return round_shape

    def __str__(self):
        return f"{self.type} ({self.name})"


class Roundtube:
    def __init__(self, name, d, t):
        self.Description = "Round Tube Profile"
        self.ID = "Tube"

        # parameters
        self.id = generateID()
        self.type = __class__.__name__
        self.name = name
        self.curve = []
        self.d = d
        self.r = d/2  # radius
        self.t = t  # wall thickness
        self.data = (name, d, t, "Round Tube Profile")
        dr = self.r / sqrt2  # grootste deel
        r = self.r
        ri = r-t
        dri = ri / sqrt2
        self.IfcProfileDef = "IfcCircleHollowProfileDef"

        # describe points
        p1 = Point2D(r, 0)  # right middle
        p2 = Point2D(dr, dr)
        p3 = Point2D(0, r)  # middle top
        p4 = Point2D(-dr, dr)
        p5 = Point2D(-r, 0)  # left middle
        p6 = Point2D(-dr, -dr)
        p7 = Point2D(0, -r)  # middle bottom
        p8 = Point2D(dr, -dr)

        p9 = Point2D(ri, 0)  # right middle inner
        p10 = Point2D(dri, dri)
        p11 = Point2D(0, ri)  # middle top inner
        p12 = Point2D(-dri, dri)
        p13 = Point2D(-ri, 0)  # left middle inner
        p14 = Point2D(-dri, -dri)
        p15 = Point2D(0, -ri)  # middle bottom inner
        p16 = Point2D(dri, -dri)

        # describe curves
        l1 = Arc2D(p1, p2, p3)
        l2 = Arc2D(p3, p4, p5)
        l3 = Arc2D(p5, p6, p7)
        l4 = Arc2D(p7, p8, p1)

        l5 = Line2D(p1, p9)

        l6 = Arc2D(p9, p10, p11)
        l7 = Arc2D(p11, p12, p13)
        l8 = Arc2D(p13, p14, p15)
        l9 = Arc2D(p15, p16, p9)
        l10 = Line2D(p9, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10])

    def serialize(self):
        return {
            'Description': self.Description,
            'ID': self.ID,
            'id': self.id,
            'type': self.type,
            'name': self.name,
            'd': self.d,
            'r': self.r,
            't': self.t,
            'data': self.data,
            'curve': self.curve.serialize() if self.curve else None
        }

    @staticmethod
    def deserialize(data):
        roundtube = Roundtube(
            name=data.get('name'),
            d=data.get('d'),
            t=data.get('t')
        )

        roundtube.Description = data.get('Description', "Round Tube Profile")
        roundtube.ID = data.get('ID', "Tube")
        roundtube.id = data.get('id')
        roundtube.type = data.get('type')
        roundtube.data = data.get('data', (data.get('name'), data.get(
            'd'), data.get('t'), "Round Tube Profile"))
        roundtube.curve = PolyCurve2D.deserialize(
            data['curve']) if 'curve' in data else None

        return roundtube

    def __str__(self):
        return f"{self.type} ({self.name})"


class LAngle:
    def __init__(self, name, h, b, tw, tf, r1, r2, ex, ey):
        self.Description = "LAngle"
        self.ID = "L"

        # parameters
        self.id = generateID()
        self.type = __class__.__name__
        self.name = name
        self.curve = []
        self.b = b  # width
        self.h = h  # height
        self.tw = tw  # wall nominal thickness
        self.tf = tw
        self.r1 = r1  # inner fillet
        self.r11 = r1 / sqrt2
        self.r2 = r2  # outer fillet
        self.r21 = r2 / sqrt2
        self.ex = ex  # from left
        self.ey = ey  # from bottom
        self.IfcProfileDef = "IfcLShapeProfileDef"

        # describe points
        p1 = Point2D(-ex, -ey)  # left bottom
        p2 = Point2D(b - ex, -ey)  # right bottom
        p3 = Point2D(b - ex, -ey + tf - r2)  # start arc
        p4 = Point2D(b - ex - r2 + self.r21, -ey + tf -
                     r2 + self.r21)  # second point arc
        p5 = Point2D(b - ex - r2, -ey + tf)  # end arc
        p6 = Point2D(-ex + tf + r1, -ey + tf)  # start arc
        p7 = Point2D(-ex + tf + r1 - self.r11, -ey + tf +
                     r1 - self.r11)  # second point arc
        p8 = Point2D(-ex + tf, -ey + tf + r1)  # end arc
        p9 = Point2D(-ex + tf, h - ey - r2)  # start arc
        p10 = Point2D(-ex + tf - r2 + self.r21, h - ey -
                      r2 + self.r21)  # second point arc
        p11 = Point2D(-ex + tf - r2, h - ey)  # end arc
        p12 = Point2D(-ex, h - ey)  # left top

        # describe curves
        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Arc2D(p3, p4, p5)
        l4 = Line2D(p5, p6)
        l5 = Arc2D(p6, p7, p8)
        l6 = Line2D(p8, p9)
        l7 = Arc2D(p9, p10, p11)
        l8 = Line2D(p11, p12)
        l9 = Line2D(p12, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9])

    def serialize(self):
        return {
            'Description': self.Description,
            'ID': self.ID,
            'id': self.id,
            'type': self.type,
            'name': self.name,
            'b': self.b,
            'h': self.h,
            'tw': self.tw,
            'tf': self.tf,
            'r1': self.r1,
            'r11': self.r11,
            'r2': self.r2,
            'r21': self.r21,
            'ex': self.ex,
            'ey': self.ey,
            'curve': self.curve.serialize() if self.curve else None
        }

    @staticmethod
    def deserialize(data):
        langle = LAngle(
            name=data.get('name'),
            h=data.get('h'),
            b=data.get('b'),
            tw=data.get('tw'),
            tf=data.get('tf'),
            r1=data.get('r1'),
            r2=data.get('r2'),
            ex=data.get('ex'),
            ey=data.get('ey')
        )

        langle.Description = data.get('Description', "LAngle")
        langle.ID = data.get('ID', "L")
        langle.id = data.get('id')
        langle.type = data.get('type')
        langle.r11 = data.get('r11')
        langle.r21 = data.get('r21')
        langle.curve = PolyCurve2D.deserialize(
            data['curve']) if 'curve' in data else None

        return langle

    def __str__(self):
        return f"{self.type} ({self.name})"


class TProfile:
    # ToDo: inner outer fillets in polycurve
    def __init__(self, name, h, b, tw, tf, r, r1, r2, ex, ey):
        self.Description = "TProfile"
        self.ID = "T"

        # parameters
        self.id = generateID()
        self.type = __class__.__name__
        self.name = name
        self.curve = []
        self.b = b  # width
        self.h = h  # height
        self.tw = tw  # wall nominal thickness
        self.tf = tw
        self.r = r  # inner fillet
        self.r01 = r/sqrt2
        self.r1 = r1  # outer fillet flange
        self.r11 = r1 / sqrt2
        self.r2 = r2  # outer fillet top web
        self.r21 = r2 / sqrt2
        self.ex = ex  # from left
        self.ey = ey  # from bottom
        self.IfcProfileDef = "IfcTShapeProfileDef"

        # describe points
        p1 = Point2D(-ex, -ey)  # left bottom
        p2 = Point2D(b - ex, -ey)  # right bottom
        p3 = Point2D(b - ex, -ey + tf - r1)  # start arc
        p4 = Point2D(b - ex - r1 + self.r11, -ey + tf -
                     r1 + self.r11)  # second point arc
        p5 = Point2D(b - ex - r1, -ey + tf)  # end arc
        p6 = Point2D(0.5 * tw + r, -ey + tf)  # start arc
        p7 = Point2D(0.5 * tw + r - self.r01, -ey + tf +
                     r - self.r01)  # second point arc
        p8 = Point2D(0.5 * tw, -ey + tf + r)  # end arc
        p9 = Point2D(0.5 * tw, -ey + h - r2)  # start arc
        p10 = Point2D(0.5 * tw - self.r21, -ey + h -
                      r2 + self.r21)  # second point arc
        p11 = Point2D(0.5 * tw - r2, -ey + h)  # end arc

        p12 = Point2D(-p11.x, p11.y)
        p13 = Point2D(-p10.x, p10.y)
        p14 = Point2D(-p9.x, p9.y)
        p15 = Point2D(-p8.x, p8.y)
        p16 = Point2D(-p7.x, p7.y)
        p17 = Point2D(-p6.x, p6.y)
        p18 = Point2D(-p5.x, p5.y)
        p19 = Point2D(-p4.x, p4.y)
        p20 = Point2D(-p3.x, p3.y)

        # describe curves
        l1 = Line2D(p1, p2)

        l2 = Line2D(p2, p3)
        l3 = Arc2D(p3, p4, p5)
        l4 = Line2D(p5, p6)
        l5 = Arc2D(p6, p7, p8)
        l6 = Line2D(p8, p9)
        l7 = Arc2D(p9, p10, p11)
        l8 = Line2D(p11, p12)

        l9 = Arc2D(p12, p13, p14)
        l10 = Line2D(p14, p15)
        l11 = Arc2D(p15, p16, p17)
        l12 = Line2D(p17, p18)
        l13 = Arc2D(p18, p19, p20)
        l14 = Line2D(p20, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14])

    def serialize(self):
        return {
            'Description': self.Description,
            'ID': self.ID,
            'id': self.id,
            'type': self.type,
            'name': self.name,
            'b': self.b,
            'h': self.h,
            'tw': self.tw,
            'tf': self.tf,
            'r': self.r,
            'r01': self.r01,
            'r1': self.r1,
            'r11': self.r11,
            'r2': self.r2,
            'r21': self.r21,
            'ex': self.ex,
            'ey': self.ey,
            'curve': self.curve.serialize() if self.curve else None
        }

    @staticmethod
    def deserialize(data):
        t_profile = TProfile(
            name=data.get('name'),
            h=data.get('h'),
            b=data.get('b'),
            tw=data.get('tw'),
            tf=data.get('tf'),
            r=data.get('r'),
            r1=data.get('r1'),
            r2=data.get('r2'),
            ex=data.get('ex'),
            ey=data.get('ey')
        )

        t_profile.Description = data.get('Description', "TProfile")
        t_profile.ID = data.get('ID', "T")
        t_profile.id = data.get('id')
        t_profile.type = data.get('type')
        t_profile.r01 = data.get('r01')
        t_profile.r11 = data.get('r11')
        t_profile.r21 = data.get('r21')
        t_profile.curve = PolyCurve2D.deserialize(
            data['curve']) if 'curve' in data else None

        return t_profile

    def __str__(self):
        return f"{self.type} ({self.name})"


class RectangleHollowSection:
    def __init__(self, name, h, b, t, r1, r2):
        self.Description = "Rectangle Hollow Section"
        self.ID = "RHS"

        # parameters
        self.id = generateID()
        self.type = __class__.__name__
        self.name = name
        self.curve = []
        self.h = h  # height
        self.b = b  # width
        self.t = t  # thickness
        self.r1 = r1  # outer radius
        self.r2 = r2  # inner radius
        dr = r1 - r1 / sqrt2
        dri = r2 - r2 / sqrt2
        bi = b-t
        hi = h-t
        self.IfcProfileDef = "IfcRectangleHollowProfileDef"

        # describe points
        p1 = Point2D(-b / 2 + r1, - h / 2)  # left bottom end arc
        p2 = Point2D(b / 2 - r1, - h / 2)  # right bottom start arc
        p3 = Point2D(b / 2 - dr, - h / 2 + dr)  # right bottom mid arc
        p4 = Point2D(b / 2, - h / 2 + r1)  # right bottom end arc
        p5 = Point2D(p4.x, -p4.y)  # right start arc
        p6 = Point2D(p3.x, -p3.y)  # right mid arc
        p7 = Point2D(p2.x, -p2.y)  # right end arc
        p8 = Point2D(-p7.x, p7.y)  # left start arc
        p9 = Point2D(-p6.x, p6.y)  # left mid arc
        p10 = Point2D(-p5.x, p5.y)  # left end arc
        p11 = Point2D(p10.x, -p10.y)  # right bottom start arc
        p12 = Point2D(p9.x, -p9.y)  # right bottom mid arc

        # inner part
        p13 = Point2D(-bi / 2 + r2, - hi / 2)  # left bottom end arc
        p14 = Point2D(bi / 2 - r2, - hi / 2)  # right bottom start arc
        p15 = Point2D(bi / 2 - dri, - hi / 2 + dri)  # right bottom mid arc
        p16 = Point2D(bi / 2, - hi / 2 + r2)  # right bottom end arc
        p17 = Point2D(p16.x, -p16.y)  # right start arc
        p18 = Point2D(p15.x, -p15.y)  # right mid arc
        p19 = Point2D(p14.x, -p14.y)  # right end arc
        p20 = Point2D(-p19.x, p19.y)  # left start arc
        p21 = Point2D(-p18.x, p18.y)  # left mid arc
        p22 = Point2D(-p17.x, p17.y)  # left end arc
        p23 = Point2D(p22.x, -p22.y)  # right bottom start arc
        p24 = Point2D(p21.x, -p21.y)  # right bottom mid arc

        # describe outer curves
        l1 = Line2D(p1, p2)
        l2 = Arc2D(p2, p3, p4)
        l3 = Line2D(p4, p5)
        l4 = Arc2D(p5, p6, p7)
        l5 = Line2D(p7, p8)
        l6 = Arc2D(p8, p9, p10)
        l7 = Line2D(p10, p11)
        l8 = Arc2D(p11, p12, p1)

        l9 = Line2D(p1, p13)
        # describe inner curves
        l10 = Line2D(p13, p14)
        l11 = Arc2D(p14, p15, p16)
        l12 = Line2D(p16, p17)
        l13 = Arc2D(p17, p18, p19)
        l14 = Line2D(p19, p20)
        l15 = Arc2D(p20, p21, p22)
        l16 = Line2D(p22, p23)
        l17 = Arc2D(p23, p24, p13)

        l18 = Line2D(p13, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18])

    def serialize(self):
        return {
            'Description': self.Description,
            'ID': self.ID,
            'id': self.id,
            'type': self.type,
            'name': self.name,
            'h': self.h,
            'b': self.b,
            't': self.t,
            'r1': self.r1,
            'r2': self.r2,
            'curve': self.curve.serialize() if self.curve else None
        }

    @staticmethod
    def deserialize(data):
        rhs = RectangleHollowSection(
            name=data.get('name'),
            h=data.get('h'),
            b=data.get('b'),
            t=data.get('t'),
            r1=data.get('r1'),
            r2=data.get('r2')
        )

        rhs.Description = data.get('Description', "Rectangle Hollow Section")
        rhs.ID = data.get('ID', "RHS")
        rhs.id = data.get('id')
        rhs.type = data.get('type')
        rhs.curve = PolyCurve2D.deserialize(
            data['curve']) if 'curve' in data else None

        return rhs

    def __str__(self):
        return f"{self.type} ({self.name})"


class CProfile:
    def __init__(self, name, b, h, t, r1, ex):
        self.Description = "Cold Formed C Profile"
        self.ID = "CP"

        # parameters
        self.id = generateID()
        self.type = __class__.__name__
        self.name = name
        self.curve = []
        self.h = h  # height
        self.b = b  # width
        self.t = t  # flange thickness
        self.r1 = r1  # outer radius
        self.r2 = r1-t  # inner radius
        r2 = r1-t

        self.ex = ex
        self.ey = h/2
        dr = r1 - r1/sqrt2
        dri = r2 - r2/sqrt2
        hi = h-t
        self.IfcProfileDef = "Unknown"

        # describe points
        p1 = Point2D(b-ex, -h/2)  # right bottom
        p2 = Point2D(r1-ex, -h/2)
        p3 = Point2D(dr-ex, -h/2+dr)
        p4 = Point2D(0-ex, -h/2+r1)
        p5 = Point2D(p4.x, -p4.y)
        p6 = Point2D(p3.x, -p3.y)
        p7 = Point2D(p2.x, -p2.y)
        p8 = Point2D(p1.x, -p1.y)  # right top
        p9 = Point2D(b-ex, hi/2)  # right top inner
        p10 = Point2D(t+r2-ex, hi/2)
        p11 = Point2D(t+dri-ex, hi/2-dri)
        p12 = Point2D(t-ex, hi/2-r2)
        p13 = Point2D(p12.x, -p12.y)
        p14 = Point2D(p11.x, -p11.y)
        p15 = Point2D(p10.x, -p10.y)
        p16 = Point2D(p9.x, -p9.y)  # right bottom inner
        # describe outer curves
        l1 = Line2D(p1, p2)  # bottom
        l2 = Arc2D(p2, p3, p4)  # right outer fillet
        l3 = Line2D(p4, p5)  # left outer web
        l4 = Arc2D(p5, p6, p7)  # left top outer fillet
        l5 = Line2D(p7, p8)  # outer top
        l6 = Line2D(p8, p9)
        l7 = Line2D(p9, p10)
        l8 = Arc2D(p10, p11, p12)  # left top inner fillet
        l9 = Line2D(p12, p13)
        l10 = Arc2D(p13, p14, p15)  # left botom inner fillet
        l11 = Line2D(p15, p16)
        l12 = Line2D(p16, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12])

    def serialize(self):
        return {
            'Description': self.Description,
            'ID': self.ID,
            'id': self.id,
            'type': self.type,
            'name': self.name,
            'h': self.h,
            'b': self.b,
            't': self.t,
            'r1': self.r1,
            'r2': self.r2,
            'ex': self.ex,
            'ey': self.ey,
            'curve': self.curve.serialize() if self.curve else None
        }

    @staticmethod
    def deserialize(data):
        c_profile = CProfile(
            name=data.get('name'),
            b=data.get('b'),
            h=data.get('h'),
            t=data.get('t'),
            r1=data.get('r1'),
            ex=data.get('ex')
        )

        c_profile.Description = data.get(
            'Description', "Cold Formed C Profile")
        c_profile.ID = data.get('ID', "CP")
        c_profile.id = data.get('id')
        c_profile.type = data.get('type')
        c_profile.r2 = data.get('r2')
        c_profile.ey = data.get('ey')
        c_profile.curve = PolyCurve2D.deserialize(
            data['curve']) if 'curve' in data else None

        return c_profile

    def __str__(self):
        return f"{self.type} ({self.name})"


class CProfileWithLips:
    def __init__(self, name, b, h, h1, t, r1, ex):
        self.Description = "Cold Formed C Profile with Lips"
        self.ID = "CPWL"

        # parameters
        self.id = generateID()
        self.type = __class__.__name__
        self.name = name
        self.curve = []
        self.h = h  # height
        self.b = b  # width
        self.h1 = h1  # lip length
        self.t = t  # flange thickness
        self.r1 = r1  # outer radius
        self.r2 = r1-t  # inner radius
        r2 = r1-t

        self.ex = ex
        self.ey = h/2
        dr = r1 - r1/sqrt2
        dri = r2 - r2/sqrt2
        hi = h-t
        self.IfcProfileDef = "Unknown"

        # describe points
        p1 = Point2D(b-ex-r1, -h/2)  # right bottom  before fillet
        p2 = Point2D(r1-ex, -h/2)
        p3 = Point2D(dr-ex, -h/2+dr)
        p4 = Point2D(0-ex, -h/2+r1)
        p5 = Point2D(p4.x, -p4.y)
        p6 = Point2D(p3.x, -p3.y)
        p7 = Point2D(p2.x, -p2.y)
        p8 = Point2D(p1.x, -p1.y)  # right top before fillet
        p9 = Point2D(b-ex-dr, h/2-dr)  # middle point arc
        p10 = Point2D(b-ex, h/2-r1)  # end fillet
        p11 = Point2D(b-ex, h/2-h1)
        p12 = Point2D(b-ex-t, h/2-h1)  # bottom lip
        p13 = Point2D(b-ex-t, h/2-t-r2)  # start inner fillet right top
        p14 = Point2D(b-ex-t-dri, h/2-t-dri)
        p15 = Point2D(b-ex-t-r2, h/2-t)  # end inner fillet right top
        p16 = Point2D(0-ex+t+r2, h/2-t)
        p17 = Point2D(0-ex+t+dri, h/2-t-dri)
        p18 = Point2D(0-ex+t, h/2-t-r2)

        p19 = Point2D(p18.x, -p18.y)
        p20 = Point2D(p17.x, -p17.y)
        p21 = Point2D(p16.x, -p16.y)
        p22 = Point2D(p15.x, -p15.y)
        p23 = Point2D(p14.x, -p14.y)
        p24 = Point2D(p13.x, -p13.y)
        p25 = Point2D(p12.x, -p12.y)
        p26 = Point2D(p11.x, -p11.y)
        p27 = Point2D(p10.x, -p10.y)
        p28 = Point2D(p9.x, -p9.y)

        # describe outer curves
        l1 = Line2D(p1, p2)
        l2 = Arc2D(p2, p3, p4)
        l3 = Line2D(p4, p5)
        l4 = Arc2D(p5, p6, p7)  # outer fillet right top
        l5 = Line2D(p7, p8)
        l6 = Arc2D(p8, p9, p10)
        l7 = Line2D(p10, p11)
        l8 = Line2D(p11, p12)
        l9 = Line2D(p12, p13)
        l10 = Arc2D(p13, p14, p15)
        l11 = Line2D(p15, p16)
        l12 = Arc2D(p16, p17, p18)
        l13 = Line2D(p18, p19)  # inner web
        l14 = Arc2D(p19, p20, p21)
        l15 = Line2D(p21, p22)
        l16 = Arc2D(p22, p23, p24)
        l17 = Line2D(p24, p25)
        l18 = Line2D(p25, p26)
        l19 = Line2D(p26, p27)
        l20 = Arc2D(p27, p28, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20])

    def serialize(self):
        return {
            'Description': self.Description,
            'ID': self.ID,
            'id': self.id,
            'type': self.type,
            'name': self.name,
            'h': self.h,
            'b': self.b,
            'h1': self.h1,
            't': self.t,
            'r1': self.r1,
            'r2': self.r2,
            'ex': self.ex,
            'ey': self.ey,
            'curve': self.curve.serialize() if self.curve else None
        }

    @staticmethod
    def deserialize(data):
        c_profile_with_lips = CProfileWithLips(
            name=data.get('name'),
            b=data.get('b'),
            h=data.get('h'),
            h1=data.get('h1'),
            t=data.get('t'),
            r1=data.get('r1'),
            ex=data.get('ex')
        )

        c_profile_with_lips.Description = data.get(
            'Description', "Cold Formed C Profile with Lips")
        c_profile_with_lips.ID = data.get('ID', "CPWL")
        c_profile_with_lips.id = data.get('id')
        c_profile_with_lips.type = data.get('type')
        c_profile_with_lips.r2 = data.get('r2')
        c_profile_with_lips.ey = data.get('ey')
        c_profile_with_lips.curve = PolyCurve2D.deserialize(
            data['curve']) if 'curve' in data else None

        return c_profile_with_lips

    def __str__(self):
        return "Profile(" + f"{self.name})"


class LProfileColdFormed:
    def __init__(self, name, b, h, t, r1, ex, ey):
        self.Description = "Cold Formed L Profile"
        self.ID = "CF_L"

        # parameters
        self.id = generateID()
        self.type = __class__.__name__
        self.name = name
        self.curve = []
        self.h = h  # height
        self.b = b  # width
        self.t = t  # flange thickness
        self.r1 = r1  # inner radius
        self.r2 = r1-t  # outer radius
        self.ex = ex
        self.ey = ey
        r11 = r1/math.sqrt(2)
        r2 = r1+t
        r21 = r2/math.sqrt(2)
        self.IfcProfileDef = "Unknown"

        # describe points
        p1 = Point2D(-ex, -ey + r2)  # start arc left bottom
        p2 = Point2D(-ex + r2 - r21, -ey + r2 - r21)  # second point arc
        p3 = Point2D(-ex + r2, -ey)  # end arc
        p4 = Point2D(b - ex, -ey)  # right bottom
        p5 = Point2D(b - ex, -ey + t)
        p6 = Point2D(-ex + t + r1, -ey + t)  # start arc
        p7 = Point2D(-ex + t + r1 - r11, -ey + t +
                     r1 - r11)  # second point arc
        p8 = Point2D(-ex + t, -ey + t + r1)  # end arc
        p9 = Point2D(-ex + t, ey)
        p10 = Point2D(-ex, ey)  # left top

        l1 = Arc2D(p1, p2, p3)
        l2 = Line2D(p3, p4)
        l3 = Line2D(p4, p5)
        l4 = Line2D(p5, p6)
        l5 = Arc2D(p6, p7, p8)
        l6 = Line2D(p8, p9)
        l7 = Line2D(p9, p10)
        l8 = Line2D(p10, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8])

    def serialize(self):
        return {
            'Description': self.Description,
            'ID': self.ID,
            'id': self.id,
            'type': self.type,
            'name': self.name,
            'h': self.h,
            'b': self.b,
            't': self.t,
            'r1': self.r1,
            'r2': self.r2,
            'ex': self.ex,
            'ey': self.ey,
            'curve': self.curve.serialize() if self.curve else None
        }

    @staticmethod
    def deserialize(data):
        l_profile_cold_formed = LProfileColdFormed(
            name=data.get('name'),
            b=data.get('b'),
            h=data.get('h'),
            t=data.get('t'),
            r1=data.get('r1'),
            ex=data.get('ex'),
            ey=data.get('ey')
        )

        l_profile_cold_formed.Description = data.get(
            'Description', "Cold Formed L Profile")
        l_profile_cold_formed.ID = data.get('ID', "CF_L")
        l_profile_cold_formed.id = data.get('id')
        l_profile_cold_formed.type = data.get('type')
        l_profile_cold_formed.r2 = data.get('r2')
        l_profile_cold_formed.curve = PolyCurve2D.deserialize(
            data['curve']) if 'curve' in data else None

        return l_profile_cold_formed

    def __str__(self):
        return f"{self.type} ({self.name})"


class SigmaProfileWithLipsColdFormed:
    def __init__(self, name, b, h, t, r1, h1, h2, h3, b2, ex):
        self.Description = "Cold Formed Sigma Profile with Lips"
        self.ID = "CF_SWL"

        # parameters
        self.id = generateID()
        self.type = __class__.__name__
        self.name = name
        self.curve = []
        self.h = h  # height
        self.h1 = h1  # LipLength
        self.h2 = h2  # MiddleBendLength
        self.h3 = h3  # TopBendLength
        self.h4 = h4 = (h - h2 - h3 * 2) / 2
        self.h5 = h5 = math.tan(0.5 * math.atan(b2 / h4)) * t
        self.b = b  # width
        self.b2 = b2  # MiddleBendWidth
        self.t = t  # flange thickness
        self.r1 = r1  # inner radius
        self.r2 = r2 = r1+t  # outer radius
        self.ex = ex
        self.ey = ey = h/2
        self.r11 = r11 = r1/math.sqrt(2)
        self.r21 = r21 = r2/math.sqrt(2)
        self.IfcProfileDef = "Unknown"

        p1 = Point2D(-ex + b2, -h2 / 2)
        p2 = Point2D(-ex, -ey + h3)
        p3 = Point2D(-ex, -ey + r2)  # start arc left bottom
        p4 = Point2D(-ex + r2 - r21, -ey + r2 - r21)  # second point arc
        p5 = Point2D(-ex + r2, -ey)  # end arc
        p6 = Point2D(b - ex - r2, -ey)  # start arc
        p7 = Point2D(b - ex - r2 + r21, -ey + r2 - r21)  # second point arc
        p8 = Point2D(b - ex, -ey + r2)  # end arc
        p9 = Point2D(b - ex, -ey + h1)  # end lip
        p10 = Point2D(b - ex - t, -ey + h1)
        p11 = Point2D(b - ex - t, -ey + t + r1)  # start arc
        p12 = Point2D(b - ex - t - r1 + r11, -ey +
                      t + r1 - r11)  # second point arc
        p13 = Point2D(b - ex - t - r1, -ey + t)  # end arc
        p14 = Point2D(-ex + t + r1, -ey + t)  # start arc
        p15 = Point2D(-ex + t + r1 - r11, -ey + t +
                      r1 - r11)  # second point arc
        p16 = Point2D(-ex + t, -ey + t + r1)  # end arc
        p17 = Point2D(-ex + t, -ey + h3 - h5)
        p18 = Point2D(-ex + b2 + t, -h2 / 2 - h5)
        p19 = Point2D(p18.x, -p18.y)
        p20 = Point2D(p17.x, -p17.y)
        p21 = Point2D(p16.x, -p16.y)
        p22 = Point2D(p15.x, -p15.y)
        p23 = Point2D(p14.x, -p14.y)
        p24 = Point2D(p13.x, -p13.y)
        p25 = Point2D(p12.x, -p12.y)
        p26 = Point2D(p11.x, -p11.y)
        p27 = Point2D(p10.x, -p10.y)
        p28 = Point2D(p9.x, -p9.y)
        p29 = Point2D(p8.x, -p8.y)
        p30 = Point2D(p7.x, -p7.y)
        p31 = Point2D(p6.x, -p6.y)
        p32 = Point2D(p5.x, -p5.y)
        p33 = Point2D(p4.x, -p4.y)
        p34 = Point2D(p3.x, -p3.y)
        p35 = Point2D(p2.x, -p2.y)
        p36 = Point2D(p1.x, -p1.y)

        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Arc2D(p3, p4, p5)
        l4 = Line2D(p5, p6)
        l5 = Arc2D(p6, p7, p8)
        l6 = Line2D(p8, p9)
        l7 = Line2D(p9, p10)
        l8 = Line2D(p10, p11)
        l9 = Arc2D(p11, p12, p13)
        l10 = Line2D(p13, p14)
        l11 = Arc2D(p14, p15, p16)
        l12 = Line2D(p16, p17)
        l13 = Line2D(p17, p18)
        l14 = Line2D(p18, p19)
        l15 = Line2D(p19, p20)
        l16 = Line2D(p20, p21)
        l17 = Arc2D(p21, p22, p23)
        l18 = Line2D(p23, p24)
        l19 = Arc2D(p24, p25, p26)
        l20 = Line2D(p26, p27)
        l21 = Line2D(p27, p28)
        l22 = Line2D(p28, p29)
        l23 = Arc2D(p29, p30, p31)
        l24 = Line2D(p31, p32)
        l25 = Arc2D(p32, p33, p34)
        l26 = Line2D(p34, p35)
        l27 = Line2D(p35, p36)
        l28 = Line2D(p36, p1)

        self.curve = PolyCurve2D().by_joined_curves([l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22, l23,
                                                     l24, l25,
                                                     l26, l27, l28])

    def serialize(self):
        return {
            'Description': self.Description,
            'ID': self.ID,
            'id': self.id,
            'type': self.type,
            'name': self.name,
            'h': self.h,
            'b': self.b,
            't': self.t,
            'r1': self.r1,
            'h1': self.h1,
            'h2': self.h2,
            'h3': self.h3,
            'b2': self.b2,
            'ex': self.ex,
            'ey': self.ey,
            'r2': self.r2,
            'r11': self.r11,
            'r21': self.r21,
            'h4': self.h4,
            'h5': self.h5,
            'curve': self.curve.serialize() if self.curve else None
        }

    @staticmethod
    def deserialize(data):
        sigma_profile_with_lips = SigmaProfileWithLipsColdFormed(
            name=data.get('name'),
            b=data.get('b'),
            h=data.get('h'),
            t=data.get('t'),
            r1=data.get('r1'),
            h1=data.get('h1'),
            h2=data.get('h2'),
            h3=data.get('h3'),
            b2=data.get('b2'),
            ex=data.get('ex')
        )

        sigma_profile_with_lips.Description = data.get(
            'Description', "Cold Formed Sigma Profile with Lips")
        sigma_profile_with_lips.ID = data.get('ID', "CF_SWL")
        sigma_profile_with_lips.id = data.get('id')
        sigma_profile_with_lips.type = data.get('type')
        sigma_profile_with_lips.ey = data.get('ey')
        sigma_profile_with_lips.r2 = data.get('r2')
        sigma_profile_with_lips.r11 = data.get('r11')
        sigma_profile_with_lips.r21 = data.get('r21')
        sigma_profile_with_lips.h4 = data.get('h4')
        sigma_profile_with_lips.h5 = data.get('h5')
        sigma_profile_with_lips.curve = PolyCurve2D.deserialize(
            data['curve']) if 'curve' in data else None

        return sigma_profile_with_lips

    def __str__(self):
        return f"{self.type} ({self.name})"


class ZProfileColdFormed:
    def __init__(self, name, b, h, t, r1):
        self.Description = "Cold Formed Z Profile"
        self.ID = "CF_Z"

        # parameters
        self.id = generateID()
        self.type = __class__.__name__
        self.name = name
        self.curve = []
        self.b = b  # width
        self.h = h  # height
        self.t = t  # flange thickness
        self.r1 = r1  # inner radius
        self.r2 = r2 = r1+t  # outer radius
        self.ex = ex = b/2
        self.ey = ey = h/2
        self.r11 = r11 = r1 / math.sqrt(2)
        self.r21 = r21 = r2 / math.sqrt(2)
        self.IfcProfileDef = "Unknown"

        p1 = Point2D(-0.5 * t, -ey + t + r1)  # start arc
        p2 = Point2D(-0.5 * t - r1 + r11, -ey + t +
                     r1 - r11)  # second point arc
        p3 = Point2D(-0.5 * t - r1, -ey + t)  # end arc
        p4 = Point2D(-ex, -ey + t)
        p5 = Point2D(-ex, -ey)  # left bottom
        p6 = Point2D(-r2 + 0.5 * t, -ey)  # start arc
        p7 = Point2D(-r2 + 0.5 * t + r21, -ey + r2 - r21)  # second point arc
        p8 = Point2D(0.5 * t, -ey + r2)  # end arc
        p9 = Point2D(-p1.x, -p1.y)
        p10 = Point2D(-p2.x, -p2.y)
        p11 = Point2D(-p3.x, -p3.y)
        p12 = Point2D(-p4.x, -p4.y)
        p13 = Point2D(-p5.x, -p5.y)
        p14 = Point2D(-p6.x, -p6.y)
        p15 = Point2D(-p7.x, -p7.y)
        p16 = Point2D(-p8.x, -p8.y)

        l1 = Arc2D(p1, p2, p3)
        l2 = Line2D(p3, p4)
        l3 = Line2D(p4, p5)
        l4 = Line2D(p5, p6)
        l5 = Arc2D(p6, p7, p8)
        l6 = Line2D(p8, p9)
        l7 = Arc2D(p9, p10, p11)
        l8 = Line2D(p11, p12)
        l9 = Line2D(p12, p13)
        l10 = Line2D(p13, p14)
        l11 = Arc2D(p14, p15, p16)
        l12 = Line2D(p16, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12])

    def serialize(self):
        return {
            'Description': self.Description,
            'ID': self.ID,
            'id': self.id,
            'type': self.type,
            'name': self.name,
            'b': self.b,
            'h': self.h,
            't': self.t,
            'r1': self.r1,
            'r2': self.r2,
            'ex': self.ex,
            'ey': self.ey,
            'r11': self.r11,
            'r21': self.r21,
            'curve': self.curve.serialize() if self.curve else None
        }

    @staticmethod
    def deserialize(data):
        z_profile_cold_formed = ZProfileColdFormed(
            name=data.get('name'),
            b=data.get('b'),
            h=data.get('h'),
            t=data.get('t'),
            r1=data.get('r1')
        )

        z_profile_cold_formed.Description = data.get(
            'Description', "Cold Formed Z Profile")
        z_profile_cold_formed.ID = data.get('ID', "CF_Z")
        z_profile_cold_formed.id = data.get('id')
        z_profile_cold_formed.type = data.get('type')
        z_profile_cold_formed.r2 = data.get('r2')
        z_profile_cold_formed.ex = data.get('ex')
        z_profile_cold_formed.ey = data.get('ey')
        z_profile_cold_formed.r11 = data.get('r11')
        z_profile_cold_formed.r21 = data.get('r21')
        z_profile_cold_formed.curve = PolyCurve2D.deserialize(
            data['curve']) if 'curve' in data else None

        return z_profile_cold_formed

    def __str__(self):
        return f"{self.type} ({self.name})"


class ZProfileWithLipsColdFormed:
    def __init__(self, name, b, h, t, r1, h1):
        self.Description = "Cold Formed Z Profile with Lips"
        self.ID = "CF_ZL"

        # parameters
        self.id = generateID()
        self.type = __class__.__name__
        self.name = name
        self.curve = []
        self.b = b  # width
        self.h = h  # height
        self.t = t  # flange thickness
        self.h1 = h1  # lip length
        self.r1 = r1  # inner radius
        self.r2 = r2 = r1+t  # outer radius
        self.ex = ex = b/2
        self.ey = ey = h/2
        self.r11 = r11 = r1 / math.sqrt(2)
        self.r21 = r21 = r2 / math.sqrt(2)
        self.IfcProfileDef = "Unknown"

        p1 = Point2D(-0.5*t, -ey+t+r1)  # start arc
        p2 = Point2D(-0.5*t-r1+r11, -ey+t+r1-r11)  # second point arc
        p3 = Point2D(-0.5*t-r1, -ey+t)  # end arc
        p4 = Point2D(-ex+t+r1, -ey+t)  # start arc
        p5 = Point2D(-ex+t+r1-r11, -ey+t+r1-r11)  # second point arc
        p6 = Point2D(-ex+t, -ey+t+r1)  # end arc
        p7 = Point2D(-ex+t, -ey+h1)
        p8 = Point2D(-ex, -ey+h1)
        p9 = Point2D(-ex, -ey+r2)  # start arc
        p10 = Point2D(-ex+r2-r21, -ey+r2-r21)  # second point arc
        p11 = Point2D(-ex+r2, -ey)  # end arc
        p12 = Point2D(-r2+0.5*t, -ey)  # start arc
        p13 = Point2D(-r2+0.5*t+r21, -ey+r2-r21)  # second point arc
        p14 = Point2D(0.5*t, -ey+r2)  # end arc
        p15 = Point2D(-p1.x, -p1.y)
        p16 = Point2D(-p2.x, -p2.y)
        p17 = Point2D(-p3.x, -p3.y)
        p18 = Point2D(-p4.x, -p4.y)
        p19 = Point2D(-p5.x, -p5.y)
        p20 = Point2D(-p6.x, -p6.y)
        p21 = Point2D(-p7.x, -p7.y)
        p22 = Point2D(-p8.x, -p8.y)
        p23 = Point2D(-p9.x, -p9.y)
        p24 = Point2D(-p10.x, -p10.y)
        p25 = Point2D(-p11.x, -p11.y)
        p26 = Point2D(-p12.x, -p12.y)
        p27 = Point2D(-p13.x, -p13.y)
        p28 = Point2D(-p14.x, -p14.y)

        l1 = Arc2D(p1, p2, p3)
        l2 = Line2D(p3, p4)
        l3 = Arc2D(p4, p5, p6)
        l4 = Line2D(p6, p7)
        l5 = Line2D(p7, p8)
        l6 = Line2D(p8, p9)
        l7 = Arc2D(p9, p10, p11)
        l8 = Line2D(p11, p12)
        l9 = Arc2D(p12, p13, p14)
        l10 = Line2D(p14, p15)
        l11 = Arc2D(p15, p16, p17)
        l12 = Line2D(p17, p18)
        l13 = Arc2D(p18, p19, p20)
        l14 = Line2D(p20, p21)
        l15 = Line2D(p21, p22)
        l16 = Line2D(p22, p23)
        l17 = Arc2D(p23, p24, p25)
        l18 = Line2D(p25, p26)
        l19 = Arc2D(p26, p27, p28)
        l20 = Line2D(p28, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20])

    def serialize(self):
        return {
            'Description': self.Description,
            'ID': self.ID,
            'id': self.id,
            'type': self.type,
            'name': self.name,
            'b': self.b,
            'h': self.h,
            't': self.t,
            'h1': self.h1,
            'r1': self.r1,
            'r2': self.r2,
            'ex': self.ex,
            'ey': self.ey,
            'r11': self.r11,
            'r21': self.r21,
            'curve': self.curve.serialize() if self.curve else None
        }

    @staticmethod
    def deserialize(data):
        z_profile_with_lips = ZProfileWithLipsColdFormed(
            name=data.get('name'),
            b=data.get('b'),
            h=data.get('h'),
            t=data.get('t'),
            r1=data.get('r1'),
            h1=data.get('h1')
        )

        z_profile_with_lips.Description = data.get(
            'Description', "Cold Formed Z Profile with Lips")
        z_profile_with_lips.ID = data.get('ID', "CF_ZL")
        z_profile_with_lips.id = data.get('id')
        z_profile_with_lips.type = data.get('type')
        z_profile_with_lips.r2 = data.get('r2')
        z_profile_with_lips.ex = data.get('ex')
        z_profile_with_lips.ey = data.get('ey')
        z_profile_with_lips.r11 = data.get('r11')
        z_profile_with_lips.r21 = data.get('r21')
        z_profile_with_lips.curve = PolyCurve2D.deserialize(
            data['curve']) if 'curve' in data else None

        return z_profile_with_lips

    def __str__(self):
        return f"{self.type} ({self.name})"




class ReadDXF():
    # append line only if unique start.value and end.value
    # sort them based on end.value has to be start.value
    def __init__(self, filename):
        self.points = []
        self.lines = []
        self.filename = filename
        self.get_line_coordinates()
        self.polycurve = self.create_polycurve()
        self.isClosed = project.closed

    def convert_coordinates(self, start_point, end_point, reference_point):

        # relative_start = start_point - reference_point
        # print(start_point, end_point, reference_point)
        relative_start = start_point[0] - reference_point[0], start_point[1] - \
            reference_point[1], start_point[2] - reference_point[2]
        # print(relative_start)
        # print(end_point, reference_point)
        relative_end = end_point[0] - reference_point[0], end_point[1] - \
            reference_point[1], end_point[2] - reference_point[2]
        # relative_end = end_point - reference_point
        # print(relative_end)
        relative_start = round(relative_start[0], project.decimals), round(
            relative_start[1], project.decimals), round(relative_start[2], project.decimals)
        relative_end = round(relative_end[0], project.decimals), round(
            relative_end[1], project.decimals), round(relative_end[2], project.decimals)
        return relative_start, relative_end

    def get_line_coordinates(self):
        doc = ezdxf.readfile(self.filename)
        modelspace = doc.modelspace()
        reference_point = None
        for entity in modelspace:
            if entity.dxftype() == 'LINE':
                start_point = entity.dxf.start
                end_point = entity.dxf.end
                if reference_point is None:
                    reference_point = start_point
                relative_start, relative_end = self.convert_coordinates(
                    start_point, end_point, reference_point)
                p1 = Point(
                    x=relative_start[0], y=relative_start[1], z=relative_start[2])
                p2 = Point(x=relative_end[0],
                           y=relative_end[1], z=relative_end[2])
                line = Line(start=p1, end=p2)
                self.points.append(p1)
                self.lines.append(line)

            elif entity.dxftype() == 'LWPOLYLINE':
                splittedpoints = []
                splittedlines = []
                with entity.points() as points:
                    endpoint = None
                    for point in points:
                        if reference_point is None:
                            reference_point = point
                        if endpoint is None:
                            endpoint = point
                        point = point[0], point[1], point[2]
                        endpoint = endpoint[0], endpoint[1], endpoint[2]
                        reference_point = reference_point[0], reference_point[1], reference_point[2]
                        relative_start, relative_end = self.convert_coordinates(
                            point, endpoint, reference_point)
                        p1 = Point(
                            x=relative_start[0], y=relative_start[1], z=relative_start[2])
                        p2 = Point(
                            x=relative_end[0], y=relative_end[1], z=relative_end[2])
                        line = Line(start=p1, end=p2)
                        splittedpoints.append(p1)
                        splittedlines.append(line)
                    self.points.append(splittedpoints)
                    self.lines.append(splittedlines)
        # print(self.lines)
        return self.lines

    def create_polycurve(self):
        if len(self.points) == 1:
            return PolyCurve.by_points(self.points)
        elif len(self.points) > 1:
            plList = []
            for pl in self.points:
                plList.append(PolyCurve.by_points(pl))
            return plList



Patprefix = ';%UNITS=MM' \
         ';' \

Revitmodelpattern = ";%TYPE=MODEL"

class PATRow:
    def __init__(self,):
        self.angle = 0
        self.x_orig = 0
        self.y_orig = 0
        self.shift_pattern = 0
        self.offset_spacing = 0
        self.dash = 0
        self.space = 0
        self.patstr = ""

    def createpatstr(self):
        patstr = str(self.angle) + ",  " + str(self.x_orig) + ",  " + str(self.y_orig) + ",  " + str(self.shift_pattern) + ",  " + str(
            self.offset_spacing)
        if self.dash == 0:
            addstr = ""
        else:
            addstr = ",  " + str(self.dash) + ",  " + str(self.space)
        patstr = patstr + addstr
        return patstr

    def create(self,angle: float, x_orig: float, y_orig: float, shift_pattern: float, offset_spacing: float, dash: float=0, space: float=0):
        # if dash and space are 0 then no pattern
        # rules: ;;;angle, x-origin, y-origin, shift_pattern, offset(spacing), pen_down, pen_up (negatief waarde)
        # x, y-origin is global,
        self.angle = angle
        self.x_orig = x_orig
        self.y_orig = y_orig
        self.shift_pattern = shift_pattern
        self.offset_spacing = offset_spacing
        self.dash = dash
        self.space = space
        self.patstr = self.createpatstr()
        return self

class PAT:
    def __init__(self,):
        self.patrows = []
        self.patstrings = []
        self.name = "None"
        self.patterntype = "None"

    def TilePattern(self, name: str, width: float, height: float, patterntype: str):
        #this is rectangle tile pattern
        self.name = name
        self.patterntype = patterntype
        row1 = PATRow().create(0,0,0,0,height,0,0)
        row2 = PATRow().create(90,0,0,0,width,0,0)
        self.patrows.append(row1)
        self.patrows.append(row2)

        self.patstrings.append("*" + name)
        self.patstrings.append(patterntype)
        self.patstrings.append(row1.patstr)
        self.patstrings.append(row2.patstr)
        self.patstrings.append(";")
        return self

    def BlockPattern(self, name: str, grosswidthheight: float, numbersublines: int, patterntype: str):
        #this is a block pattern
        subspacing = grosswidthheight / numbersublines
        self.name = name
        self.patterntype = patterntype
        row1 = PATRow().create(0,0,0,0,grosswidthheight,0,0)
        row2 = PATRow().create(90,0,0,0,grosswidthheight,0,0)

        self.patrows.append(row1)
        self.patrows.append(row2)

        self.patstrings.append("*" + name)
        self.patstrings.append(patterntype)
        self.patstrings.append(row1.patstr)
        self.patstrings.append(row2.patstr)
        n = 0
        for i in range(numbersublines):
            row3 = PATRow().create(0, 0, subspacing * n + grosswidthheight, 0, grosswidthheight*2, grosswidthheight, -grosswidthheight)
            row4 = PATRow().create(0, grosswidthheight, subspacing * n, 0, grosswidthheight*2, grosswidthheight, -grosswidthheight)
            row5 = PATRow().create(90, subspacing * n, 0, 0, grosswidthheight*2, grosswidthheight,-grosswidthheight)
            row6 = PATRow().create(90, subspacing * n + grosswidthheight, grosswidthheight, 0, grosswidthheight*2, grosswidthheight,-grosswidthheight)
            self.patrows.append(row3)
            self.patrows.append(row4)
            self.patrows.append(row5)
            self.patrows.append(row6)
            self.patstrings.append(row3.patstr)
            self.patstrings.append(row4.patstr)
            self.patstrings.append(row5.patstr)
            self.patstrings.append(row6.patstr)
            n = n + 1
        self.patstrings.append(";")
        return self

    def CombiPattern(self, name: str, grosswidthheight: float, patterntype: str):
        #this is a combined pattern
        width = (2 / 3) * grosswidthheight
        t = grosswidthheight / 6
        self.name = name
        self.patterntype = patterntype

        row1 = PATRow().create(0, 0, 0, 0, grosswidthheight, width, (-2 * t))
        row2 = PATRow().create(0, 0, t, 0, grosswidthheight, width, (-2 * t))
        row3 = PATRow().create(0, 0, 2 * t, 0, grosswidthheight, width, (-2 * t))
        row4 = PATRow().create(0, 2 * t, width, 0, grosswidthheight, width, (-2 * t))
        row5 = PATRow().create(0, 2 * t, width + t, 0, grosswidthheight, width, (-2 * t))
        row6 = PATRow().create(0, 2 * t, width + 2 * t, 0, grosswidthheight, width, (-2 * t))
        row7 = PATRow().create(90, 0, 2 * t, 0, grosswidthheight, width, (-2 * t))
        row8 = PATRow().create(90, t, 2 * t, 0, grosswidthheight, width, (-2 * t))
        row9 = PATRow().create(90, 2 * t, 2 * t, 0, grosswidthheight, width, (-2 * t))
        row10 = PATRow().create(90, width, 0, 0, grosswidthheight, width, (-2 * t))
        row11 = PATRow().create(90, width + t, 0, 0, grosswidthheight, width, (-2 * t))
        row12 = PATRow().create(90, width + 2 * t, 0, 0, grosswidthheight, width, (-2 * t))

        self.patrows.append(row1)
        self.patrows.append(row2)
        self.patrows.append(row3)
        self.patrows.append(row4)
        self.patrows.append(row5)
        self.patrows.append(row6)
        self.patrows.append(row7)
        self.patrows.append(row8)
        self.patrows.append(row9)
        self.patrows.append(row10)
        self.patrows.append(row11)
        self.patrows.append(row12)

        self.patstrings.append("*" + name)
        self.patstrings.append(patterntype)
        self.patstrings.append(row1.patstr)
        self.patstrings.append(row2.patstr)
        self.patstrings.append(row3.patstr)
        self.patstrings.append(row4.patstr)
        self.patstrings.append(row5.patstr)
        self.patstrings.append(row6.patstr)
        self.patstrings.append(row7.patstr)
        self.patstrings.append(row8.patstr)
        self.patstrings.append(row9.patstr)
        self.patstrings.append(row10.patstr)
        self.patstrings.append(row11.patstr)
        self.patstrings.append(row12.patstr)
        self.patstrings.append(";")
        return self

    def ChevronPattern(self, name: str, grosswidth: float, widthtile: float, patterntype: str):
        #this is a chevronpattern(hungarian)
        lengthline = math.sqrt(2) * grosswidth
        self.name = name
        self.patterntype = patterntype

        row1 = PATRow().create(90, 0, 0, 0, grosswidth, 0, 0)
        row2 = PATRow().create(45, 0, 0, widthtile, widthtile, lengthline, -lengthline)
        row3 = PATRow().create(-45, -grosswidth, 0, -widthtile, widthtile, lengthline, -lengthline)

        self.patrows.append(row1)
        self.patrows.append(row2)
        self.patrows.append(row3)

        self.patstrings.append("*" + name)
        self.patstrings.append(patterntype)
        self.patstrings.append(row1.patstr)
        self.patstrings.append(row2.patstr)
        self.patstrings.append(row3.patstr)
        self.patstrings.append(";")
        return self

    def HerringbonePattern(self, name: str, lengthtile: float, numberOfTilesInLength: float, patterntype: str):
        # this is a herringbone pattern(visgraat)
        width = lengthtile / numberOfTilesInLength
        self.name = name
        self.patterntype = patterntype

        row1 = PATRow().create(45, 0, 0, width, width, lengthtile + width, -(lengthtile - width))
        row2 = PATRow().create(135, 0, 0, -width, width, lengthtile, -lengthtile)
        row3 = PATRow().create(-45, 0, 0, -width, width, width, -(2 * lengthtile - width))

        self.patrows.append(row1)
        self.patrows.append(row2)
        self.patrows.append(row3)

        self.patstrings.append("*" + name)
        self.patstrings.append(patterntype)
        self.patstrings.append(row1.patstr)
        self.patstrings.append(row2.patstr)
        self.patstrings.append(row3.patstr)
        self.patstrings.append(";")
        return self

    def Strips(self, name: str, spacing: float, angle: float, patterntype: str):
        # these are continues lines with a certain spacing and angle
        self.name = name
        self.patterntype = patterntype

        row1 = PATRow().create(angle, 0, 0, 0, spacing, 0, 0)

        self.patrows.append(row1)

        self.patstrings.append("*" + name)
        self.patstrings.append(patterntype)
        self.patstrings.append(row1.patstr)
        self.patstrings.append(";")
        return self

    def StretcherBondPattern(self, name: str, width: float, height: float, shift: float, patterntype: str):
        # this is a brick pattern rectangle with a shift
        self.name = name
        self.patterntype = patterntype

        row1 = PATRow().create(0, 0, 0, 0, height, 0, 0)
        row2 = PATRow().create(90, 0, 0, 0, width, height, -height)
        row3 = PATRow().create(90, shift, height, 0, width, height, -height)

        self.patrows.append(row1)
        self.patrows.append(row2)
        self.patrows.append(row3)

        self.patstrings.append("*" + name)
        self.patstrings.append(patterntype)
        self.patstrings.append(row1.patstr)
        self.patstrings.append(row2.patstr)
        self.patstrings.append(row3.patstr)
        self.patstrings.append(";")
        return self

    def ParallelLines(self, name: str, widths: list, patterntype: str):
        # this pattern consists of parallel lines with different offset distances. Can be defined in a list.
        self.name = name
        self.patterntype = patterntype
        self.patstrings.append("*" + name)
        self.patstrings.append(patterntype)
        width = sum(widths)
        x = 0
        for i in widths:
            row = PATRow().create(90,x,0,0,width,0,0)
            self.patrows.append(row)
            self.patstrings.append(row.patstr)
            x = x + i

        self.patstrings.append(";")
        return self

    def stretcher_bond_with_joint(self, name:str, bricklength: float, brickheight: float, jointwidth: float, jointheight: float, patterntype: str):
        #This is stretcherbond(halfsteensverband) with joints
        self.name = name
        self.patterntype = patterntype
        lagenmaat = brickheight + jointheight

        row1 = PATRow().create(0,0,0,0,lagenmaat*2, bricklength, -jointwidth)
        row2 = PATRow().create(0,0,brickheight,0,lagenmaat*2,bricklength, -jointwidth)
        row3 = PATRow().create(0,0.5*(bricklength + jointwidth),lagenmaat,0,lagenmaat*2, bricklength, -jointwidth)
        row4 = PATRow().create(0,0.5*(bricklength + jointwidth),lagenmaat+brickheight,0,lagenmaat*2, bricklength, -jointwidth)

        row5 = PATRow().create(90,0,0,0,bricklength+jointwidth,brickheight,-(brickheight+2*jointheight))
        row6 = PATRow().create(90,bricklength,0,0,bricklength+jointwidth,brickheight,-(brickheight+2*jointheight))
        row7 = PATRow().create(90,(bricklength+jointwidth)/2,lagenmaat,0,bricklength+jointwidth,brickheight,-(brickheight+2*jointheight))
        row8 = PATRow().create(90,(bricklength+jointwidth)/2+bricklength,lagenmaat,0,bricklength+jointwidth,brickheight,-(brickheight+2*jointheight))

        self.patrows.append(row1)
        self.patrows.append(row2)
        self.patrows.append(row3)
        self.patrows.append(row4)
        self.patrows.append(row5)
        self.patrows.append(row6)
        self.patrows.append(row7)
        self.patrows.append(row8)

        self.patstrings.append("*" + name)
        self.patstrings.append(patterntype)
        self.patstrings.append(row1.patstr)
        self.patstrings.append(row2.patstr)
        self.patstrings.append(row3.patstr)
        self.patstrings.append(row4.patstr)
        self.patstrings.append(row5.patstr)
        self.patstrings.append(row6.patstr)
        self.patstrings.append(row7.patstr)
        self.patstrings.append(row8.patstr)
        self.patstrings.append(";")
        return self

    def TilePatternWithJoint(self, name: str, width: float, height: float, jointwidth: float, jointheight: float, patterntype: str):
        #this is rectangle tile pattern with joints between tiles
        self.name = name
        self.patterntype = patterntype
        row1 = PATRow().create(0, 0, 0, 0, height+jointheight, width, -jointwidth)
        row2 = PATRow().create(0, 0, height, 0, height + jointheight, width, -jointwidth)
        row3 = PATRow().create(90,0,0,0,width+jointwidth,height,-jointheight)
        row4 = PATRow().create(90,width,0,0,width+jointwidth,height,-jointheight)

        self.patrows.append(row1)
        self.patrows.append(row2)
        self.patrows.append(row3)
        self.patrows.append(row4)

        self.patstrings.append("*" + name)
        self.patstrings.append(patterntype)
        self.patstrings.append(row1.patstr)
        self.patstrings.append(row2.patstr)
        self.patstrings.append(row3.patstr)
        self.patstrings.append(row4.patstr)
        self.patstrings.append(";")
        return self

    def cross_bond_with_joint(self, name:str, brickwidth: float, bricklength: float, brickheight: float, jointwidth: float, jointheight: float, patterntype: str):
        #This is crossbond(kruisverband) with joints
        self.name = name
        self.patterntype = patterntype
        lagenmaat = brickheight + jointheight

        row1 = PATRow().create(0,0,0,0,lagenmaat*4, bricklength, -jointwidth)
        row2 = PATRow().create(0,0,brickheight,0,lagenmaat*4,bricklength, -jointwidth)

        row3 = PATRow().create(0,0.5*(brickwidth + jointwidth),lagenmaat,0,lagenmaat*2, brickwidth, -jointwidth)
        row4 = PATRow().create(0,0.5*(brickwidth + jointwidth),lagenmaat + brickheight,0,lagenmaat*2, brickwidth, -jointwidth)

        row5 = PATRow().create(0,0.5*(bricklength + jointwidth),lagenmaat*2,0,lagenmaat*4, bricklength, -jointwidth)
        row6 = PATRow().create(0,0.5*(bricklength + jointwidth),lagenmaat*4+brickheight,0,lagenmaat*2, bricklength, -jointwidth)

        row7 = PATRow().create(90,0,0,0,bricklength+jointwidth,brickheight,-(3*lagenmaat+jointheight))
        row8 = PATRow().create(90,bricklength,0,0,bricklength+jointwidth,brickheight,-(3*lagenmaat+jointheight))
        row9 = PATRow().create(90,0.5*(brickwidth + jointwidth),lagenmaat,0,brickwidth+jointwidth,brickheight,-(brickheight+2*jointheight))
        row10 = PATRow().create(90,0.5*(brickwidth + jointwidth)+brickwidth,lagenmaat,0,brickwidth+jointwidth,brickheight,-(brickheight+2*jointheight))

        row11 = PATRow().create(90,(bricklength+jointwidth)/2,lagenmaat*2,0,bricklength+jointwidth,brickheight,-(3*lagenmaat+jointheight))
        row12 = PATRow().create(90,(bricklength+jointwidth)/2+bricklength,lagenmaat*2,0,bricklength+jointwidth,brickheight,-(3*lagenmaat+jointheight))

        self.patrows.append(row1)
        self.patrows.append(row2)
        self.patrows.append(row3)
        self.patrows.append(row4)
        self.patrows.append(row5)
        self.patrows.append(row6)
        self.patrows.append(row7)
        self.patrows.append(row8)
        self.patrows.append(row9)
        self.patrows.append(row10)
        self.patrows.append(row11)
        self.patrows.append(row12)

        self.patstrings.append("*" + name)
        self.patstrings.append(patterntype)
        self.patstrings.append(row1.patstr)
        self.patstrings.append(row2.patstr)
        self.patstrings.append(row3.patstr)
        self.patstrings.append(row4.patstr)
        self.patstrings.append(row5.patstr)
        self.patstrings.append(row6.patstr)
        self.patstrings.append(row7.patstr)
        self.patstrings.append(row8.patstr)
        self.patstrings.append(row9.patstr)
        self.patstrings.append(row10.patstr)
        self.patstrings.append(row11.patstr)
        self.patstrings.append(row12.patstr)
        self.patstrings.append(";")
        return self

def CreatePatFile(patternobjects: list, filepath: str):
    #Write Pattern File
    patternstrings = []
    for i in patternobjects:
        patternstrings = patternstrings + i.patstrings

    patternstrings.insert(0, Patprefix)

    patn = []
    for i in patternstrings:
        patn.append(i + "\n")
    # Create PAT-file
    fp = open(filepath, 'w')
    for i in patn:
        fp.write(i)
    fp.close()
    return filepath

def PatRowGeom(patrow: PATRow, width: float, height: float, dx, dy):
    # tested for 0-90 degrees
    #Create BuildingPy Lines from PAT-objects
    nlines = int(height / patrow.offset_spacing)+1
    lines = []
    n = 0
    for i in range(nlines):
        Xn = Vector3.rotate_XY(XAxis, math.radians(patrow.angle))
        Yn = Vector3.rotate_XY(YAxis, math.radians(patrow.angle))
        CSNewLn = CoordinateSystem(Point(0, 0, 0), Xn, Yn, ZAxis)
        x_start = 0
        y_start = 0
        x_end = width
        y_end = 0
        l1 = Line(Point(x_start, y_start, 0), Point(x_end, y_end, 0)) # baseline
        l2 = Line.transform(l1, CSNewLn) # rotation
        v1 = Vector3.by_two_points(l2.start,l2.end)
        v1 = Vector3.normalize(v1)
        v2 = Vector3.scale(v1, patrow.shift_pattern * n)
        l3 = Line.translate_2(l2, v2)  # shift of line for pattern
        #if patrow.shift_pattern == 0:
        #    l3 = l2
        #else:
        #    v2 = Vector3.scale(v1, patrow.shift_pattern*(n+1))
        #    l3 = Line.translate_2(l2,v2) # shift of line for pattern
        v3 = Vector3.normalize(Vector3.cross_product(v1,ZAxis)) #Eenheidsvector haaks op lijn
        if patrow.angle == 0:
            v4 = Vector3.scale(v3, n * patrow.offset_spacing)  # Verplaatsingsvector voor spacing, inverse in geval lijn = 0 graden
            v4 = Vector3.reverse(v4)
        else:
            v4 = Vector3.scale(v3, n * patrow.offset_spacing)  # Verplaatsingsvector voor spacing
        if n * patrow.offset_spacing == 0: # eerste lijn heeft geen verplaatsing
            l4 = l3
        else:
            l4 = l3.translate(v4)
        v6 = Vector3(dx + patrow.x_orig,dy + patrow.y_orig,0)
        print(v6)
        l5 = Line.translate_2(l4,v6)

        if patrow.dash == 0 and patrow.space == 0:
            lines.append(l5)
        else:
            # dashed lines
            LinePattern = ["Pat", [patrow.dash, -patrow.space],
                           1]  # Rule: line, whitespace, line whitespace etc., scale
            for i in line_to_pattern(l5, LinePattern):
                lines.append(i)
        n = n + 1

    return lines

def PAT2Geom(Pat: PAT, width, height,dx,dy):
    lineObjs = []
    for i in Pat.patrows:
        lines = PatRowGeom(i, width, height,dx,dy)
        for i in lines:
            lineObjs.append(i)
    return lineObjs

#reader
#drawsection


# TODO Line to Grid Object
# TODO Grid Object with building.py line --> convert to Speckle Line with pattern


def rgb_to_int(rgb):
    r, g, b = [max(0, min(255, c)) for c in rgb]

    return (255 << 24) | (r << 16) | (g << 8) | b


def getXYZ(XMLtree, nodenumber):
    root = XMLtree.getroot()
    # POINTS
    n = root.findall(".//Nodes/Number")
    nodenumbers = []

    for i in n:
        nodenumbers.append(i.text)
    # Search
    rest = nodenumbers.index(nodenumber)
    return (rest)


def XMLImportNodes(XMLtree):
    root = XMLtree.getroot()
    
    nodenumbers = [node.text for node in root.findall(".//Nodes/Number")]
    X = [float(x.text.replace(",", ".")) for x in root.findall(".//Nodes/X")]
    Y = [float(y.text.replace(",", ".")) for y in root.findall(".//Nodes/Y")]
    Z = [float(z.text.replace(",", ".")) for z in root.findall(".//Nodes/Z")]
    
    XYZ = [Point(x, y, z) for x, y, z in zip(X, Y, Z)]
    
    return nodenumbers, XYZ


def XMLImportgetGridDistances(Grids):
    # Function to create grids from the format 0, 4x5400, 4000, 4000 to absolute XYZ-values
    GridsNew = []
    distance = 0.0
    # GridsNew.append(distance)
    for i in Grids:
        # del Grids[0]
        if "x" in i:
            spl = i.split("x")
            count = int(spl[0])
            width = float(spl[1].replace(",", "."))
            for i in range(count):
                distance = distance + width
                GridsNew.append(distance)
        else:
            distance = distance + float(i)
            GridsNew.append(distance)
    return GridsNew


def XMLImportGrids(XMLtree, gridExtension):
    # create building.py Grids from the grids of XFEM4U
    root = XMLtree.getroot()
    gridlines = []

    # GRIDS
    GridEx = gridExtension

    GridsX = root.findall(".//Grids/X")[0].text.split()
    GridsX = XMLImportgetGridDistances(GridsX)
    Xmax = max(GridsX)
    GridsXLable = root.findall(".//Grids/X_Lable")[0].text.split()
    GridsY = root.findall(".//Grids/Y")[0].text.split()
    GridsY = XMLImportgetGridDistances(GridsY)
    Ymax = max(GridsY)
    GridsYLable = root.findall(".//Grids/Y_Lable")[0].text.split()
    GridsZ = root.findall(".//Grids/Z")[0].text.split()
    GridsZ = XMLImportgetGridDistances(GridsZ)
    GridsZLable = root.findall(".//Grids/Z_Lable")[0].text.split()
    Zmax = max(GridsZ)

    grids = []
    for i in GridsX:
        grids.append(Line(start=Point(i, -GridEx, 0),
                     end=Point(i, Ymax+GridEx, 0)))

    for i in GridsY:
        grids.append(Line(start=Point(-GridEx, i, 0),
                     end=Point(Xmax+GridEx, i, 0)))

    for i in GridsZ:
        grids.append(Line(start=Point(0, 0, i), end=Point(0, Xmax, i)))

    obj = []
    for i in grids:
        obj.append(Grid.by_startpoint_endpoint(i, "Grid"))
     #   gridlines.append(line)
    return obj

# def findMaterial(material):


def XMLImportPlates(XMLtree):
    # Get platedata from XML
    root = XMLtree.getroot()
    # PLATES

    platesNumbersElem = root.findall(".//Plates/Number")
    PlatesNodesElem = root.findall(".//Plates/Node")
    platesMaterialElem = root.findall(".//Plates/Material")
    platesZElem = root.findall(".//Plates/Z")
    platesThicknessElem = root.findall(".//Plates/h")
    platesTop_Center_BottomElem = root.findall(".//Plates/Top_Center_Bottom")

    platesNumbers = []
    for i in platesNumbersElem:
        platesNumbers.append(i.text)
    PlatesNodes = []
    for i in PlatesNodesElem:
        PlatesNodes.append(i.text)
    platesMaterialQuality = []
    for i in platesMaterialElem:
        platesMaterialQuality.append(i.text)
    platesMaterial = []
    lstConcrete = ["C20/25", "C25/30", "C30/37",
                   "C35/45", "C40/50", "C45/55", "C50/60", "C53/65"]
    lstTimber = ["C14", "C16", "C18", "C20", "C22", "C24", "C27", "C30", "C35",
                 "C40", "C50", "D18", "D24", "D30", "D35", "D40", "D50", "D60", "D70"]
    lstSteel = ["S235,S275,S355"]
    lstColor = []
    for i in platesMaterialQuality:
        if i in lstConcrete:
            platesMaterial.append("Concrete")
            lstColor.append(rgb_to_int([192, 192, 192]))
        elif i in lstTimber:
            platesMaterial.append("Timber")
            lstColor.append(rgb_to_int([191, 159, 116]))
        elif i in lstSteel:
            platesMaterial.append("Steel")
            lstColor.append(rgb_to_int([237, 28, 36]))
        else:
            platesMaterial.append("Other")
            lstColor.append(rgb_to_int([150, 150, 150]))
    platesZ = []
    for i in platesZElem:
        platesZ.append(float(i.text))
    platesThickness = []
    for i in platesThicknessElem:
        platesThickness.append(float(i.text))
    platesTop_Center_Bottom = []
    for i in platesTop_Center_BottomElem:
        platesTop_Center_Bottom.append(i.text)

    # for loop to get each element in an array
    plateOffsets = []
    # Plate ligt standaard in de hartlijn. In het onderstaande is dit aangepast.
    for i, j, k in zip(platesZ, platesThickness, platesTop_Center_Bottom):
        if k == "Top":
            offset = -0.5 * j
        elif k == "Center":
            offset = 0
        elif k == "Bottom":
            offset = 0.5 * j
        else:
            offset = 0
        offset = offset + j
        plateOffsets.append(offset)

    rootPlates = root.findall(".//Plates")

    # XMLImportPlates(root):
    PlatesTags = []
    PlatesValues = []
    for elements in root:
        if elements.tag == "Plates":
            for element in elements:
                PlatesTags.append(element.tag)
                PlatesValues.append(element.text)

    # Iedere plate met nodes in een sublijst stoppen
        # plate
            # nodes

    # indices where a new plate starts.
    ind = [i for i, x in enumerate(PlatesTags) if x == "Number"]

    platesIndices = []
    platesValues = []
    platesNodes = []
    count = 0
    for x in ind:
        count = count + 1
        try:
            platesIndices.append(PlatesTags[x:ind[count]])
            platesValues.append(PlatesValues[x:ind[count]])
            platesNodes.append(PlatesValues[x+1:ind[count]-5])
        except:
            # voor de laatste item uit de lijst, anders out of range
            platesIndices.append(PlatesTags[x::])
            # voor de laatste item uit de lijst, anders out of range
            platesValues.append(PlatesValues[x::])
            platesNodes.append(PlatesValues[x+1:-5])

    obj = []
    XYZ = XMLImportNodes(XMLtree)[1]  # Knopen

    platesPolyCurves = []
    for i in platesNodes:
        PlatePoints = []
        for j in i:
            Point = XYZ[getXYZ(XMLtree, j)]
            PlatePoints.append(Point)
        PlatePoints.append(PlatePoints[0])
        ply = PolyCurve.by_points(PlatePoints)
        # obj.append(ply)
        platesPolyCurves.append(ply)

    # Panels maken Building.py
    Panels = []

    for i, j, k, l, m, n in zip(platesPolyCurves, platesThickness, plateOffsets, platesMaterial, platesNumbers, lstColor):
        Panels.append(Panel.by_polycurve_thickness(i, j, k, l + m, n))

    return Panels


class xmlXFEM4U:
    def __init__(self):
        self.Frame1 = "<Frame>\n"
        self.Project = "<ProjectName>" + "Building.py" + "</ProjectName>\n"
        self.ProjectNumber = "<ProjectNumber>0</ProjectNumber>\n"
        self.ExportDate = "<ExportDateTime>2023-04-08 19:55:39Z</ExportDateTime>\n"
        self.XMLVersion = "<XMLExportVersion>v4.0.30319</XMLExportVersion>\n"
        self.Nodes = "<Nodes></Nodes>\n"
        self.Supports = "<Supports></Supports>\n"
        self.Grids = "<Grids><X>0 5000</X><X_Lable>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z AA AB AC</X_Lable><Y>0 5000</Y><Y_Lable>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24</Y_Lable><Z>0</Z><Z_Lable>+0</Z_Lable></Grids>\n"
        self.Profiles = "<Profiles></Profiles>\n"
        self.Beamgroup = "<Beamgroup></Beamgroup>\n"
        self.Beams = "<Beams></Beams>\n"
        self.Panels = "<Panels></Panels>\n"
        self.Plates = "<Plates></Plates>\n"
        self.LoadCases = "<LoadCases></LoadCases>\n"
        self.BeamLoads = "<BeamLoads></BeamLoads>\n"
        self.NodeLoads = "<NodeLoads></NodeLoads>\n"
        self.SurfaceLoads = "<SurfaceLoads></SurfaceLoads>\n"
        self.Combinations = "<Combinations></Combinations>\n"
        self.RebarLongitudinal = "<RebarLongitudinal></RebarLongitudinal>\n"
        self.RebarStirrup = "<RebarStirrup></RebarStirrup>\n"
        self.Layers = "<Layers><Layer_number>1</Layer_number><Layer_description>Layer 1</Layer_description></Layers>\n"
        self.Frame2 = "</Frame>\n"
        self.xmlstr = None

    def addBeamsPlates(self, buildingpyobj):
        obj = buildingpyobj
        # Number of nodes:
        n = 0
        Nodes = []
        Plates = []
        Beams = []
        Beamgroup = []
        Profiles = []
        Supports = []
        Points = []
        plateN = 0  # Numbering plates
        beamsN = 0  # Numbering beams
        beamsGN = 0  # Numbering beamgroup
        profN = 0  # Numbering profiles
        supportN = 0  # Numbering of supports
        Nodes.append("<Nodes>\n")
        Plates.append("<Plates>\n")
        Beams.append("<Beams>\n")
        Beamgroup.append("<Beamgroup>\n")
        Profiles.append("<Profiles>\n")
        Supports.append("<Supports>\n")

        ProfileNames = []  # all profiles
        for i in obj:
            nm = i.__class__.__name__
            if nm == "Frame":
                ProfileNames.append([i, i.profileName])

        ProfileNamesUnique = []  # Unique profiles
        ItemsOfUniqueProfileName = []
        for item in ProfileNames:
            if item[1] not in ProfileNamesUnique:
                ProfileNamesUnique.append(item[1])
                ItemsOfUniqueProfileName.append(item[0])

        for i, j in zip(ProfileNamesUnique, ItemsOfUniqueProfileName):
            profN = profN + 1
            Profiles.append("<Number>" + str(profN) + "</Number>\n")
            if j.material.name == "Steel":
                Profiles.append("<Profile_name>" + i + "</Profile_name>\n")
                Profiles.append("<Material_type>" + "0" + "</Material_type>\n")
                Profiles.append("<Material>" + "S235" + "</Material>\n")
                Profiles.append("<Angle>" + "0" + "</Angle>\n")
            elif j.material.name == "Concrete":  # nu simpel al het andere is beton
                Profiles.append("<Profile_name>" + "Profile " +
                                str(profN) + "</Profile_name>\n")
                Profiles.append("<Material_type>" + "1" + "</Material_type>\n")
                Profiles.append("<Material>" + "C20/25" + "</Material>\n")
                Profiles.append("<Angle>" + "0" + "</Angle>\n")
                Profiles.append("<Profile_shape>" + "1" + "</Profile_shape>\n")
                Profiles.append("<h>600</h>\n")
                Profiles.append("<b>500</b>\n")
                Profiles.append("<h1>50</h1>\n")
                Profiles.append("<b1>50</b1>\n")
                Profiles.append("<h2>50</h2>\n")
                Profiles.append("<b2>50</b2>\n")
                Profiles.append("<h3>50</h3>\n")
                Profiles.append("<b3>50</b3>\n")
                Profiles.append("<h4>50</h4>\n")
                Profiles.append("<b4>50</b4>\n")

        for i in obj:
            nm = i.__class__.__name__
            if nm == 'Panel':
                plateN = plateN + 1
                Plates.append("<Number>" + str(plateN) + "</Number>\n")
                PlatePoints = i.origincurve.points[: -1]
                for j in PlatePoints:
                    n = n + 1
                    Nodes.append("<Number>" + str(n) + "</Number>\n")
                    Nodes.append("<X>" + str(round(j.x)) + "</X>\n")
                    Nodes.append("<Y>" + str(round(j.y)) + "</Y>\n")
                    Nodes.append("<Z>" + str(round(j.z)) + "</Z>\n")
                    Plates.append("<Node>" + str(n) + "</Node>\n")
                Plates.append("<h>" + str(i.thickness) + "</h>\n")
                Plates.append(
                    "<Material_type>" + "c4aeb39b3f8d45cf9613e8377bdf73624" + "</Material_type>\n")  # material nog uitlezen #Concrete: c9a5876f475cefab7cc11281b017914a1 # Steel: c4aeb39b3f8d45cf9613e8377bdf73624
                # material nog uitlezen
                Plates.append("<Material>" + "S235" + "</Material>\n")
                Plates.append("<Z>" + "0" + "</Z>\n")
                Plates.append("<Top_Center_Bottom>" +
                              "Center" + "</Top_Center_Bottom>\n")

            elif nm == 'Frame':
                ProfN = ProfileNamesUnique.index(i.profileName) + 1
                beamsGN = beamsGN + 1
                Beamgroup.append("<Number>" + str(beamsGN) + "</Number>\n")
                n = n + 1
                Nodes.append("<Number>" + str(n) + "</Number>\n")
                Nodes.append("<X>" + str(round(i.start.x)) + "</X>\n")
                Nodes.append("<Y>" + str(round(i.start.y)) + "</Y>\n")
                Nodes.append("<Z>" + str(round(i.start.z)) + "</Z>\n")

                Beamgroup.append("<Startnode>" + str(n) + "</Startnode>\n")

                Points.append([i.start, n])

                beamsN = beamsN + 1
                Beams.append("<Number>" + str(beamsN) + "</Number>")
                Beams.append("<Beamgroupnumber>" +
                             str(beamsGN) + "</Beamgroupnumber>\n")
                Beams.append("<From_node_number>" +
                             str(n) + "</From_node_number>\n")

                n = n + 1
                Nodes.append("<Number>" + str(n) + "</Number>\n")
                Nodes.append("<X>" + str(round(i.end.x)) + "</X>\n")
                Nodes.append("<Y>" + str(round(i.end.y)) + "</Y>\n")
                Nodes.append("<Z>" + str(round(i.end.z)) + "</Z>\n")

                Beamgroup.append("<Endnode>" + str(n) + "</Endnode>\n")

                Points.append([i.end, n])

                Beams.append("<To_node_number>" +
                             str(n) + "</To_node_number>\n")
                Beams.append("<Angle>" + str(i.rotation) + "</Angle>\n")
                Beams.append("<Angle_profile>" + "0" + "</Angle_profile>\n")
                ProfNstr = str(ProfN)
                Beams.append("<Profile_number>" + ProfNstr +
                             "</Profile_number>\n")
                Beams.append("<Z>" + str(i.ZOffset) + "</Z>\n")
                Beams.append("<Top_Center_Bottom>" +
                             i.YJustification + "</Top_Center_Bottom>\n")
            elif nm == 'Grid':
                pass
        for i in obj:
            nm = i.__class__.__name__
            if nm == 'Support':
                supportN = supportN + 1

                bools = []
                for j in Points:
                    bools.append(Point.intersect(i.Point, j[0]))
                if sum(bools) > 0:  # Means intersection with existing point/node
                    no = bools.index(1)+1
                else:  # No intersection, so new node is required
                    n = n + 1
                    Nodes.append("<Number>" + str(n) + "</Number>\n")
                    Nodes.append("<X>" + str(round(i.Point.x)) + "</X>\n")
                    Nodes.append("<Y>" + str(round(i.Point.y)) + "</Y>\n")
                    Nodes.append("<Z>" + str(round(i.Point.z)) + "</Z>\n")
                    no = n
                Supports.append("<Number>" + str(supportN) + "</Number>\n")
                Supports.append("<Nodenumber>" + str(no) + "</Nodenumber>\n")
                Supports.append("<Tx>" + i.Tx + "</Tx>\n")
                Supports.append("<Ty>" + i.Ty + "</Ty>\n")
                Supports.append("<Tz>" + i.Tz + "</Tz>\n")
                Supports.append("<Rx>" + i.Rx + "</Rx>\n")
                Supports.append("<Ry>" + i.Ry + "</Ry>\n")
                Supports.append("<Rz>" + i.Rz + "</Rz>\n")
                Supports.append("<Kx>" + str(i.Kx) + "</Kx>\n")
                Supports.append("<Ky>" + str(i.Ky) + "</Ky>\n")
                Supports.append("<Kz>" + str(i.Kz) + "</Kz>\n")
                Supports.append("<Cx>" + str(i.Cx) + "</Cx>\n")
                Supports.append("<Cy>" + str(i.Cy) + "</Cy>\n")
                Supports.append("<Cz>" + str(i.Cz) + "</Cz>\n")
                Supports.append("<dx>" + str(i.dx) + "</dx>\n")
                Supports.append("<dy>" + str(i.dy) + "</dy>\n")
                Supports.append("<dz>" + str(i.dz) + "</dz>\n")

            else:
                pass

        Nodes.append("</Nodes>\n")
        Plates.append("</Plates>\n")
        Beams.append("</Beams>\n")
        Profiles.append("</Profiles>\n")
        Beamgroup.append("</Beamgroup>\n")
        Supports.append("</Supports>\n")

        self.Nodes = ''.join(str(N) for N in Nodes)
        self.Plates = ''.join(str(P) for P in Plates)
        self.Beams = ''.join(str(B) for B in Beams)
        self.Beamgroup = ''.join(str(BP) for BP in Beamgroup)
        self.Profiles = ''.join(str(Pr) for Pr in Profiles)
        self.Supports = ''.join(str(Sup) for Sup in Supports)

    def addGrids(self, spacX=None, seqX=None, spacY=None, seqY=None, z=None):
        if spacX is None:
            self.Grids = "<Grids>" + "</Grids>"
        else:
            self.Grids = "<Grids>" + "<X>" + spacX + "</X>" + "<X_Lable>" + seqX + "</X_Lable>" + "<Y>" + spacY + "</Y>" + "<Y_Lable>" + seqY + "</Y_Lable>" + "<Z>" + "0 " + str(
                z) + "</Z>" + "<Z_Lable>" + "+0 h" + "</Z_Lable>" + "</Grids>"

    def addLoadCasesCombinations(self):
        # Standard Load Cases and Combinations
        # Load Cases
        LoadCases = []
        LoadCases.append("<LoadCases>\n")
        LoadCases.append("<Number>1</Number>\n")
        LoadCases.append("<Description>Permanent</Description>\n")
        LoadCases.append("<Type>0</Type>\n")
        LoadCases.append("<psi0>1</psi0>\n")
        LoadCases.append("<psi1>1</psi1>\n")
        LoadCases.append("<psi2>1</psi2>\n")
        LoadCases.append("<Number>2</Number>\n")
        LoadCases.append("<Description>Veranderlijk</Description>\n")
        LoadCases.append("<Type>1</Type>\n")
        LoadCases.append("<psi0>0,4</psi0>\n")
        LoadCases.append("<psi1>0,5</psi1>\n")
        LoadCases.append("<psi2>0,3</psi2>\n")
        LoadCases.append("</LoadCases>\n")

        # Load Combinations
        Combinations = []
        Combinations.append("<Combinations>\n")
        Combinations.append(
            "<LoadCombinationNumber>1</LoadCombinationNumber>\n")
        Combinations.append("<Description>Dead load</Description>\n")
        Combinations.append("<CombTyp>0</CombTyp>\n")
        Combinations.append("<Case>1</Case>\n")
        Combinations.append("<Psi>1</Psi>\n")
        Combinations.append("<Gamma>1, 35</Gamma>\n")
        Combinations.append("<Case>2</Case>\n")
        Combinations.append("<Psi>1</Psi>\n")
        Combinations.append("<Gamma>1, 5</Gamma>\n")
        Combinations.append(
            "<LoadCombinationNumber>2</LoadCombinationNumber>\n")
        Combinations.append("<Description>Live load</Description>\n")
        Combinations.append("<CombTyp>0</CombTyp>\n")
        Combinations.append("<Case>1</Case>\n")
        Combinations.append("<Psi>1</Psi>\n")
        Combinations.append("<Gamma>1, 2</Gamma>\n")
        Combinations.append("<Case>2</Case>\n")
        Combinations.append("<Psi>1</Psi>\n")
        Combinations.append("<Gamma>1, 5</Gamma>\n")
        Combinations.append(
            "<LoadCombinationNumber>3</LoadCombinationNumber>\n")
        Combinations.append("<Description>Dead load</Description>\n")
        Combinations.append("<CombTyp>3</CombTyp>")
        Combinations.append("<Case>1</Case>")
        Combinations.append("<Psi>1</Psi>")
        Combinations.append("<Gamma>1</Gamma>")
        Combinations.append("<Case>2</Case>")
        Combinations.append("<Psi>1</Psi>")
        Combinations.append("<Gamma>1</Gamma>")
        Combinations.append("<LoadCombinationNumber>4</LoadCombinationNumber>")
        Combinations.append("<Description>Live")
        Combinations.append("load</Description>")
        Combinations.append("<CombTyp>3</CombTyp>")
        Combinations.append("<Case>1</Case>")
        Combinations.append("<Psi>1</Psi>")
        Combinations.append("<Gamma>1</Gamma>")
        Combinations.append("<Case>2</Case>")
        Combinations.append("<Psi>1</Psi>")
        Combinations.append("<Gamma>1</Gamma>")
        Combinations.append("<LoadCombinationNumber>5</LoadCombinationNumber>")
        Combinations.append("<Description>SLS")
        Combinations.append("Permanent</Description>")
        Combinations.append("<CombTyp>4</CombTyp>")
        Combinations.append("<Case>1</Case>")
        Combinations.append("<Psi>1</Psi>")
        Combinations.append("<Gamma>1</Gamma>")
        Combinations.append("<LoadCombinationNumber>6</LoadCombinationNumber>")
        Combinations.append("<Description>SLS")
        Combinations.append("Quasi - permanent</Description>")
        Combinations.append("<CombTyp>2</CombTyp>")
        Combinations.append("<Case>1</Case>")
        Combinations.append("<Psi>1</Psi>")
        Combinations.append("<Gamma>1</Gamma>")
        Combinations.append("<Case>2</Case>")
        Combinations.append("<Psi>0, 8</Psi>")
        Combinations.append("<Gamma>1</Gamma>")
        Combinations.append("</Combinations>")
        self.LoadCases = ''.join(str(LCa) for LCa in LoadCases)
        self.Combinations = ''.join(str(LC) for LC in Combinations)

    def addSurfaceLoad(self, obj=None):
        SurfaceLoads = []
        SurfaceLoads.append("<SurfaceLoads>\n")
        if obj != None:
            slN = 0
            for i in obj:
                nm = i.__class__.__name__
                if nm == "SurfaceLoad":
                    slN = slN + 1
                    SurfaceLoads.append("<Number>" + str(slN) + "</Number>\n")
                    SurfaceLoads.append(
                        "<LoadCaseNumber>" + str(i.LoadCase) + "</LoadCaseNumber>\n")
                    SurfaceLoads.append(
                        "<Description>" + i.Description + "</Description>\n")
                    for j in i.PolyCurve.points:
                        SurfaceLoads.append(
                            "<NodeX>" + str(j.x) + "</NodeX>\n")
                        SurfaceLoads.append(
                            "<NodeY>" + str(j.y) + "</NodeY>\n")
                        SurfaceLoads.append(
                            "<NodeZ>" + str(j.z) + "</NodeZ>\n")
                    SurfaceLoads.append(
                        "<Coordinate_system>" + i.crs + "</Coordinate_system>\n")
                    SurfaceLoads.append(
                        "<Direction>" + i.direction + "</Direction>\n")
                    SurfaceLoads.append(
                        "<LoadBearingDirection>" + i.LoadBearingDirection + "</LoadBearingDirection>\n")
                    SurfaceLoads.append("<q1>" + str(i.q1) + "</q1>\n")
                    SurfaceLoads.append("<q2>" + str(i.q2) + "</q2>\n")
                    SurfaceLoads.append("<q3>" + str(i.q3) + "</q3>\n")
                    SurfaceLoads.append(
                        "<LoadConstantOrLinear>" + i.LoadConstantOrLinear + "</LoadConstantOrLinear>\n")
                    SurfaceLoads.append("<iq1>" + str(i.iq1) + "</iq1>\n")
                    SurfaceLoads.append("<iq2>" + str(i.iq2) + "</iq2>\n")
                    SurfaceLoads.append("<iq3>" + str(i.iq3) + "</iq3>\n")
                else:
                    pass
        SurfaceLoads.append("</SurfaceLoads>\n")
        self.SurfaceLoads = ''.join(str(SL) for SL in SurfaceLoads)

    def addPanels(self, obj=None):
        Panels = []
        Panels.append("<Panels>\n")
        if obj != None:
            slN = 0
            for i in obj:
                nm = i.__class__.__name__
                if nm == "LoadPanel":
                    slN = slN + 1
                    Panels.append("<Number>" + str(slN) + "</Number>\n")
                    Panels.append("<Description>" +
                                  i.Description + "</Description>\n")
                    for j in i.PolyCurve.points:
                        Panels.append("<NodeX>" + str(j.x) + "</NodeX>\n")
                        Panels.append("<NodeY>" + str(j.y) + "</NodeY>\n")
                        Panels.append("<NodeZ>" + str(j.z) + "</NodeZ>\n")
                    Panels.append(
                        "<LoadBearingDirection>" + i.LoadBearingDirection + "</LoadBearingDirection>\n")
                    Panels.append("<SurfaceType>" +
                                  i.LoadBearingDirection + "</SurfaceType>\n")
                else:
                    pass
        Panels.append("</Panels>\n")
        self.Panels = ''.join(str(pan) for pan in Panels)

    def addProject(self, projectname):
        self.Project = "<ProjectName>" + projectname + "</ProjectName>"

    def addprojectnumber(self, ProjectNumber):
        self.ProjectNumber = "<ProjectNumber>" + ProjectNumber + "</ProjectNumber>\n"

    def XML(self):
        self.xmlstr = self.Frame1 + self.Project + self.ProjectNumber + self.ExportDate + self.XMLVersion + self.Nodes + self.Supports + self.Grids + self.Profiles + self.Beamgroup + self.Beams + \
            self.Plates + self.Panels + self.LoadCases + self.BeamLoads + self.NodeLoads + self.SurfaceLoads + \
            self.Combinations + self.RebarLongitudinal + \
            self.RebarStirrup + self.Layers + self.Frame2

    def __str__(self):
        return f"{__class__.__name__}(" + f"{self.xmlstr})"


def createXFEM4UXML(project: BuildingPy, filepathxml: str):
    # Export to XFEM4U XMLK-file
    xmlS4U = xmlXFEM4U()  # Create XML object with standard values
    # Add Beams, Profiles, Plates, Beamgroups, Nodes
    xmlS4U.addBeamsPlates(project.objects)
    xmlS4U.addProject(project.name)
    xmlS4U.addPanels(project.objects)  # add Load Panels
    xmlS4U.addGrids()  # Grids
    xmlS4U.addLoadCasesCombinations()
    xmlS4U.XML()
    XMLString = xmlS4U.xmlstr

    filepath = filepathxml
    file = open(filepath, "w")
    a = file.write(XMLString)
    file.close()

    return filepath


def writeDirectCommandsfile(xmlfilepath: str):
    # Write Ini-file for directcommands
    pathdirectcommands = os.path.join(
        os.getenv('LOCALAPPDATA'), 'Struct4u', 'DirectCommands_XFEM4U.ini')
    row1 = '[Struct4u]\n'
    row2 = 'Import_XML=' + xmlfilepath + '\n'
    content = row1 + row2

    file = open(pathdirectcommands, "w")
    a = file.write(content)
    file.close()


def openXFEM4U(fileName):
    # Open XML file in XFEM4U
    os.system("C:/Struct4u/XFEM4U/wframe3d.exe " + fileName)


def openXFrame2D(fileName):
    # Open XML file in XFEM4U
    os.system("C:/Program Files (x86)/Struct4u/XFrame2d/XFrame2d.exe " + fileName)


def SubprocessXFEM4UThread():
    # Run XFEM4U
    try:
        subprocess.run("C:/Struct4u/XFEM4U/wframe3d.exe",
                       shell=True, check=False)
    except:
        print("exception")

# [!not included in BP singlefile - end]
class Scia_Params:
    def __init__(self, id=str, name=str, layer=str, perpendicular_alignment=str, lcs_rotation=str, start_node=str, end_node=str, cross_section=str, eem_type=str, bar_system_line_on=str, ey=str, ez=str, geometry_table=str, revit_rot=None, layer_type=None, Yjustification=str, Xjustification=str, centerbottom=None, profile_data=None):
        self.id = id
        self.type = __class__.__name__
        self.name = name
        self.layer = layer
        self.perpendicular_alignment = perpendicular_alignment
        self.lcs_rotation = lcs_rotation
        self.start_node = start_node
        self.end_node = end_node
        self.cross_section = cross_section
        self.eem_type = eem_type
        self.bar_system_line_on = bar_system_line_on
        self.ey = ey
        self.ez = ez
        self.geometry_table = geometry_table
        self.revit_rot = revit_rot
        self.layer_type = layer_type
        self.Yjustification = Yjustification
        self.Xjustification = Xjustification
        self.centerbottom = centerbottom
        self.profile_data = profile_data
        #add material


class LoadXML:
    def __init__(self, filename=str, project=BuildingPy):
        self.filename = filename
        self.project = project
        self.unrecognizedElements = []
        self.method_times = {}
        self.root = self.load()
        if self.root != None:
            self.getStaaf()
            if len(self.unrecognizedElements) != 0:
                print(f"Unrecognized objects: {self.unrecognizedElements}")


    def load(self):
        start_time = time.time()
        try:
            tree = ET.parse(self.filename)
            root = tree.getroot()
            return root
        except Exception as e:
            print(e)
            return None
        finally:
            end_time = time.time()
            self._record_time("load", end_time - start_time)
            return root

    def getAllKnoop(self):
        start_time = time.time()
        tableName = "EP_DSG_Elements.EP_StructNode.1"
        for container in self.root:
            for table in container:
                if table.attrib["t"] == tableName:
                    for obj in table:
                        if obj.tag == "{http://www.scia.cz}h":
                            for header in obj:
                                # print(header.attrib["t"])
                                pass
                        else:
                            pass
                            # print(obj.attrib["nm"])
        end_time = time.time()  # End time
        self._record_time("getStaaf", end_time - start_time)


    def _record_time(self, method_name, duration):
        if method_name in self.method_times:
            self.method_times[method_name] += duration
        else:
            self.method_times[method_name] = duration

    def print_total_times(self):
        for method, total_time in self.method_times.items():
            print(f"Total time for {method}: {total_time} seconds")

    def findKnoop(self, name):
        tableName = "EP_DSG_Elements.EP_StructNode.1"
        for container in self.root:
            for table in container:
                if table.attrib["t"] == tableName:
                    for obj in table.iter("{http://www.scia.cz}obj"):
                        if obj.attrib["nm"] == name:
                            x, y, z = round(float(obj[1].attrib["v"])*self.project.scale,0), round(float(obj[2].attrib["v"])*self.project.scale,0), round(float(obj[3].attrib["v"])*self.project.scale,0)
                            pt = Point(x,y,z)
                            return pt

    def findKnoopNumber(self, name):
        tableName = "EP_DSG_Elements.EP_StructNode.1"
        for container in self.root:
            for table in container:
                if table.attrib["t"] == tableName:
                    for obj in table.iter("{http://www.scia.cz}obj"):
                        if obj.attrib["nm"] == name:
                            return obj.attrib["nm"]


    def convertJustification(self, justification):
        justification = justification.lower()
        if justification == "left" or justification == "links":
            return "center", "left"
        elif justification == "right" or justification == "rechts":
            return "center", "right"
        elif justification == "top" or justification == "boven":
            return "top", "center"
        elif justification == "bottom" or justification == "onder":
            return "bottom", "center"
        elif justification == "top left" or justification == "linksboven":
            return "top", "left"
        elif justification == "top right" or justification == "rechtsboven":
            return "top", "right"
        elif justification == "bottom left" or justification == "linksonder":
            return "bottom", "left"
        elif justification == "bottom right" or justification == "rechtsonder":
            return "bottom", "right"
        elif justification == "center" or justification == "midden" or justification == "centre" or justification == "standaard":
            return "center", "center"
        else:
            print(f"Justification: [{justification}] not recognized")
            return "center", "center"


    def structuralElementRecognision(self, tag):
        columnstrings = ["kolom", "column"]
        for columnstring in columnstrings:
            if columnstring.lower() in tag.lower():
                return "Column"
        return "Beam"


    def getStaaf(self):
        tableName = "EP_DSG_Elements.EP_Beam.1"

        h0 = "Naam"
        h0Index = None

        h1 = "Laag"
        h1Index = None

        h2 = "Loodrecht uitlijning"
        h2Index = None

        h3 = "LCS-rotatie"
        h3Index = None

        h4 = "Beginknoop"
        h4Index = None

        h5 = "Eindknoop"
        h5Index = None

        h6 = "Doorsnede"
        h6Index = None

        h7 = "EEM-type"
        h7Index = None

        h8 = "Staafsysteemlijn op"
        h8Index = None

        h9 = "ey"
        h9Index = None

        h10= "ez"
        h10Index = None

        h11 = "Tabel van geometrie"
        h11Index = None

        removeLayers = ["dummy"]

        for container in self.root:
            for table in container:
                if table.attrib["t"] == tableName:
                    for obj in table:
                        if obj.tag == "{http://www.scia.cz}h":
                            for index, header in enumerate(obj):
                                if header.attrib["t"] == h0:
                                    h0Index = index
                                if header.attrib["t"] == h1:
                                    h1Index = index
                                if header.attrib["t"] == h2:
                                    h2Index = index
                                if header.attrib["t"] == h3:
                                    h3Index = index
                                if header.attrib["t"] == h4:
                                    h4Index = index
                                if header.attrib["t"] == h5:
                                    h5Index = index
                                if header.attrib["t"] == h6:
                                    h6Index = index
                                if header.attrib["t"] == h7:
                                    h7Index = index
                                if header.attrib["t"] == h8:
                                    h8Index = index
                                if header.attrib["t"] == h9:
                                    h9Index = index
                                if header.attrib["t"] == h10:
                                    h10Index = index
                                if header.attrib["t"] == h11:
                                    h11Index = index
                            if h1Index == None:
                                print("Incorrect Scia XML Export Template")
                                sys.exit()
                        else:
                            #define here
                            comments = Scia_Params()
                            comments.id = str(obj.attrib["id"])
                            comments.name = str(obj[h0Index].attrib["v"])
                            comments.layer = str(obj[h1Index].attrib["n"])
                            comments.perpendicular_alignment = str(obj[h2Index].attrib["t"])
                            comments.lcs_rotation = str(obj[h3Index].attrib["v"])
                            comments.start_node = str(obj[h4Index].attrib["n"])
                            comments.end_node = str(obj[h5Index].attrib["n"])
                            comments.cross_section = str(obj[h6Index].attrib["n"])
                            comments.eem_type = str(obj[h7Index].attrib["t"])
                            comments.bar_system_line_on = str(obj[h8Index].attrib["t"])
                            comments.ey = str(obj[h9Index].attrib["v"])
                            comments.ez = str(obj[h10Index].attrib["v"])
                            comments.geometry_table = str(obj[h11Index].attrib["t"])


                            p1 = self.findKnoop(obj[h4Index].attrib["n"])
                            p1Number = self.findKnoopNumber(obj[h4Index].attrib["n"])
                            p2 = self.findKnoop(obj[h5Index].attrib["n"])
                            p2Number = self.findKnoopNumber(obj[h5Index].attrib["n"])
                            
                            #TEMP
                            p1 = Point(p1.x, p1.y, p1.z)

                            node1 = Node()
                            node1.number = p1Number
                            node1.point = p1
                            self.project.objects.append(node1)

                            node2 = Node()
                            node2.point = p2
                            node2.number = p2Number
                            self.project.objects.append(node2)

                            ey = float(obj[h9Index].attrib["v"]) * -project.scale
                            ez = float(obj[h10Index].attrib["v"]) * project.scale
                            
                            lineSeg = Line(start=p1, end=p2)
                            
                            layerType = self.structuralElementRecognision(obj[h1Index].attrib["n"])

                            rotationRAD = obj[h3Index].attrib["v"]
                            

                            rotationDEG = (float(rotationRAD)*float(180) / math.pi)
                            if layerType == "Column":
                                rotationDEG = rotationDEG+90
                                Yjustification, Xjustification = self.convertJustification(comments.perpendicular_alignment)
                                comments.Yjustification = Yjustification
                                comments.Xjustification = Xjustification

                            Yjustification, Xjustification = self.convertJustification(comments.perpendicular_alignment)
                            comments.Yjustification = Yjustification
                            comments.Xjustification = Xjustification

                            comments.layer_type = layerType

                            comments.revit_rot = rotationDEG
                            elementType = (obj[h6Index].attrib["n"])

                            for removeLayer in removeLayers:
                                if removeLayer.lower() in elementType.lower():
                                    pass
                                else:
                                    elementType = elementType.split("-")[1].strip()
                                    self.project.objects.append(lineSeg)
                                    # try:
                                    el = Frame.by_startpoint_endpoint_profile_name_justifiction(node1, node2, elementType, elementType, Xjustification, Yjustification, rotationDEG, BaseSteel, ey, ez, layerType, comments)
                                    comments.profile_data = el.profile_data
                                    self.project.objects.append(el)
                                    comments.centerbottom = el.centerbottom
                                    # except Exception as e:
                                    #     if elementType not in self.unrecognizedElements:
                                    #         self.unrecognizedElements.append(elementType)
                                    #     print(e, elementType)