#[BuildingPy] DO NOT EDIT THIS FILE. IT IS GENERATED FROM THE SOURCE CODE
try:
    from collections.abc import MutableSequence
except ImportError:
    from collections import MutableSequence

from abc import ABC, abstractmethod
from abc import abstractmethod
from bisect import bisect
from collections import defaultdict
from functools import reduce
from math import sqrt, cos, sin, acos, degrees, radians, log, pi
from packages.svg.path import CubicBezier, QuadraticBezier, Line, Arc
from packages.svg.path import parse_path
from pathlib import Path
from typing import List
from typing import Self
from typing import Union
import copy
import importlib
import json
import math
import operator
import os
import pickle
import re
import string, random, json
import sys
import urllib
import urllib.request
import xml.etree.ElementTree as ET


class Support:
	def __init__(self):
		self.Number = None
		self.Point: Point = Point(0, 0, 0)
		
		self.Tx: str = " "  # A, P, N, S
		self.Ty: str = " "  # A, P, N, S
		self.Tz: str = " "  # A, P, N, S
		self.Rx: str = " "  # A, P, N, S
		self.Ry: str = " "  # A, P, N, S
		self.Rz: str = " "  # A, P, N, S
		self.Kx: float = 0  # kN/m
		self.Ky: float = 0  # kN/m
		self.Kz: float = 0  # kN/m
		self.Cx: float = 0  # kNm/rad
		self.Cy: float = 0  # kNm/rad
		self.Cz: float = 0  # kNm/rad
		self.dx: float = 0  # eccentricity in x
		self.dy: float = 0  # eccentricity in y
		self.dz: float = 0  # eccentricity in z

	@staticmethod
	def pinned(PlacementPoint):
		sup = Support()
		sup.Point = PlacementPoint
		sup.Tx = "A"
		sup.Ty = "A"
		sup.Tz = "A"
		return (sup)

	@staticmethod
	def x_roller(PlacementPoint):
		sup = Support()
		sup.Point = PlacementPoint
		sup.Ty = "A"
		sup.Tz = "A"
		return (sup)

	@staticmethod
	def y_roller(PlacementPoint):
		sup = Support()
		sup.Point = PlacementPoint
		sup.Tx = "A"
		sup.Tz = "A"
		return (sup)

	@staticmethod
	def z_roller(PlacementPoint):
		sup = Support()
		sup.Point = PlacementPoint
		sup.Tx = "A"
		sup.Ty = "A"
		return (sup)

	@staticmethod
	def fixed(PlacementPoint):
		sup = Support()
		sup.Point = PlacementPoint
		sup.Tx = "A"
		sup.Ty = "A"
		sup.Tz = "A"
		sup.Rx = "A"
		sup.Ry = "A"
		sup.Rz = "A"
		return (sup)


class LoadCase:
	def __init__(self):
		self.Number = None
		self.Description: str = ""
		self.psi0 = 1
		self.psi1 = 1
		self.psi2 = 1
		self.Type = 0  # 0 = permanent, 1 = variabel


class SurfaceLoad:
	def __init__(self):
		self.LoadCase = None
		self.PolyCurve: PolyCurve = None
		self.Description: str = ""
		self.crs = "ccaa0435161960d4c7e436cf107a03f61"
		self.direction = "caf2b4ce743de1df30071f9566b1015c6"
		self.LoadBearingDirection = "cfebf3fce7063ab9a89d28a86508c0fb3"
		self.q1 = 0
		self.q2 = 0
		self.q3 = 0
		self.LoadConstantOrLinear = "cb81ae405e988f21166edf06d7fd646fb"
		self.iq1 = -1
		self.iq2 = -1
		self.iq3 = -1

	@staticmethod
	def by_load_case_polycurve_q(LoadCase, PolyCurve, q):
		SL = SurfaceLoad()
		SL.LoadCase = LoadCase
		SL.PolyCurve = PolyCurve
		SL.q1 = q
		SL.q2 = q
		SL.q3 = q
		return SL


class LoadPanel:
	def __init__(self):
		self.PolyCurve: PolyCurve = None
		self.Description: str = ""
		self.LoadBearingDirection = "X"
		# Wall, saddle_roof_positive_pitch #Wall, / Free-standing wall, Flat roof, Shed roof, Saddle roof, Unknown
		self.SurfaceType = ""


def chess_board_surface_loads_rectangle(startx, starty, dx, dy, nx, ny, width, height, LoadCase, q123, description: str):
	SurfaceLoads = []
	x = startx
	y = starty
	for j in range(ny):
		for i in range(nx):
			SL = SurfaceLoad()
			SL.Description = description
			SL.LoadCase = LoadCase
			SL.PolyCurve = PolyCurve.by_points(
				[Point(x, y, 0),
				 Point(x + width, y, 0),
				 Point(x, y + height, 0),
				 Point(x, y, 0)]
			)
			SL.q1 = SL.q2 = SL.q3 = q123  # [kN/m2]
			SurfaceLoads.append(SL)
			x = x + dx
		y = y + dy
	return SurfaceLoads



class Serializable:
	@property
	def type(self):
		return __class__.__name__
	@staticmethod
	def serialize_type(obj) -> dict:
		"""Save the type of an object to a dictionary.

		Args:
			obj: the object to get the type of

		Returns:
			dict: a dictionary with keys 'module' and 'type'
		"""
		return {
			'module': obj.__module__,
			'type': obj.__class__.__name__
			}
		
	def serialize(self) -> dict:
		"""serialize members of this object into a dictionary

		Returns:
			dict: a dictionary of all members. the members will serialize themselves, when necessary.
		"""
		return self.__dict__
	
	def toJson(self) -> str:
		"""converts a serializable object to json

		Returns:
			str: a json string
		"""
		return json.dumps(self, default=lambda x: 
			#when a variable is not compatible with the standard json serialization functions, it's probably one of our classes.
			x.serialize() | self.serialize_type(x)
			)
	
	@staticmethod
	def deserialize_type(data):
		"""Creates an new object from the provided data."""
		if isinstance(data, dict):
			if 'type' in data:
				#module_name =  # data.pop('__module__')
				module = importlib.import_module(data.pop('module'))
				type = getattr(module, data.pop('type'))

				if hasattr(type, 'deserialize'):
					obj = type.deserialize(data)
				else:
					obj = type.__new__(type)
					#we assume obj is an instance of Serializable
					obj.deserialize_members(data)
				#obj.deserialize(data)
				return obj
			#else:
			#    return {key: Serializable.deserialize_type(value) for key, value in data.items()}
		elif isinstance(data, list):
			return [Serializable.deserialize_type(item) for item in data]
		return data
	
	def deserialize_members(self, data : dict):
		"""Deserializes the object from the provided data."""
	#    #raise NotImplementedError()
		for key, value in data.items():
			setattr(self, key, self.deserialize_type(value))
	
	def save(self, file_name):
		# we can possibly add an override function we can call on class objects. but for now, this will work fine
		serialized_data = self.toJson()
		with open(file_name, 'w') as file:
			file.write(serialized_data)
			
	def open(self, file_name):
		with open(file_name) as file:
			self.deserialize_members(json.load(file))
			# self.__dict__ = json.load(file)
	def __repr__(self) -> str:
		return str(self)


class ID(Serializable):
    def __init__(self) -> None:
        self.id = None
        self.object = None
        self.name = None
        self.generateID()

    def generateID(self) -> None:
        id = ""
        lengthID = 12
        random_source = string.ascii_uppercase + string.digits
        for x in range(lengthID):
            id += random.choice(random_source)

        id_list = list(id)
        self.id = f"#"+"".join(id_list)
        return f"test {self.__class__.__name__}"

    def str(self) -> str:
        return f"{self.id}"

def generateID() -> ID:
    return ID()

def find_in_list_of_list(mylist, char):
    for sub_list in mylist:
        if char in sub_list:
            return (mylist.index(sub_list))
    raise ValueError("'{char}' is not in list".format(char=char))


def findjson(id, json_string):
    #faster way to search in json
    results = []

    def _decode_dict(a_dict):
        try:
            results.append(a_dict[id])
        except KeyError:
            pass
        return a_dict

    json.loads(json_string, object_hook=_decode_dict) # Return value ignored.
    return results

def list_transpose(lst):
    #list of lists, transpose columns/rows
    newlist = list(map(list, zip(*lst)))
    return newlist

def is_null(lst):
    return all(el is None for el in lst)

def clean_list(input_list, preserve_indices=True):
    if not input_list:
        return input_list
    
    culled_list = []

    if preserve_indices:
        if is_null(input_list):
            return None
        
        j = len(input_list) - 1
        while j >= 0 and input_list[j] is None:
            j -= 1

        for i in range(j + 1):
            sublist = input_list[i]

            if isinstance(sublist, list):
                val = clean_list(sublist, preserve_indices)
                culled_list.append(val)
            else:
                culled_list.append(input_list[i])
    else:
        if is_null(input_list):
            return []
        
        for el in input_list:
            if isinstance(el, list):
                if not is_null(el):
                    val = clean_list(el, preserve_indices=False)
                    if val:
                        culled_list.append(val)
            elif el is not None:
                culled_list.append(el)
            
    return culled_list

def flatten(list:list[list]):
    """convert 2d list to 1d list

    Args:
        list (list[list]): a list of lists

    Returns:
        a list containing all elements: _description_
    """
    return [elem for sublist in list for elem in sublist]
    #if type(lst) != list:
    #    lst = [lst]
    #flat_list = []
    #for sublist in lst:
    #    try:
    #        for item in sublist:
    #            flat_list.append(item)
    #    except:
    #        flat_list.append(sublist)
    #return flat_list

def all_true(lst):
    for element in lst:
        if not element:
            return False
    return True

def replace_at_index(object, index, new_object):
    if index < 0 or index >= len(object):
        raise IndexError("Index out of range")
    return object[:index] + new_object + object[index+1:]

def xmldata(myurl, xPathStrings):
    urlFile = urllib.request.urlopen(myurl)
    tree = ET.parse(urlFile)
    xPathResults = []
    for xPathString in xPathStrings:
        a = tree.findall(xPathString)
        xPathResulttemp2 = []
        for xPathResult in a:
            xPathResulttemp2.append(xPathResult.text)
        xPathResults.append(xPathResulttemp2)
    return xPathResults


@staticmethod
def rgb_to_int(rgb):
    r, g, b = [max(0, min(255, c)) for c in rgb]
    return (255 << 24) | (r << 16) | (g << 8) | b

class Shape:
	"""this class defines functions and properties for geometric shapes."""
	@property
	def statical_moment(self) -> float:
		return self.area * self.centroid.y

def to_array(*args) -> list:
    """converts the arguments into an array.

    Returns:
            list: the arguments provided, converted to a list.
    """
    return args[0] if len(args) == 1 and hasattr(args[0], "__getitem__") else list(args)


class Vector(Serializable, list):
    """
    a shared base class for point and vector. contains the x, y and z coordinates.
    operations you do with these vector will apply for the children.
    for example: Vector(2, 4, 6) / 2 = Vector(1, 2, 3)
    or: Vector(2,5) ** 2 = Vector(4, 25)
    Vectors can also be nested.
    """

    def __init__(self, *args, **kwargs) -> "Vector":
        arrayArgs: list = to_array(*args)

        list.__init__(self, arrayArgs)
        Serializable.__init__(self)

        for kwarg in kwargs.items():
            self.set_axis_by_name(kwarg[0], kwarg[1])
    x_axis : 'Vector' = None
    y_axis : 'Vector' = None
    z_axis : 'Vector' = None
    left : 'Vector' = None
    right : 'Vector' = None
    backward : 'Vector' = None
    forward : 'Vector' = None
    down : 'Vector' = None
    up : 'Vector' = None
    x_axis_2d : 'Vector' = None
    y_axis_2d : 'Vector' = None
    left_2d : 'Vector' = None
    right_2d : 'Vector' = None
    backward_2d : 'Vector' = None
    forward_2d : 'Vector' = None

    def __str__(self):
        return (
            self.__class__.__name__
            + "("
            + ",".join(
                [
                    f"{axis_name}={((v * 100) // 1 ) / 100 }"
                    for v, axis_name in zip(self, self.axis_names)
                ]
            )
            + ")"
        )

    axis_names = ["x", "y", "z", "w"]

    @property
    def dimensions(self):
        return len(self)

    @dimensions.setter
    def dimensions(self, value):
        if value > len(self):
            self.extend([0] * (value - len(self)))
        elif value < len(self):
            del self[value:]

    @property
    def x(self):
        return self[0]

    @x.setter
    def x(self, value):
        self[0] = value

    @property
    def y(self):
        return self[1]

    @y.setter
    def y(self, value):
        self[1] = value

    @property
    def z(self):
        return self[2]

    @z.setter
    def z(self, value):
        self[2] = value

    @property
    def w(self):
        return self[3]

    @w.setter
    def w(self, value):
        self[3] = value

    @property
    def magnitude_squared(self):
        result = 0
        for axis_value in self:
            result += axis_value * axis_value
        return result

    length_squared = magnitude_squared

    @property
    def magnitude(self):
        """the 'length' could also mean the axis count. this makes it more clear.
        Returns:
                the length
        """
        return math.sqrt(self.magnitude_squared)

    length = magnitude

    @magnitude.setter
    def magnitude(self, value):
        """Rescales the vector to have the specified length.

        #### Parameters:
        - `vector_1` (`Vector`): The vector to be rescaled.
        - `newlength` (float): The desired length of the vector.

        #### Returns:
        `Vector`: A new Vector object representing the rescaled vector.

        #### Example usage:
        ```python
        vector = Vector(3, 4, 0)
        new_vector = Vector.new_length(vector, 5)
        # Vector(X = 3.000, Y = 4.000, Z = 0.000)
        ```
        """
        self *= value / self.magnitude

    @property
    def normalized(self):
        """Returns the normalized form of the vector.
        The normalized form of a vector is a vector with the same direction but with a length (magnitude) of 1.

        #### Returns:
        `Vector`: A new Vector object representing the normalized form of the input vector.

        #### Example usage:
        ```python
        vector1 = Vector(3, 0, 4)
        normalized_vector = vector1.normalized
        # Vector(X = 0.600, Y = 0.000, Z = 0.800)
        ```
        """
        sqm = self.magnitude_squared

        return self / math.sqrt(sqm) if sqm > 0 else Vector([0] * len(self))

    @property
    def angle(self) -> float:
        """output range: -PI to PI

        Returns:
                float: the arc tangent of y / x in radians
        """
        # treat this normal vector as a triangle. we know all sides but want to know the angle.
        # tan(deg) = other side / straight side
        # deg = atan(other side / straight side)
        return math.atan2(self.y, self.x)

    @staticmethod
    def by_coordinates(x: float, y: float, z: float = None):
        return Vector(x, y, z) if z is not None else Vector(x, y)

    @staticmethod
    def by_list(coordinate_list: list):
        return Vector(coordinate_list)

    @staticmethod
    def by_angle(angle: float) -> "Vector":
        """generates a 2d normal using the angle passed

        Args:
                angle (float): a number in radians

        Returns:
                Vector: a rotated normal (vector with length of 1)
        """
        return Vector(math.cos(angle), math.sin(angle))

    @staticmethod
    def angle_between(vector_1: "Vector", vector_2: "Vector") -> float:
        """Computes the angle in degrees between two coords.
        The angle between two coords is the angle required to rotate one vector onto the other, measured in degrees.

        #### Parameters:
        - `vector_1` (`Vector`): The first vector.
        - `vector_2` (`Vector`): The second vector.

        #### Returns:
        `float`: The angle in degrees between the input coords.

        #### Example usage:
        ```python
        vector1 = Vector(1, 0, 0)
        vector2 = Vector(0, 1, 0)
        angle = Vector.angle_between(vector1, vector2)
        # 90
        ```
        """
        dot_product = Vector.dot_product(vector_1, vector_2)
        length_vector_1 = vector_1.magnitude
        length_vector_2 = vector_2.magnitude

        if length_vector_1 == 0 or length_vector_2 == 0:
            return 0

        cos_angle = dot_product / (length_vector_1 * length_vector_2)
        cos_angle = max(-1.0, min(cos_angle, 1.0))
        return math.acos(cos_angle)

    def dot_product(vector_1, vector_2: "Vector") -> "float":
        """Computes the dot product of two vectors.
        The dot product of two vectors is a scalar quantity equal to the sum of the products of their corresponding components. It gives insight into the angle between the vectors.

        #### Parameters:
        - `vector_1` (`Vector`): The first vector.
        - `vector_2` (`Vector`): The second vector.

        #### Returns:
        `float`: The dot product of the input vectors.

        #### Example usage:
        ```python
        vector1 = Vector(1, 2, 3)
        vector2 = Vector(4, 5, 6)
        dot_product = Vector.dot_product(vector1, vector2)
        # 32
        ```
        """
        total = 0
        for i in range(len(vector_1)):
            total += vector_1[i] * vector_2[i]
        return total

    @staticmethod
    def distance_squared(point_1: "Vector", point_2: "Vector") -> float:
        """Computes the Euclidean distance between two 3D points.

        #### Parameters:
        - `point_1` (Vector): The first point.
        - `point_2` (Vector): The second point.

        #### Returns:
        `float`: The Euclidean distance between `point_1` and `point_2`.

        #### Example usage:
        ```python
        point_1 = Vector(0, 0, 400)
        point_2 = Vector(300, 0, 400)
        output = Vector.distance(point_1, point_2)
        # 90000
        ```
        """
        return (point_2 - point_1).magnitude_squared

    @staticmethod
    def distance(point_1: "Vector", point_2: "Vector") -> float:
        """Computes the Euclidean distance between two 3D points.

        #### Parameters:
        - `point_1` (Vector): The first point.
        - `point_2` (Vector): The second point.

        #### Returns:
        `float`: The Euclidean distance between `point_1` and `point_2`.

        #### Example usage:
        ```python
        point_1 = Vector(0, 0, 400)
        point_2 = Vector(300, 0, 400)
        output = Vector.distance(point_1, point_2)
        # 90000
        ```
        """
        return (point_2 - point_1).magnitude

    @staticmethod
    def axis_index(axis: str) -> int:
        """returns index of axis name.<br>
        raises a valueError when the name isn't valid.

        Args:
                axis (str): the name of the axis

        Returns:
                int: the index
        """
        return Vector.axis_names.index(axis.lower())

    @staticmethod
    def cross_product(
        vector_1: "Vector", vector_2: "Vector|None" = None
    ) -> "Vector|float":
        """Computes the cross product of two vectors in three-dimensional space is a vector that is perpendicular to both original vectors. It is used to find a vector that is normal to a plane defined by the input vectors.
        we're using the right hand rule, as stated in the wiki.

        #### Parameters:
        - `vector_1` (`Vector`): The first vector.
        - `vector_2` (`Vector`): The second vector. (when not passed, it will just return a random perpendicular vector to vector_1)

        #### Returns:
        `Vector`: A new Vector object representing the cross product of the input vectors.

        #### Example usage:
        ```python
        vector1 = Vector(1, 2, 3)
        vector2 = Vector(4, 5, 6)
        cross_product = Vector.cross_product(vector1, vector2)
        # Vector(X = -3, Y = 6, Z = -3)
        ```
        """
        if len(vector_1) == 3:
            return Vector(
                vector_1.y * vector_2.z - vector_1.z * vector_2.y,
                vector_1.z * vector_2.x - vector_1.x * vector_2.z,
                vector_1.x * vector_2.y - vector_1.y * vector_2.x,
            )
        elif vector_2 == None:
            # rotate the vector 90 degrees, counter clockwise
            return Vector(-vector_1.y, vector_1.x)
        else:
            # just return the value of the z axis which would result if these were 3d vectors
            return vector_1.x * vector_2.y - vector_1.y * vector_2.x

    perpendicular = cross_product

    def change_axis_count(self, axis_count: int):
        """in- or decreases the amount of axes to the preferred axis count.

        Args:
                axis_count (int): the new amount of axes
        """
        if axis_count > len(self):
            diff = axis_count + 1 - len(self)
            self.extend([0] * diff)
        else:
            self = self[:axis_count]

    def set_axis(self, axis_index: int, value) -> int | None:
        """sets an axis with the specified index to the value. will resize when the coords can't contain them.

        Args:
                axis_index (int): the index of the axis, for example 2
                value: the value to set the axis to

        Returns:
                int: the new size when resized, -1 when the axis is invalid, None when the value was just set.
        """

        if axis_index >= len(self):
            self.extend([0] * (axis_index - len(self)))
            self.extend([value])
            return axis_index
        self[axis_index] = value
        return None

    def set_axis_by_name(self, axis_name: str, value) -> int | None:
        """sets an axis with the specified name to the value. will resize when the coords can't contain them.

        Args:
                axis_name (str): the name of the axis, for example 'x'
                value: the value to set the axis to

        Returns:
                int: the new size when resized, -1 when the axis is invalid, None when the value was just set.
        """
        return self.set_axis(Vector.axis_index(axis_name), value)

    @staticmethod
    def by_two_points(point_1: "Vector", point_2: "Vector") -> "Vector":
        """Computes the vector between two points.

        #### Parameters:
        - `point_1` (`Vector`): The starting point.
        - `point_2` (`Vector`): The ending point.

        #### Returns:
        `Vector`: A new Vector object representing the vector between the two points.

        #### Example usage:
        ```python
        point1 = Point(1, 2, 3)
        point2 = Point(4, 6, 8)
        vector = Vector.by_two_points(point1, point2)
        # Vector(X = 3, Y = 4, Z = 5)
        ```
        """
        return point_2 - point_1

    @staticmethod
    def rotate(point: "Vector", angle: float, axis: "Vector" = None, pivot: 'Vector' = None) -> "Vector":
        """use Matrix.by_rotation(axis, angle) * point instead!"""

        from abstract.matrix import Matrix

        return Matrix.rotate(angle, axis, pivot) * point

    def volume(self):
        result = 1
        for val in self:
            result *= val
        return result

    # useful for sorting
    def compare(self, other):
        for axis in range(len(self)):
            if self[axis] != other[axis]:
                return other[axis] - self[axis]
        return 0

    def ioperate_2(self, op: operator, other):
        try:
            for index in range(len(self)):
                self[index] = op(self[index], other[index])
        except TypeError:
            # variable doesn't support index
            # https://stackoverflow.com/questions/7604380/check-for-operator
            for index in range(len(self)):
                self[index] = op(self[index], other)
        return self

    def operate_2(self, op: operator, other):
        result = Vector([0] * len(self))
        try:
            for index in range(len(self)):
                result[index] = op(self[index], other[index])
        except TypeError:
            # variable doesn't support index
            # https://stackoverflow.com/questions/7604380/check-for-operator
            for index in range(len(self)):
                result[index] = op(self[index], other)
        return result

    def operate_1(self, op: operator):
        result = Vector([0] * len(self))
        for index in range(len(self)):
            result[index] = op(self[index])
        return result

    def __add__(self, other):
        """Calculates the sum of two vectors.

        equivalent to the + operator.

        """
        return self.operate_2(operator.__add__, other)

    sum = translate = __add__

    def __sub__(self, other):
        """Calculates the difference between two Vector objects.
        This method returns a new Vector object that is the result of subtracting the components of `vector_2` from `vector_1`.

        equivalent to the - operator.

        #### Parameters:
        - `vector_1` (`Vector`): The minuend vector.
        - `vector_2` (`Vector`): The subtrahend vector.

        #### Returns:
        `Vector`: A new Vector object resulting from the component-wise subtraction of `vector_2` from `vector_1`.

        #### Example usage:
        ```python
        vector1 = Vector(5, 7, 9)
        vector2 = Vector(1, 2, 3)
        result = Vector.diff(vector1, vector2)
        # Vector(X = 4.000, Y = 5.000, Z = 6.000)
        ```
        """
        return self.operate_2(operator.__sub__, other)

    difference = diff = substract = __sub__

    def __truediv__(self, other):
        """Divides the components of the first vector by the corresponding components of the second vector.
        This method performs component-wise division. If any component of `vector_2` is 0, the result for that component will be undefined.

        equivalent to the / operator.

        #### Parameters:
        - `vector_1` (`Vector`): The numerator vector.
        - `vector_2` (`Vector`): The denominator vector.

        #### Returns:
        `Vector`: A new Vector object resulting from the component-wise division.

        #### Example usage:
        ```python
        vector1 = Vector(10, 20, 30)
        vector2 = Vector(2, 4, 5)
        result = Vector.divide(vector1, vector2)
        # Vector(X = 5.000, Y = 5.000, Z = 6.000)
        ```
        """
        return self.operate_2(operator.__truediv__, other)

    divide = __truediv__

    def __mul__(self, other):
        """Scales the vector by the specified scale factor.

        equivalent to the * operator.

        #### Parameters:
        - `vector` (`Vector`): The vector to be scaled.
        - `scalefactor` (float): The scale factor.

        #### Returns:
        `Vector`: A new Vector object representing the scaled vector.

        #### Example usage:
        ```python
        vector = Vector(1, 2, 3)
        scaled_vector = Vector.scale(vector, 2)
        # Vector(X = 2, Y = 4, Z = 6)
        ```
        """
        return self.operate_2(operator.__mul__, other)

    product = scale = __rmul__ = __mul__

    def __pow__(self, power: float) -> Self:
        """raises the vector to a certain power.

        equivalent to the ** operator.

        Returns:
                Self: a vector with all components raised to the specified power
        """
        return self.ioperate_2(operator.__pow__)

    def __neg__(self) -> Self:
        """negates this vector.

        equivalent to the - operator.

        Returns:
                Self: a vector with all components negated.
        """
        return self.operate_1(operator.__neg__)

    reverse = __neg__

    @staticmethod
    def square(self) -> "Vector":
        """
        Computes the square of each component of the input vector.

        #### Parameters:
        - `vector_1` (`Vector`): The input vector.

        #### Returns:
        `Vector`: A new Vector object representing the square of each component of the input vector.

        #### Example usage:
        ```python
        vector = Vector(2, 3, 4)
        squared_vector = Vector.square(vector)
        # Vector(X = 4, Y = 9, Z = 16)
        ```
        """
        return self**2

    # i operators. these operate on self (+=, *=, etc)

    def __iadd__(self, other) -> Self:
        """Translates the point by a given vector.

        equivalent to the += operator.

        #### Parameters:
        - `point` (Point): The point to be translated.
        - `vector` (Vector): The translation vector.

        #### Returns:
        `Point`: Translated point.

        #### Example usage:
        ```python
        point = Point(23, 1, 23)
        vector = Vector(93, 0, -19)
        output = Point.translate(point, vector)
        # Point(X = 116.000, Y = 1.000, Z = 4.000)
        ```
        """
        return self.ioperate_2(operator.__iadd__, other)

    def __isub__(self, other) -> Self:
        return self.ioperate_2(operator.__isub__, other)

    def __imul__(self, other) -> Self:
        return self.ioperate_2(operator.__imul__, other)

    def __itruediv__(self, other) -> Self:
        return self.ioperate_2(operator.__itruediv__, other)


Vector.x_axis = Vector(1, 0, 0)
Vector.x_axis = Vector(1, 0, 0)
Vector.y_axis = Vector(0, 1, 0)
Vector.z_axis = Vector(0, 0, 1)

Vector.left = Vector(-1, 0, 0)
Vector.right = Vector.x_axis
Vector.backward = Vector(0, -1, 0)
Vector.forward = Vector.y_axis
Vector.down = Vector(0, 0, -1)
Vector.up = Vector.z_axis

Vector.x_axis_2d = Vector(1, 0)
Vector.y_axis_2d = Vector(0, 1)
Vector.left_2d = Vector(-1, 0)
Vector.right_2d = Vector.x_axis_2d
Vector.backward_2d = Vector(0, -1)
Vector.forward_2d = Vector.y_axis_2d

Point = Vector


class Rect(Serializable, Shape):
	"""Represents a two-dimensional bounding box."""
	def __init__(self, *args, **kwargs):
		"""@
		#### Example usage:
		```python
		rect = Rect(3, 4) # x 3, width 4
		rect2 = Rect(z=10) # x 0, y 0, z 10, width 0, length 0, height 0
		rect3 = Rect(Vector(y=8), Vector(x = 4)) # x 0, y 8, width 4, length 0
		```
		"""
		
		
		#first half = for position
		half:int = len(args) // 2
		self.p0 = Point(*args[0:half])
		#second half for size
		self.size = Vector(*args[half:])
		
		for kwarg in kwargs.items():
			try:
				offset = self.p0.set_axis(kwarg[0], kwarg[1])
				if offset != None:
					self.size.change_axis_count(offset)
			except ValueError:
				axis_index = Rect.size_axis_index(kwarg[0])
				offset = self.size.set_axis(axis_index, kwarg[1])
				if offset != None:
					self.p0.change_axis_count(offset)
			
		Serializable.__init__(self)
		
	def change_axis_count(self,axis_count: int):
		self.p0.change_axis_count(axis_count)
		self.size.change_axis_count(axis_count)
	
	@staticmethod
	def size_axis_index(axis)->int:
		return ["width", "length", "height"].index(axis)
	
	@property
	def width(self):
		return self.size.x
	@width.setter
	def width(self, value):
		self.size.x = value
		
	@property
	def length(self):
		return self.size.y
	@length.setter
	def length(self, value):
		self.size.y = value

	@property
	def height(self):
		return self.size.z
	@height.setter
	def height(self, value):
		self.size.z = value
	
	@property
	def center(self):
		return self.p0 + self.size * 0.5
	@center.setter
	def center(self, value):
		self.p0 = value - (self.size * 0.5)
	centroid = center

	@property
	def x(self):
		return self.p0.x
	@x.setter
	def x(self, value):
		self.p0.x = value
	@property
	def y(self):
		return self.p0.y
	@y.setter
	def y(self, value):
		self.p0.y = value
	@property
	def z(self):
		return self.p0.z
	@z.setter
	def z(self, value):
		self.p0.z = value
		
	def area(self):
		return self.size.volume()
	@property
	def p1(self):
		return self.p0 + self.size
	
	def __str__(self):
		return __class__.__name__ + '(p0=' + str(self.p0)+',size=' + str(self.size) + ')'
	


	@staticmethod
	def by_points(points: list[Point]) -> 'Rect':
		"""Constructs a bounding box based on a list of points.

		Calculates the minimum and maximum values from the points to define the corners of the bounding box.

		#### Parameters:
		- `points` (list[Point]): A list of Point objects to calculate the bounding box from.

		#### Returns:
		`Rect`: The bounding box instance with updated corners based on the provided points.

		#### Example usage:
		```python
		points = [Point(0, 0, 0), Point(2, 2, 0), Point(2, 0, 0), Point(0, 2, 0)]
		bbox = Rect().by_points(points)
		# Rect with corners at (0, 0, 0), (2, 2, 0), (2, 0, 0), and (0, 2, 0)
		```
		"""
		
		axis_count = len(points[0])
		if axis_count == 0: raise ValueError("please provide points")
		
		#copy
		p0 = Point(points[0])
		p1 = Point(points[0])
		
		#it's faster to not skip the first point than to check if it's the first point or revert to an index-based loop
		for p in points:
			for axis in range(axis_count):
				p0[axis] = min(p0[axis], p[axis])
				p1[axis] = max(p1[axis], p[axis])
		return Rect(p0, p1 - p0)
	
	def expanded(self, border_size: float) -> 'Rect':
		return Rect(self.p0 - border_size, self.size + border_size * 2)
	
	@staticmethod
	def centered_at_origin(size: Vector) -> 'Rect':
		"""Constructs a rect with specified dimensions, centered at the origin.

		#### Parameters:
		- `size` (Vector): The size of the bounding box.

		#### Returns:
		`Rect`: The bounding box instance with dimensions centered at the origin.

		#### Example usage:
		```python
		bbox = Rect().centered_at_origin(length=100, width=50)
		# Rect centered at origin with specified length and width
		```
		"""
		
		return Rect(size * -0.5, size)
	
	@staticmethod
	def by_size(size:Vector)->'Rect':
		"""Constructs a rect with specified dimensions, with its pos0 at the origin.

		#### Parameters:
		- `size` (Vector): The size of the rectangle

		#### Returns:
		`Rect`: The rect instance with dimensions centered at the origin.

		#### Example usage:
		```python
		rect = Rect().by_size(length=100, width=50)
		# Rect(x=0, y=0, width = 100, length = 100)
		```
		"""
		return Rect(Vector([0] * len(size)), size)
	
	def collides(self, other:'Rect')->bool:
		"""checks if two rectangles collide with eachother. <br>
		when they touch eachother exactly (f.e. a Rect with position [0] and size [1] and a rect with position [1] and size [1]), the function will return false.

		Args:
			other (Rect): the rectangle which may collide with this rectangle

		Returns:
			bool: true if the two rectangles overlap
		"""
		for axis in range(len(self.p0)):
			if self.p0[axis] + self.size[axis] <= other.p0[axis] or other.p0[axis] + other.size[axis] <= self.p0[axis]:
				return False
		return True
	
	def contains(self, other:'Rect')->bool:
		for axis in range(len(self.p0)):
			if other.p0[axis] < self.p0[axis] or other.p0[axis] + other.size[axis] > self.p0[axis] + self.size[axis]:
				return False
		return True
	
	def substractFrom(self, other:'Rect')->list['Rect']:
		"""cut the 'other' rectangle in pieces by substracting this rectangle from it

		Args:
			other (Rect): the rectangle to substract this rectangle from

		Returns:
			list[Rect]: a list of up to 4 rectangles for 2d (if the rect is in the center). CAUTION: THEY OVERLAP!
		"""
		pieces:list[Rect] = []
		to_clone = other
		#check each axis
		for axis in range(len(self.p0)):
			self_p1 = self.p0[axis] + self.size[axis]
			other_p1 = other.p0[axis] + other.size[axis]
			if self_p1 < other_p1:
				diff = other_p1 - self_p1
				
				piece:Rect = copy.deepcopy(to_clone)
				
				piece.p0[axis] = self_p1
				
				piece.size[axis] = diff
				pieces.append(piece)
				#also crop other.
				#to_clone.size[axis] -= diff
			self_p0 = self.p0[axis]
			other_p0 = other.p0[axis]
			if self_p0 > other_p0:
				diff = self_p0 - other_p0
				piece:Rect = copy.deepcopy(to_clone)
				piece.size[axis] = diff
				pieces.append(piece)
				#to_clone.p0[axis] = self_p0
				#to_clone.size[axis] -= diff
		return pieces
	
	@staticmethod
	def outer(children: list['Rect']) -> 'Rect':
		"""creates a rectangle containing child rectangles.

		Args:
			children (list[&#39;Rect&#39;]): the children to contain in the rectangle

		Returns:
			Rect: the bounds
		"""
		p0 = children[0].p0
		p1 = children[0].p1
		for i in range(1,len(children)):
			child = children[i]
			for axis_index in range(len(p0)):
				p0[axis_index] = min(child.p0[axis_index], p0[axis_index])
				p1[axis_index] = max(child.p0[axis_index] + child.size[axis_index], p1[axis_index])
		return Rect(p0, p1 - p0)
				
	
	def get_corner(self, corner_index: int) -> Point:
		"""

		Args:
			corner_index (int): corners are ordered like 0 -> 000, 1 -> 001, 2 -> 010, 011, 100 etc.
			where 0 = the minimum and 1 = the maximum

		Returns:
			Point: a corner
		"""
		corner : Point = Point()
		for axis in range(len(self)):
			corner.append(self.p0[axis] + self.size[axis] if corner_index & 1 << axis else self.p0[axis])
		return corner
		

	def corners(self, axis_count = None) -> 'list[Point]':
		"""Calculates the corners of the bounding.

		#### Returns:
		`list[Point]`: A list of Point objects representing the corners of the bounding box.

		#### Example usage:
		```python
		bbox3d = Rect(Point(1, 1, 1), Vector(2, 2, 2))
		corners = bbox3d.corners()
		Returns a list of eight points representing the corners of the bounding box
		```
		"""
		corners:list[Point] = []
		if axis_count == None:
			axis_count = len(self.p0)
		for corner_index in range(2 << axis_count):
			corners.append(self.get_corner(corner_index))
		return corners

class PointList(Vector[Vector]):
	"""Represents a collection of points in space as a point cloud."""
	
	def __init__(self, points: list) -> 'PointList':
		"""Initializes a PointList object with a list of points.

		#### Parameters:
		- `points` (list): An optional list of points to initialize the point cloud. Each point can be an instance of a Point class or a tuple/list of coordinates.

		Initializes the PointList's attributes and sets up the list of points based on the input provided. The ID is generated to uniquely identify the point cloud.
		"""
		super().__init__(points)
		
	
	#just execute the operator for all list members
	def operate_2(self, op:operator, other):
		return self.__class__([self[index].operate_2(op, other) for index in range(len(self))])
	
	def ioperate_2(self, op:operator, other):
		for index in range(len(self)):
			self[index].ioperate_2(op, other)
		return self

	def operate_1(self, op:operator):
		return self.__class__([self[index].operate_1(op) for index in range(len(self))])
	
	@property
	def bounds(self) -> 'Rect':
		return Rect.by_points(self)

#alternative naming
PointCloud = PointList



class Matrix(Serializable, list[list]):
    """
    elements are ordered like [row][column] or [y][x]
    """

    def __init__(self, matrix: list[list] = [[1, 0], [0, 1]]) -> "Matrix":
        list.__init__(self, matrix)

    @property
    def cols(self) -> "int":
        """returns the width (x size) of this matrix in columns."""
        return len(self[0])

    @property
    def rows(self) -> "int":
        """returns the height (y size) of this matrix in columns."""
        return len(self)

    @property
    def dimensions(self) -> int:
        return len(self) - 1

    def get_row(self, row: int) -> Vector:
        """

        Args:
                col (int): the row index

        Returns:
                Vector: a row vector
        """
        return Vector(self[row])

    def get_col(self, col: int) -> Vector:
        """

        Args:
                col (int): the column index

        Returns:
                Vector: a column vector
        """
        return Vector([self[row][col] for row in range(self.rows)])

    @property
    def origin(self) -> Vector:
        col = self.cols - 1
        return Vector([self[row][col] for row in range(self.rows - 1)])

    def get_axis(self, axis_index: int) -> Vector:
        """

        Args:
            axis (_type_): _description_

        Returns:
            Vector: the vector you'd get if you multiplied a vector containing all 0's except 1 on this axis without translation with the matrix.
            for example: m.multiply_without_translation(Vector(0, 0, 1)) == m.get_axis(2)
        """
        return Vector([self[row][axis_index] for row in range(self.rows - 1)])

    position = origin

    @staticmethod
    def scale(scalar: Vector) -> "Matrix":
        """

        Args:
                dimensions (int): the amount of dimensions of this scaling matrix. is it 2d? 3d?
                scalar (float): _description_

        Returns:
                Matrix: a scaling matrix of size (dimensions + 1, dimensions + 1)
        """
        dimensions = len(scalar)
        match dimensions:
            case 1:
                arr = [[scalar[0], 0], [0, 1]]
            case 2:
                arr = [[scalar[0], 0, 0], [0, scalar[1], 0], [0, 0, 1]]
            case 3:
                arr = [
                    [scalar[0], 0, 0, 0],
                    [0, scalar[1], 0, 0],
                    [0, 0, scalar[2], 0],
                    [0, 0, 0, 1],
                ]
            case _:
                arr = [
                    [
                        (
                            (
                                scalar[row]
                                if row < dimensions and col < dimensions
                                else 1
                            )
                            if row == col
                            else 0
                        )
                        for col in range(dimensions + 1)
                    ]
                    for row in range(dimensions + 1)
                ]
        return Matrix(arr)

    @staticmethod
    def empty(rows: int, cols=None):
        """creates a matrix of size n x m (rows x columns or y * x or h * w)"""
        if cols == None:
            cols = rows
        return Matrix([[0 for col in range(cols)] for row in range(rows)])

    @staticmethod
    def identity(dimensions: int) -> "Matrix":
        return Matrix.scale(Vector([1] * (dimensions + 1)))

    @staticmethod
    def translate(addition: Vector) -> "Matrix":
        """

        Args:
                origin (Vector): the matrix translates all points by this offset.

        Returns:
                Matrix:
        """
        matrix_size: int = len(addition) + 1
        return Matrix(
            [
                [
                    1 if col == row else addition[row] if col == len(addition) else 0
                    for col in range(matrix_size)
                ]
                for row in range(matrix_size)
            ]
        )

    by_origin = translate

    @staticmethod
    def by_origin_and_axes(origin: Point, axes: list[Vector]) -> "Matrix":
        """

        Args:
                origin (Point): the translation vector of this matrix
                axes (list[Vector]): the x, y and other axes of this matrix

        Returns:
                Matrix: a matrix with columns ordered like this:
                axes[0], axes[1], ..., axes[n], origin
                the bottom row is just an identity row.
        """
        matrix_size = len(axes) + 1
        return Matrix(
            [
                # copied columns
                (
                    [
                        axes[col][row] if col < len(axes) else origin[row]
                        for col in range(matrix_size)
                    ]
                    if row < len(origin)
                    else
                    # identity row
                    [0 if col < len(axes) else 1 for col in range(matrix_size)]
                )
                for row in range(matrix_size)
            ]
        )

    @staticmethod
    def by_origin_unit_axes(origin: Point, unit_axes: list[Vector]) -> "Matrix":
        """

        Args:
                origin (Point): the origin of the matrix. all points will get translated by this vector.
                unit_axes (list[Vector]): the axes of this matrix, as unit vectors. they will get normalized!

        Returns:
                Matrix: the final matrix
        """
        return Matrix.by_origin_and_axes(
            origin, axes=[axis.normalized for axis in unit_axes]
        )

    @staticmethod
    def rotate(angle: float, axis: Vector = None, pivot: Vector = None) -> "Matrix":
        """creates a rotation matrix to rotate something over the origin around an axis by a specified angle

        Returns:
                Matrix: a rotation matrix. when a point is multiplied with this matrix, it's rotated.
        """
        cos_angle = math.cos(angle)
        sin_angle = math.sin(angle)
        if axis == None:
            # when no pivot and no axis is specified, we assume a 2d rotation matrix is desired, since it doesn't make sense to rotate a 3d vector without specifying an axis.
            if pivot == None or len(pivot) == 2:
                origin_matrix = Matrix(
                    [[cos_angle, -sin_angle, 0], [sin_angle, cos_angle, 0], [0, 0, 1]]
                )
            else:
                origin_matrix = Matrix(
                    [
                        [cos_angle, -sin_angle, 0, 0],
                        [sin_angle, cos_angle, 0, 0],
                        [0, 0, 1, 0],
                        [0, 0, 0, 1],
                    ]
                )
        else:
            # https://stackoverflow.com/questions/6721544/circular-rotation-around-an-arbitrary-axis
            normalized_axis = axis.normalized
            one_min_cos = 1 - cos_angle
            origin_matrix = Matrix(
                [
                    [
                        cos_angle + normalized_axis.x * normalized_axis.x * one_min_cos,
                        normalized_axis.x * normalized_axis.y * one_min_cos
                        - normalized_axis.z * sin_angle,
                        normalized_axis.x * normalized_axis.z * one_min_cos
                        + normalized_axis.y * sin_angle,
                    ],
                    [
                        normalized_axis.y * normalized_axis.x * one_min_cos
                        + normalized_axis.z * sin_angle,
                        cos_angle + normalized_axis.y * normalized_axis.y * one_min_cos,
                        normalized_axis.y * normalized_axis.z * one_min_cos
                        - normalized_axis.x * sin_angle,
                    ],
                    [
                        normalized_axis.z * normalized_axis.x * one_min_cos
                        - normalized_axis.y * sin_angle,
                        normalized_axis.z * normalized_axis.y * one_min_cos
                        + normalized_axis.x * sin_angle,
                        cos_angle + normalized_axis.z * normalized_axis.z * one_min_cos,
                    ],
                ]
            )
        if pivot == None:
            return origin_matrix
        else:
            # from right to left:
            # - translate objects so the pivot is at the origin
            # - rotate objects around the origin
            # - translate objects back so the pivot is at its old location

            return Matrix.translate(pivot) * origin_matrix * Matrix.translate(-pivot)

    def __mul__(self, other: "Matrix | Vector | Rect | PointList"):
        """CAUTION! MATRICES NEED TO MULTIPLY FROM RIGHT TO LEFT!
        for example: translate * rotate (rotate first, translate after)
        and: matrix * point (point first, multiplied by matrix after)"""
        if isinstance(other, Matrix):
            # multiply matrices with eachother
            # https://www.geeksforgeeks.org/multiplication-two-matrices-single-line-using-numpy-python/

            # visualisation of resulting sizes:
            # https://en.wikipedia.org/wiki/Matrix_multiplication

            # the number of columns (width) in the first matrix needs to be equal to the number of rows (height) in the second matrix
            # (look at for i in range(other.height))

            # we are multiplying row vectors of self with col vectors of other
            if self.cols == other.rows:
                resultRows = self.rows
                resultCols = other.cols
                result: Matrix = Matrix.empty(resultRows, resultCols)
                # explicit for loops
                for row in range(self.rows):
                    for col in range(other.cols):
                        for multiplyIndex in range(other.rows):
                            # this is the simple code, which would work if the number of self.cols was equal to other.rows
                            result[row][col] += (
                                self[row][multiplyIndex] * other[multiplyIndex][col]
                            )
            else:
                resultCols = max(self.cols, other.cols)
                resultRows = max(self.rows, other.rows)

                result: Matrix = Matrix.empty(resultRows, resultCols)

                # the size of the vector that we're multiplying.
                multiplyVectorSize = max(self.cols, other.rows)

                # explicit for loops
                for row in range(resultRows):
                    for col in range(resultCols):
                        for multiplyIndex in range(multiplyVectorSize):
                            # if an element doesn't exist in the matrix, we use an identity element.
                            selfValue = (
                                self[row][multiplyIndex]
                                if row < self.rows and multiplyIndex < self.cols
                                else 1 if multiplyIndex == row else 0
                            )
                            otherValue = (
                                other[multiplyIndex][col]
                                if col < other.cols and multiplyIndex < other.rows
                                else 1 if multiplyIndex == col else 0
                            )
                            result[row][col] += selfValue * otherValue

        elif isinstance(other, PointList):
            return other.__class__([self * p for p in other])
        # point comes in from top and comes out to the right:
        # |
        # v
        # a b
        # c d ->
        elif isinstance(other, Vector):
            result: Vector = Vector([0] * len(other))
            # loop over column vectors and multiply them with the vector. sum the results (multiplied col 1 + multiplied col 2) to get the final product!
            for col in range(self.cols):
                if col < len(other):
                    for row in range(len(result)):
                        result[row] += self[row][col] * other[col]
                else:
                    # otherValue = 1, just add the vector
                    for row in range(len(result)):
                        result[row] += self[row][col]
            return result
        elif isinstance(other, Rect):
            mp0 = self * other.p0
            mp1 = self * other.p1
            return Rect.by_points([mp0, mp1])
        else:
            # this causes python to check for rmul on the other type
            return NotImplemented
        return result

    transform = multiply = __mul__

    def multiply_without_translation(self, other: Vector) -> Vector:
        """this function just multiplies the coords by the matrix, but doesn't add anything to the result. good for sizes for example.

        Args:
                other (Vector): _description_

        Returns:
                _type_: _description_
        """
        result: Vector = Vector([0] * self.rows)
        for col in range(min(self.cols, len(other))):
            for row in range(self.rows):
                result[row] += self[row][col] * other[col]
        return result

    def get_col(self, col_index: int):
        return Vector([row[col_index] for row in self])

    def get_row(self, row_index: int):
        return Vector(self[row_index])

    @property
    def translation(self) -> Vector:
        """the translation is just the last column of the matrix

        Returns:
                Vector: the last column of this matrix, which gets added to the result when a point is multiplied by the matrix
        """
        return self.get_col(self.cols - 1)

    def cofactor(self, i: int, j: int) -> float:
        """Calculates the cofactor of element at position (i, j)."""
        minor_matrix = self.minor(i, j)
        return ((-1) ** (i + j)) * minor_matrix.determinant()

    def cofactor_matrix(self) -> "Matrix":
        """Returns the cofactor matrix."""
        return Matrix(
            [[self.cofactor(i, j) for j in range(self.cols)] for i in range(self.rows)]
        )

    def adjugate(self) -> "Matrix":
        """Returns the adjugate (or adjoint) of the matrix."""
        return self.cofactor_matrix().transpose()

    def determinant(self) -> float:
        """Calculates the determinant of the matrix."""
        if self.rows != self.cols:
            raise ValueError("Matrix must be square to compute determinant.")
        if self.rows == 1:
            return self[0][0]
        if self.rows == 2:
            return self[0][0] * self[1][1] - self[0][1] * self[1][0]

        det = 0
        for c in range(self.cols):
            det += ((-1) ** c) * self[0][c] * self.minor(0, c).determinant()
        return det

    def minor(self, row_index: int, col_index: int) -> "Matrix":
        """Returns the minor of the matrix by removing the i-th row and j-th column."""
        return Matrix(
            [
                row[:col_index] + row[col_index + 1 :]
                for row in (self[:row_index] + self[row_index + 1 :])
            ]
        )

    def inverse(self) -> "Matrix":
        """Returns the inverse of the matrix if it exists."""

        determinant = self.determinant()
        if determinant == 0:
            raise ValueError("Matrix is not invertible (determinant is zero).")

        adjugate = self.adjugate()
        return Matrix([[element / determinant for element in row] for row in adjugate])

    def add(self, other: "Matrix"):
        if self.shape() != other.shape():
            raise ValueError("Matrices must have the same dimensions")
        return Matrix(
            [
                [self[i][j] + other.matrix[i][j] for j in range(len(self[0]))]
                for i in range(len(self))
            ]
        )

    def all(self, axis=None):
        if axis is None:
            return all(all(row) for row in self)
        elif axis == 0:
            return [
                all(self[row][col] for row in range(len(self)))
                for col in range(len(self[0]))
            ]
        elif axis == 1:
            return [all(col) for col in self]
        else:
            raise ValueError("Axis must be None, 0, or 1")

    def any(self, axis=None):
        if axis is None:
            return any(any(row) for row in self)
        elif axis == 0:
            return [
                any(self[row][col] for row in range(len(self)))
                for col in range(len(self[0]))
            ]
        elif axis == 1:
            return [any(col) for col in self]
        else:
            raise ValueError("Axis must be None, 0, or 1")

    def argmax(self, axis=None):
        if axis is None:
            flat_list = [item for sublist in self for item in sublist]
            return flat_list.index(max(flat_list))
        elif axis == 0:
            return [
                max(range(len(self)), key=lambda row: self[row][col])
                for col in range(len(self[0]))
            ]
        elif axis == 1:
            return [max(range(len(row)), key=lambda col: row[col]) for row in self]
        else:
            raise ValueError("Axis must be None, 0, or 1")

    def argmin(self, axis=None):
        if axis is None:
            flat_list = [item for sublist in self for item in sublist]
            return flat_list.index(min(flat_list))
        elif axis == 0:
            return [
                min(range(len(self)), key=lambda row: self[row][col])
                for col in range(len(self[0]))
            ]
        elif axis == 1:
            return [min(range(len(row)), key=lambda col: row[col]) for row in self]
        else:
            raise ValueError("Axis must be None, 0, or 1")

    def argpartition(self, kth, axis=0):
        def partition(arr, kth):
            pivot = arr[kth]
            less = [i for i in range(len(arr)) if arr[i] < pivot]
            equal = [i for i in range(len(arr)) if arr[i] == pivot]
            greater = [i for i in range(len(arr)) if arr[i] > pivot]
            return less + equal + greater

        if axis == 0:
            return [
                partition([self[row][col] for row in range(len(self))], kth)
                for col in range(len(self[0]))
            ]
        elif axis == 1:
            return [partition(row, kth) for row in self]

    def argsort(self, axis=0):
        if axis == 0:
            return [
                [row for row, val in sorted(enumerate(col), key=lambda x: x[1])]
                for col in zip(*self)
            ]
        elif axis == 1:
            return [list(range(len(self[0]))) for _ in self]

    def astype(self, dtype):
        cast_matrix = [[dtype(item) for item in row] for row in self]
        return Matrix(cast_matrix)

    def byteswap(self, inplace=False):
        if inplace:
            for i in range(len(self)):
                for j in range(len(self[i])):
                    self[i][j] = ~self[i][j]
            return self
        else:
            new_matrix = [[~item for item in row] for row in self]
            return Matrix(new_matrix)

    def choose(self, choices, mode="raise"):
        if mode != "raise":
            raise NotImplementedError("Only 'raise' mode is implemented")

        chosen = [[choices[item] for item in row] for row in self]
        return Matrix(chosen)

    def compress(self, condition, axis=None):
        if axis == 0:
            compressed = [row for row, cond in zip(self, condition) if cond]
            return Matrix(compressed)
        else:
            raise NotImplementedError("Axis other than 0 is not implemented")

    def clip(self, min=None, max=None):
        clipped_matrix = []
        for row in self:
            clipped_row = [
                (
                    max
                    if max is not None and val > max
                    else min if min is not None and val < min else val
                )
                for val in row
            ]
            clipped_matrix.append(clipped_row)
        return Matrix(clipped_matrix)

    def conj(self):
        conjugated_matrix = [
            [complex(item).conjugate() for item in row] for row in self
        ]
        return Matrix(conjugated_matrix)

    def conjugate(self):
        return self.conj()

    def copy(self):
        copied_matrix = copy.deepcopy(self)
        return Matrix(copied_matrix)

    def cumprod(self, axis=None):
        if axis is None:
            flat_list = self.flatten()
            cumprod_list = []
            cumprod = 1
            for item in flat_list:
                cumprod *= item
                cumprod_list.append(cumprod)
            return Matrix([cumprod_list])
        else:
            raise NotImplementedError("Axis handling not implemented in this example")

    def cumsum(self, axis=None):
        if axis is None:
            flat_list = self.flatten()
            cumsum_list = []
            cumsum = 0
            for item in flat_list:
                cumsum += item
                cumsum_list.append(cumsum)
            return Matrix([cumsum_list])
        else:
            raise NotImplementedError("Axis handling not implemented in this example")

    def diagonal(self, offset=0):
        return [
            self[i][i + offset]
            for i in range(len(self))
            if 0 <= i + offset < len(self[i])
        ]

    def dump(self, file):
        with open(file, "wb") as f:
            pickle.dump(self, f)

    def dumps(self):
        return pickle.dumps(self)

    def fill(self, value):
        for i in range(len(self)):
            for j in range(len(self[i])):
                self[i][j] = value

    @staticmethod
    def from_points(from_point: Point, to_point: Point):
        Vz = Vector.by_two_points(from_point, to_point)
        Vz = Vz.normalized
        Vzglob = Vector(0, 0, 1)
        Vx = Vector.cross_product(Vz, Vzglob)
        if Vx.length == 0:
            Vx = Vector(1, 0, 0) if Vz.x != 1 else Vector(0, 1, 0)
        Vx = Vx.normalized
        Vy = Vector.cross_product(Vx, Vz)

        return Matrix(
            [
                [Vx.x, Vy.x, Vz.x, from_point.x],
                [Vx.y, Vy.y, Vz.y, from_point.y],
                [Vx.z, Vy.z, Vz.z, from_point.z],
                [0, 0, 0, 1],
            ]
        )

    def flatten(self):
        return [item for sublist in self for item in sublist]

    def getA(self):
        return self

    def getA1(self):
        return [item for sublist in self for item in sublist]

    def getH(self):
        conjugate_transposed = [
            [complex(self[j][i]).conjugate() for j in range(len(self))]
            for i in range(len(self[0]))
        ]
        return Matrix(conjugate_transposed)

    def getI(self):
        raise NotImplementedError(
            "Matrix inversion is a complex operation not covered in this simple implementation."
        )

    def getT(self):
        return self.transpose()

    def getfield(self, dtype, offset=0):
        raise NotImplementedError(
            "This method is conceptual and depends on structured data support within the Matrix."
        )

    def item(self, *args):
        if len(args) == 1:
            index = args[0]
            rows, cols = len(self), len(self[0])
            return self[index // cols][index % cols]
        elif len(args) == 2:
            return self[args[0]][args[1]]
        else:
            raise ValueError("Invalid number of indices.")

    def itemset(self, *args):
        if len(args) == 2:
            index, value = args
            rows, cols = len(self), len(self[0])
            self[index // cols][index % cols] = value
        elif len(args) == 3:
            row, col, value = args
            self[row][col] = value
        else:
            raise ValueError("Invalid number of arguments.")

    def max(self, axis=None):
        if axis is None:
            return max(item for sublist in self for item in sublist)
        elif axis == 0:
            return [
                max(self[row][col] for row in range(len(self)))
                for col in range(len(self[0]))
            ]
        elif axis == 1:
            return [max(row) for row in self]
        else:
            raise ValueError("Invalid axis.")

    def mean(self, axis=None):
        if axis is None:
            flat_list = self.flatten()
            return sum(flat_list) / len(flat_list)
        elif axis == 0:
            return [
                sum(self[row][col] for row in range(len(self))) / len(self)
                for col in range(len(self[0]))
            ]
        elif axis == 1:
            return [sum(row) / len(row) for row in self]
        else:
            raise ValueError("Axis must be None, 0, or 1")

    def min(self, axis=None):
        if axis is None:
            return min(item for sublist in self for item in sublist)
        elif axis == 0:
            return [
                min(self[row][col] for row in range(len(self)))
                for col in range(len(self[0]))
            ]
        elif axis == 1:
            return [min(row) for row in self]
        else:
            raise ValueError("Invalid axis.")

    @staticmethod
    def zeros(rows, cols):
        return Matrix([[0 for _ in range(cols)] for _ in range(rows)])

    @staticmethod
    def participation(self):
        pass

    def prod(self, axis=None):
        if axis is None:
            return reduce(
                lambda x, y: x * y, [item for sublist in self for item in sublist], 1
            )
        elif axis == 0:
            return [
                reduce(
                    lambda x, y: x * y, [self[row][col] for row in range(len(self))], 1
                )
                for col in range(len(self[0]))
            ]
        elif axis == 1:
            return [reduce(lambda x, y: x * y, row, 1) for row in self]
        else:
            raise ValueError("Invalid axis.")

    def ptp(self, axis=None):
        if axis is None:
            flat_list = [item for sublist in self for item in sublist]
            return max(flat_list) - min(flat_list)
        elif axis == 0:
            return [
                max([self[row][col] for row in range(len(self))])
                - min([self[row][col] for row in range(len(self))])
                for col in range(len(self[0]))
            ]
        elif axis == 1:
            return [max(row) - min(row) for row in self]
        else:
            raise ValueError("Invalid axis.")

    def put(self, indices, values):
        if len(indices) != len(values):
            raise ValueError("Length of indices and values must match.")
        flat_list = self.ravel()
        for index, value in zip(indices, values):
            flat_list[index] = value

    @staticmethod
    def random(rows, cols):
        import random

        return Matrix([[random.random() for _ in range(cols)] for _ in range(rows)])

    def ravel(self):
        return [item for sublist in self for item in sublist]

    def repeat(self, repeats, axis=None):
        if axis is None:
            flat_list = self.ravel()
            repeated = [item for item in flat_list for _ in range(repeats)]
            return Matrix([repeated])
        elif axis == 0:
            repeated_matrix = [row for row in self for _ in range(repeats)]
        elif axis == 1:
            repeated_matrix = [
                [item for item in row for _ in range(repeats)] for row in self
            ]
        else:
            raise ValueError("Invalid axis.")
        return Matrix(repeated_matrix)

    def reshape(self, rows, cols):
        flat_list = self.flatten()
        if len(flat_list) != rows * cols:
            raise ValueError("The total size of the new array must be unchanged.")
        reshaped = [flat_list[i * cols : (i + 1) * cols] for i in range(rows)]
        return Matrix(reshaped)

    def resize(self, new_rows, new_cols):
        return Matrix(
            [
                [
                    (
                        self[row][col]
                        if (col < self.cols and row < self.rows)
                        else (1 if row == col else 0)
                    )
                    for col in range(new_cols)
                ]
                for row in range(new_rows)
            ]
        )

    def round(self, decimals=0):
        rounded_matrix = [[round(item, decimals) for item in row] for row in self]
        return Matrix(rounded_matrix)

    def searchsorted(self, v, side="left"):
        flat_list = self.flatten()
        i = 0
        if side == "left":
            while i < len(flat_list) and flat_list[i] < v:
                i += 1
        elif side == "right":
            while i < len(flat_list) and flat_list[i] <= v:
                i += 1
        else:
            raise ValueError("side must be 'left' or 'right'")
        return i

    def setfield(self, val, dtype, offset=0):
        raise NotImplementedError(
            "Structured data operations are not supported in this Matrix class."
        )

    def setflags(self, write=None, align=None, uic=None):
        print("This Matrix class does not support setting flags directly.")

    def shape(self):
        return len(self), len(self[0])

    def sort(self, axis=-1):
        if axis == -1 or axis == 1:
            for row in self:
                row.sort()
        elif axis == 0:
            transposed = [
                [self[j][i] for j in range(len(self))] for i in range(len(self[0]))
            ]
            for row in transposed:
                row.sort()
            self = [
                [transposed[j][i] for j in range(len(transposed))]
                for i in range(len(transposed[0]))
            ]
        else:
            raise ValueError("Axis out of range.")

    def squeeze(self):
        squeezed_matrix = [row for row in self if any(row)]
        return Matrix(squeezed_matrix)

    def std(self, axis=None, ddof=0):
        var = self.var(axis=axis, ddof=ddof)
        if isinstance(var, list):
            return [x**0.5 for x in var]
        else:
            return var**0.5

    def subtract(self, other):
        if self.shape() != other.shape():
            raise ValueError("Matrices must have the same dimensions")
        return Matrix(
            [
                [self[i][j] - other.matrix[i][j] for j in range(len(self[0]))]
                for i in range(len(self))
            ]
        )

    def sum(self, axis=None):
        if axis is None:
            return sum(sum(row) for row in self)
        elif axis == 0:
            return [
                sum(self[row][col] for row in range(len(self)))
                for col in range(len(self[0]))
            ]
        elif axis == 1:
            return [sum(row) for row in self]
        else:
            raise ValueError("Axis must be None, 0, or 1")

    def swapaxes(self, axis1, axis2):
        if axis1 == 0 and axis2 == 1 or axis1 == 1 and axis2 == 0:
            return Matrix(
                [[self[j][i] for j in range(len(self))] for i in range(len(self[0]))]
            )
        else:
            raise ValueError("Axis values out of range for a 2D matrix.")

    def take(self, indices, axis=None):
        if axis is None:
            flat_list = [item for sublist in self for item in sublist]
            return Matrix([flat_list[i] for i in indices])
        elif axis == 0:
            return Matrix([self[i] for i in indices])
        else:
            raise ValueError("Axis not supported or out of range for a 2D matrix.")

    def tofile(self, fid, sep="", format="%s"):
        if isinstance(fid, str):
            with open(fid, "wb" if sep == "" else "w") as f:
                self._write_to_file(f, sep, format)
        else:
            self._write_to_file(fid, sep, format)

    def _write_to_file(self, file, sep, format):
        if sep == "":
            file.write(self.tobytes())
        else:
            for row in self:
                line = sep.join(format % item for item in row) + "\n"
                file.write(line)

    def __str__(self):
        # '\n'.join([str(row) for row in self])
        # vs code doesn't work with new lines
        return "Matrix(" + list.__str__(self) + ")"

    def trace(self, offset=0):
        rows, cols = len(self), len(self[0])
        return sum(
            self[i][i + offset]
            for i in range(min(rows, cols - offset))
            if 0 <= i + offset < cols
        )

    def transpose(self):
        transposed = [
            [self[j][i] for j in range(len(self))] for i in range(len(self[0]))
        ]
        return Matrix(transposed)

    def var(self, axis=None, ddof=0):
        if axis is None:
            flat_list = self.flatten()
            mean = sum(flat_list) / len(flat_list)
            return sum((x - mean) ** 2 for x in flat_list) / (len(flat_list) - ddof)
        elif axis == 0 or axis == 1:
            means = self.mean(axis=axis)
            if axis == 0:
                return [
                    sum((self[row][col] - means[col]) ** 2 for row in range(len(self)))
                    / (len(self) - ddof)
                    for col in range(len(self[0]))
                ]
            else:
                return [
                    sum((row[col] - means[idx]) ** 2 for col in range(len(row)))
                    / (len(row) - ddof)
                    for idx, row in enumerate(self)
                ]
        else:
            raise ValueError("Axis must be None, 0, or 1")

    def _validate(self):
        rows = len(self)
        cols = len(self[0]) if rows > 0 else 0
        return rows, cols


CoordinateSystem = Matrix



class Plane:
	# Plane is an infinite element in space defined by a point and a normal
	"""The `Plane` class represents an infinite plane in 3D space, defined uniquely by an origin point and a normal vector, along with two other vectors lying on the plane, providing a complete basis for defining plane orientation and position."""
	def __init__(self):
		""""Initializes a new Plane instance.

		- `Origin` (Point): The origin point of the plane, which also lies on the plane.
		- `Normal` (Vector): A vector perpendicular to the plane, defining its orientation.
		- `v1` (Vector): A vector lying on the plane, typically representing the "x" direction on the plane.
		- `v2` (Vector): Another vector on the plane, perpendicular to `v1` and typically representing the "y" direction on the plane.
		"""
		self.Origin = Point(0, 0, 0)
		self.Normal = Vector(x=0, y=0, z=1)
		self.vector_1 = Vector(x=1, y=0, z=0)
		self.vector_2 = Vector(x=0, y=1, z=0)

	@classmethod
	def by_two_vectors_origin(cls, vector_1: Vector, vector_2: Vector, origin: Point) -> 'Plane':
		"""Creates a Plane defined by two vectors and an origin point.
		This method establishes a plane using two vectors that lie on the plane and an origin point. The normal is calculated as the cross product of the two vectors, ensuring it is perpendicular to the plane.

		#### Parameters:
			vector_1 (Vector): The first vector on the plane.
			vector_2 (Vector): The second vector on the plane, should not be parallel to vector_1.
			origin (Point): The origin point of the plane, lying on the plane.

		#### Returns:
			Plane: A Plane instance defined by the given vectors and origin.
		
		#### Example usage:
		```python

		```
		"""
		p1 = Plane()
		p1.Normal = Vector.cross_product(vector_1, vector_2).normalized
		p1.Origin = origin
		p1.vector_1 = vector_1
		p1.vector_2 = vector_2
		return p1

	def __str__(self) -> str:
		"""Generates a string representation of the Plane.

		#### Returns:
			str: A string describing the Plane with its origin, normal, and basis vectors.
		 
		#### Example usage:
		```python

		```
		"""

		return f"{__class__.__name__}(" + f"{self.Origin}, {self.Normal}, {self.vector_1}, {self.vector_2})"

	# TODO
	# byLineAndPoint
	# byOriginNormal
	# byThreePoints




class Sphere(Serializable):
	def __init__(self, point:Point, diameter:int):
		self.point = point
		self.diameter = diameter
		
	def __str__(self) -> str:
		return str(Sphere)

	@staticmethod
	def radius_by_3_points(start:float, mid: float, end: float) -> float:
		a = Point.distance(start, mid)
		b = Point.distance(mid, end)
		c = Point.distance(end, start)
		s = (a + b + c) / 2
		A = math.sqrt(max(s * (s - a) * (s - b) * (s - c), 0))
				
		if abs(A) < 1e-6:
			return float('inf')
		else:
			R = (a * b * c) / (4 * A)
			return R

class Circle:
	"""Represents a circle with a specific radius, plane, and length.
	"""
	def __init__(self, radius: 'float', plane: 'Plane', length: 'float') -> 'Circle':
		"""The Circle class defines a circle by its radius, the plane it lies in, and its calculated length (circumference).

		- `radius` (float): The radius of the circle.
		- `plane` (Plane): The plane in which the circle lies.
		- `length` (float): The length (circumference) of the circle. Automatically calculated during initialization.
		"""
		self.radius = radius
		self.plane = plane
		self.length = length
		
		pass  # Curve

	def __id__(self):
		"""Returns the ID of the Circle.

		#### Returns:
		`str`: The ID of the Circle in the format "id:{self.id}".
		"""

	def __str__(self) -> 'str':
		"""Generates a string representation of the Circle object.

		#### Returns:
		`str`: A string that represents the Circle object.

		#### Example usage:
		```python
		circle = Circle(radius, plane, length)
		print(circle)
		# Output: Circle(...)
		```
		"""


class Ellipse:
	"""Represents an ellipse defined by its two radii and the plane it lies in."""
	def __init__(self, firstRadius: 'float', secondRadius: 'float', plane: 'Plane') -> 'Ellipse':
		"""The Ellipse class describes an ellipse through its major and minor radii and the plane it occupies.
			
		- `firstRadius` (float): The first (major) radius of the ellipse.
		- `secondRadius` (float): The second (minor) radius of the ellipse.
		- `plane` (Plane): The plane in which the ellipse lies.
		"""
		self.firstRadius = firstRadius
		self.secondRadius = secondRadius
		self.plane = plane
		
		pass  # Curve

	def __id__(self):
		"""Returns the ID of the Ellipse.

		#### Returns:
		`str`: The ID of the Ellipse in the format "id:{self.id}".
		"""
		return f"id:{self.id}"

	def __str__(self) -> 'str':
		"""Generates a string representation of the Ellipse object.

		#### Returns:
		`str`: A string that represents the Ellipse object.

		#### Example usage:
		```python
		ellipse = Ellipse(firstRadius, secondRadius, plane)
		print(ellipse)
		# Output: Ellipse(...)
		```
		"""
		return f"{__class__.__name__}({self})"



class Curve(Serializable):
    @property
    @abstractmethod
    def length(self) -> float:
        pass

    @property
    def start(self) -> Point:
        return self.point_at_fraction(0)

    @property
    def mid(self) -> Point:
        return self.point_at_fraction(0.5)

    @property
    def end(self) -> Point:
        return self.point_at_fraction(1)

    @property
    def dimensions(self) -> Point:
        return len(self.start)

    @dimensions.setter
    def dimensions(self, value):
        raise NotImplemented()

    @abstractmethod
    def point_at_fraction(fraction: float) -> Point:
        """
        Args:
            fraction (float): a value from 0 to 1, describing the position in the curve.

        Returns:
            Point: self.start for 0, self.end for 1
        """
        pass

    def segmentate(
        self, settings: SegmentationSettings = SegmentationSettings()
    ) -> "Polygon":
        """

        Args:
            max_angle (float): the maximum angle to keep a straight line. for example, if max_angle = PI/2 and an arc has an angle of PI, it will return 2 line segments.

        Returns:
            list[Point]: a list of points sampled along this line
        """
        segmentated_polygon = Polygon()
        self.segmentate_part(segmentated_polygon, settings)
        segmentated_polygon.append(self.end)
        return segmentated_polygon

    def segmentate_part(
        self, polygon_to_add_to: "Polygon", settings: SegmentationSettings
    ):
        """segmentates this curve as a part of the polygon. will not add self.end to the polygon.

        Args:
            polygon_to_add_to (Polygon): the polygon this curve will be a part of.
        """
        raise NotImplemented()


class Line(Curve):
    def __init__(self, start: Point, end: Point) -> "Line":
        """Initializes a Line object with the specified start and end points.

        - `start` (Point): The starting point of the line segment.
        - `end` (Point): The ending point of the line segment.
        """
        # copy
        """The starting point of the line segment"""
        self._start = Point(start)
        """The ending point of the line segment."""
        self._end = Point(end)

    @property
    def start(self) -> "Point":
        return self._start

    @start.setter
    def start(self, value):
        self._start = value

    @property
    def end(self) -> "Point":
        return self._end

    @end.setter
    def end(self, value):
        self._end = value

    @Curve.dimensions.setter
    def dimensions(self, value):
        self._start.dimensions = value
        self._end.dimensions = value

    @property
    def mid(self) -> "Point":
        """Computes the midpoint of the Line object.

        #### Returns:
        `Point`: The midpoint of the Line object.

        #### Example usage:
        ```python

        ```
        """
        return (self.start + self.end) * 0.5

    @property
    def angle(self) -> float:
        return (self.end - self.start).angle

    @property
    def points(self) -> list[Point]:
        return [Point(self.start), Point(self.end)]

    def segmentate_part(self, polygon_to_add_to: "Polygon", max_angle: float):
        polygon_to_add_to.append(Point(self.start))

    def __rmul__(self, transformer) -> "Line":
        return Line(transformer * self.start, transformer * self.end)

    def point_at_fraction(self, fraction: float) -> Point:
        return self.start * (1 - fraction) + self.end * fraction

    @staticmethod
    def by_start_end(start: "Point", end: "Point") -> "Line":
        return Line(start, end)

    @staticmethod
    def by_startpoint_direction_length(
        start: "Point", direction: "Vector", length: "float"
    ) -> "Line":
        """Creates a line segment starting from a given point in the direction of a given vector with a specified length.

        #### Parameters:
        - `start` (Point): The starting point of the line segment.
        - `direction` (Vector): The direction vector of the line segment.
        - `length` (float): The length of the line segment.

        #### Returns:
        `Line`: A new Line object representing the line segment.

        #### Example usage:
        ```python

        ```
        """
        norm = math.sqrt(direction.x**2 + direction.y**2 + direction.z**2)
        normalized_direction = Vector(
            direction.x / norm, direction.y / norm, direction.z / norm
        )

        end_x = start.x + normalized_direction.x * length
        end_y = start.y + normalized_direction.y * length
        end_z = start.z + normalized_direction.z * length
        end_point = Point(end_x, end_y, end_z)

        return Line(start, end_point)

    # @classmethod
    def point_at_parameter(self, interval: "float" = None) -> "Point":
        """Computes the point on the Line object at a specified parameter value.

        #### Parameters:
        - `interval` (float): The parameter value determining the point on the line. Default is None, which corresponds to the midpoint.

        #### Returns:
        `Point`: The point on the Line object corresponding to the specified parameter value.

        #### Example usage:
        ```python

        ```
        """
        if interval == None:
            interval = 0.0
        x1, y1, z1 = self.start.x, self.start.y, self.start.z
        x2, y2, z2 = self.end.x, self.end.y, self.end.z
        if float(interval) == 0.0:
            return self.start
        else:
            devBy = 1 / interval
            return Point((x1 + x2) / devBy, (y1 + y2) / devBy, (z1 + z2) / devBy)

    def intersects(self, other: "Line") -> bool:
        """checks if two lines intersect with eachother.

        Args:
            other (Line): the line which may intersect with this rectangle

        Returns:
            bool: true if the lines cross eachother.
        """
        # ax + b = cx + d
        # ax = cx + d - b
        # ax - cx = d - b
        # (a - c)x = d - b
        # x = (d - b) / (a - c)

        # calculate a and c

        diff_self = self.end - self.start
        diff_other = other.end - other.start
        # a
        slope_self = math.inf if diff_self.x == 0 else diff_self.y / diff_self.x

        # c
        slope_other = math.inf if diff_other.x == 0 else diff_other.y / diff_other.x
        # handle edge cases
        # colinear
        if slope_self == slope_other:
            return False

        # b
        self_y_at_0 = self.start.y - self.start.x * slope_self

        # check if one slope is infinite (both infinite is handled by colinear)
        if other.start.x == other.end.x:
            self_y_at_line = self_y_at_0 + slope_self * other.start.x
            return other.start.y < self_y_at_line < other.end.y

        # d
        other_y_at_0 = other.start.y - other.start.x * slope_other

        if self.start.x == self.end.x:
            other_y_at_line = other_y_at_0 + slope_other * self.start.x
            return self.start.y < other_y_at_line < self.end.y

        intersection_x = (other_y_at_0 - self_y_at_0) / (slope_self - slope_other)

        return self.start.x < intersection_x < self.end.x

    def split(self, points: "Union[Point, list[Point]]") -> "list[Line]":
        """Splits the Line object at the specified point(s).

        #### Parameters:
        - `points` (Point or List[Point]): The point(s) at which the Line object will be split.

        #### Returns:
        `List[Line]`: A list of Line objects resulting from the split operation.

        #### Example usage:
        ```python

        ```
        """
        lines = []
        if isinstance(points, list):
            points.extend([self.start, self.end])
            sorted_points = sorted(points, key=lambda p: p.distance(p, self.end))
            lines = create_lines(sorted_points)
            return lines
        elif isinstance(points, Point):
            point = points
            lines.append(Line(start=self.start, end=point))
            lines.append(Line(start=point, end=self.end))
            return lines

    @property
    def length(self) -> "float":
        """Computes the length of the Line object.

        #### Returns:
        `float`: The length of the Line object.

        #### Example usage:
        ```python

        ```
        """
        return (self.end - self.start).magnitude

    @property
    def direction(self) -> Vector:
        """Computes the direction of the Line object."""
        return (self.end - self.start).normalized

    def __str__(self) -> "str":
        """Returns a string representation of the Line object.

        #### Returns:
        `str`: A string representation of the Line object.

        #### Example usage:
        ```python

        ```
        """
        return f"{__class__.__name__}(" + f"{self.start}, {self.end})"


class Arc(Curve):
    def __init__(self, matrix: "Matrix", angle: float) -> None:
        self.matrix, self.angle = matrix, angle

    @Curve.dimensions.setter
    def dimensions(self, value):
        dimensions = self.dimensions
        if value > dimensions:
            # assuming it's a 4x4 and needs to be a 3x3. remove the 3rd row and column
            self.matrix = self.matrix.minor(value, value)
        else:
            # assuming it's a 3x3 and needs to be a 4x4.
            # insert identity rows
            output_matrix = []

            for row in range(value):
                if row < dimensions - 1:
                    get_row = row
                elif row == value:
                    get_row = dimensions - 1
                else:
                    output_matrix.append([0] * value)
                    continue
                source_row = self.matrix[get_row]
                output_matrix.append(
                    source_row[0 : dimensions - 1]
                    + [0] * (value - dimensions)
                    + source_row[dimensions - 1]
                )

            self.matrix = Matrix(output_matrix)

    @staticmethod
    def by_start_mid_end(start: Point, mid: Point, end: Point) -> "Arc|Line":
        # construct a matrix from a plane
        # x = (start - origin).normalized
        # y
        # https://stackoverflow.com/questions/13977354/build-circle-from-3-points-in-3d-space-implementation-in-c-or-c
        # triangle "edges"
        start_to_mid = mid - start
        start_to_end = end - start
        mid_to_end = end - mid

        # triangle normal
        y_cross = Vector.cross_product(start_to_mid, start_to_end)

        y_length_squared = (
            y_cross.length_squared if len(start) > 2 else y_cross * y_cross
        )
        if y_length_squared < 10e-14:
            return Line(
                start, end
            )  # area of the triangle is too small (you may additionally check the points for colinearity if you are paranoid)

        # helpers
        offset_multiplier = 0.5 / y_length_squared
        # calculate dot products
        tt = Vector.dot_product(start_to_mid, start_to_mid)
        uu = Vector.dot_product(start_to_end, start_to_end)

        # result circle
        origin = (
            start
            + (
                start_to_end * tt * start_to_end.dot_product(mid_to_end)
                - start_to_mid * uu * start_to_mid.dot_product(mid_to_end)
            )
            * offset_multiplier
        )
        # radius = math.sqrt(tt * uu * (mid_to_end*mid_to_end) * iwsl2*0.5)

        x_axis = start - origin
        normalized_x_axis = x_axis.normalized
        radius = x_axis.length

        if len(start) == 2:
            # 2d
            normalized_y_axis = Vector.cross_product(normalized_x_axis)
            arc_matrix = Matrix.by_origin_and_axes(
                origin,
                [
                    x_axis,
                    (normalized_y_axis if y_cross > 0 else -normalized_y_axis) * radius,
                ],
            )
        else:  # 3d

            normalized_z_axis = y_cross / math.sqrt(y_length_squared)
            # TODO: z axis is pointing the other way when the angle is more than PI
            # dot_product = Vector.dot_product(normalized_x_axis, normalized_end_direction)
            # if dot_product >
            normalized_y_axis = Vector.cross_product(
                normalized_z_axis, normalized_x_axis
            )
            # to get the angle, multiply the end point inversely by the matrix and measure its angle.
            arc_matrix = Matrix.by_origin_and_axes(
                origin, [x_axis, normalized_y_axis * radius, normalized_z_axis]
            )
        inverse = arc_matrix.inverse()
        angle = (inverse * end).angle
        if angle < 0:
            angle += math.pi * 2

        return Arc(arc_matrix, angle)

    def segmentate_part(
        self, polygon_to_add_to: "Polygon", settings: SegmentationSettings
    ):
        segment_count = math.ceil(self.angle / settings.max_angle)
        interval = 1.0 / segment_count
        for i in range(segment_count):
            polygon_to_add_to.append(self.point_at_fraction(i * interval))

    @Curve.dimensions.setter
    def dimensions(self, value):
        self.matrix.dimensions

    @property
    def start(self) -> Point:
        """

        Returns:
            Point: the starting point of this arc
        """
        return self.matrix.get_axis(0) + self.matrix.origin

    @property
    def radius(self) -> float:
        """

        Returns:
            Point: the radius of the circle this arc is a part of
        """
        return self.matrix.multiply_without_translation(
            Vector.x_axis if self.matrix.dimensions > 2 else Vector.x_axis_2
        ).magnitude

    @property
    def origin(self) -> Point:
        """

        Returns:
            Point: the center of the circle this arc is a part of
        """
        return self.matrix.translation

    @property
    def length(self) -> float:
        """

        Returns:
            Point: the length of this arc
        """
        return self.angle * self.radius

    def __rmul__(self, transformer) -> "PolyCurve":
        return Arc(transformer * self.matrix, self.angle)

    def point_at_fraction(self, fraction: float):
        """

        #### Example usage:
        ```python
        #counter-clockwise arc with center 0,0
        arc = Arc.by_start_mid_end(Point(-1,0), Point(0,1), Point(1, 0))
        #the point at fraction 0.5 is (0,1)

        #clockwise arc with center 0,0
        arc = Arc.by_start_mid_end(Point(-1,0), Point(0, -1), Point(1, 0))
        #the point at fraction 0.5 is (0,-1)
        ```

        Args:
            fraction (float): a value from 0 (start) to (end)

        Returns:
            Point: a point on the arc at a certain fraction
        """
        angle_vector = Vector.by_angle(self.angle * fraction)
        angle_vector.dimensions = self.matrix.dimensions
        return self.matrix * angle_vector

    @property
    def centroid(self) -> "Point":
        """

        Returns:
            Point: the center of mass of this arc object
        """
        origin = self.origin
        radius = self.radius
        angle = self.angle
        # the distance of the centroid of the arc to its origin
        centroid_distance = (2 / 3) * (
            (radius * (math.sin(angle) ** 3))
            / (angle - math.sin(angle) * math.cos(angle))
        )
        return origin + centroid_distance * ((self.mid - origin) / radius)

    def __str__(self) -> "str":
        """Generates a string representation of the Arc object.

        #### Returns:
        `str`: A string that represents the Arc object.
        """
        return f"{__class__.__name__}.by_start_mid_end(start={self.start}, mid={self.mid}, end={self.end})"


class Polygon(PointList):
    """Represents a polygon composed of points."""

    def __init__(self, *args) -> "Polygon":

        super().__init__(to_array(*args))

    @property
    def closed(self) -> bool:
        return self[0] == self[-1]

    @property
    def points(self) -> list[Point]:
        return [Point(p) for p in self]

    @closed.setter
    def closed(self, value) -> "Polygon":
        """Closes the PolyCurve by connecting the last point to the first point, or opens it by removing the last point if it's a duplicate of the first point
        #### Example usage:
        ```python
            c:PolyCurve = PolyCurve(Point(1,3),Point(4,3),Point(2,6))
            c.closed = true #Point(1,3) just got added to the back of the list
        ```
        """
        if value != self.closed:
            if value:
                # copy. else, when operators are executed, it will execute the operator twice on the same reference
                self.append(Vector(self[0]))
            else:
                del self[-1]
        return self

    @property
    def curves(self) -> list[Line]:
        """this function won't close the polycurve!

        Returns:
            list[Line]: the curves connecting this polycurve
        """
        return [
            Line(self[point_index], self[point_index + 1])
            for point_index in range(len(self) - 1)
        ]

    @property
    def is_rectangle(self) -> bool:
        """the polycurve should be wound counter-clockwise and the first line should be in the x direction

        Returns:
            bool: if this curve is a rectangle, i.e. it has 4 corner points
        """
        if len(self) == 4 or self.closed and len(self) == 5:
            if (
                self[0].y == self[1].y
                and self[1].x == self[2].x
                and self[2].y == self[3].y
                and self[3].x == self[0].x
            ):
                return True
        else:
            return False

    def contains(self, p: "Point") -> bool:
        """checks if the point is inside the polygon

        Args:
            p (Point): _description_

        Returns:
            bool: _description_
        """
        # yoinked this from stack overflow, looks clean
        # https://stackoverflow.com/questions/36399381/whats-the-fastest-way-of-checking-if-a-point-is-inside-a-polygon-in-python

        # Ray tracing
        n = len(self)
        inside = False

        p1 = self[0]
        for i in range(n + 1 if self.closed else n):
            p2 = self[i % n]
            if p.y > min(p1.y, p2.y):
                if p.y <= max(p1.y, p2.y):
                    if p.x <= max(p1.x, p2.x):
                        if p1.y != p2.y:
                            xints = (p.y - p1.y) * (p2.x - p1.x) / (p2.y - p1.y) + p1.x
                        if p1.x == p2.x or p.x <= xints:
                            inside = not inside
            p1 = p2

        return inside

    def intersects(self, other: "PolyCurve") -> bool:
        """checks if two polycurves intersect with eachother. caution! this is brute force.

        Args:
            other (PolyCurve): the PolyCurve which may intersect with this rectangle

        Returns:
            bool: true if any of the lines of the two polygons cross eachother.
        """
        # before doing such an expensive method, let's check if our bounds cross first.
        if self.bounds.collides(other.bounds):
            other_curves = other.curves
            for c in self.curves:
                for other_c in other_curves:
                    if c.intersects(other_c):
                        return True
        return False

    def collides(self, other: "Polygon") -> bool:
        """checks if two polygons collide with eachother.

        Args:
            other (Polygon): the polygon which may collide with this rectangle

        Returns:
            bool: true if two polygons overlap
        """
        # hopefully, most of the time we contain a point of the other.
        return (
            self.contains(other[0]) or other.contains(self[0]) or self.intersects(other)
        )

    @classmethod
    def by_points(self, points: "list[Point]") -> "Polygon":
        """Creates a Polygon from a list of points.

        #### Parameters:
        - `points` (list[Point]): The list of points defining the Polygon.

        #### Returns:
        `Polygon`: The created Polygon object.

        #### Example usage:
        ```python

        ```
        """
        if len(points) < 3:
            print("Error: Polygon must have at least 3 unique points.")
            return None

        _points = []

        for point in points:  # Convert all to Point
            if isinstance(point, Point):
                _points.append(Point(point.x, point.y, 0))
            else:
                _points.append(point)

        if Point.to_matrix(_points[0]) == Point.to_matrix(_points[-1]):
            _points.pop()

        seen = set()
        unique_points = [p for p in _points if not (p in seen or seen.add(p))]

        polygon = Polygon()
        polygon.points = unique_points

        num_points = len(unique_points)
        for i in range(num_points):
            next_index = (i + 1) % num_points
            polygon.curves.append(
                Line(start=unique_points[i], end=unique_points[next_index])
            )

        return polygon

    @staticmethod
    def rectangular(rect: Rect) -> "Polygon":
        """Creates a rectangle in a given plane.

        #### Parameters:
        - `rect` (Rect): The rectangle to use as reference. one axis of its size should be 0 or a ValueError will occur!
        - `width` (float): The width of the rectangle.
        - `height` (float): The height of the rectangle.

        #### Returns:
        `Polygon`: The rectangle Polygon.

        #### Example usage:
        ```python
        ```
        """
        try:
            not_used_axis_index = rect.size.index(0)
        except:
            # 2d rectangle
            not_used_axis_index = 2

        axis0 = 1 if not_used_axis_index == 0 else 0
        axis1 = 1 if not_used_axis_index == 2 else 2

        rect_p1 = rect.p1
        curve_p0 = rect.p0
        # clone
        curve_p1 = Point(rect.p0)
        curve_p1[axis0] = rect_p1[axis0]

        curve_p2 = rect_p1
        curve_p3 = Point(rect.p0)
        curve_p3[axis1] = rect_p1[axis1]
        return Polygon(curve_p0, curve_p1, curve_p2, curve_p3)

    @staticmethod
    def by_joined_curves(lines: "list[Line]") -> "Polygon":
        """returns an unclosed polygon from the provided lines, with each point being the starting point of each line.
        creates a shallow copy of the lines provided!

        Args:
            lines (list[Line]): the starting point of every line provided will be used. segments are expected to be continuous. (lines[0].end == lines[1].start)

        Returns:
            Polygon: an unclosed polygon.
        """
        if not lines:
            print("Error: At least one curve is required to form a Polygon.")
            sys.exit()

        for i in range(len(lines) - 1):
            if lines[i].end != lines[i + 1].start:
                raise ValueError("Error: Curves must be contiguous to form a Polygon.")

        return Polygon([line.start for line in lines] + [lines[-1].end])

    @property
    def area(self) -> "float":  # shoelace formula
        """Calculates the area enclosed by the Polygon using the shoelace formula.

        #### Returns:
        `float`: The area enclosed by the Polygon.

        #### Example usage:
        ```python

        ```
        """
        if len(self) < 3:
            return "Polygon has less than 3 points!"

        num_points = len(self)
        S1, S2 = 0, 0

        for i in range(num_points):
            S1 += self[i - 1].x * self[i].y
            S2 += self[i - 1].y * self[i].x

        area = 0.5 * abs(S1 - S2)
        return area

    @property
    def centroid(self) -> "Point":
        """Calculates the centroid of the Polygon in 2D. we assume that the polygon doesn't intersect itself.

        #### Returns:
        `Point`: The centroid point of the Polygon.

        #### Example usage:
        ```python

        ```
        """
        if self.closed:
            num_points = len(self)
            if num_points < 3:
                return "Polygon has less than 3 points!"

            area = self.area

            # https://stackoverflow.com/questions/5271583/center-of-gravity-of-a-polygon

            Cx, Cy = 0.0, 0.0
            for i in range(num_points):
                x0, y0 = self[i - 1].x, self[i - 1].y
                x1, y1 = self[i].x, self[i].y
                factor = x0 * y1 - x1 * y0
                Cx += (x0 + x1) * factor
                Cy += (y0 + y1) * factor

            Cx /= 6.0 * area
            Cy /= 6.0 * area

            return Point(Cx, Cy)
        else:
            raise ValueError("this polycurve is not closed")

    @property
    def length(self) -> "float":
        """Calculates the total length of the Polygon.

        #### Returns:
        `float`: The total length of the Polygon.

        #### Example usage:
        ```python

        ```
        """
        lst = []
        for line in self.curves:
            lst.append(line.length)

        return sum(i.length for i in self.curves)

    def __str__(self) -> "str":
        """Returns a string representation of the PolyCurve.

        #### Returns:
        `str`: The string representation of the PolyCurve.

        #### Example usage:
        ```python

        ```
        """
        return f"{__class__.__name__} (points: {list.__str__(self)})"


class PolyCurve(list[Line], Shape, Curve):
    """Stores lines, which could possibly be arcs"""

    def __init__(self, *args):
        """Initializes a PolyCurve object, which is unclosed by default."""

        super().__init__(to_array(*args))

    # properties
    @property
    def start(self):
        return self[0].start

    @property
    def end(self):
        return self[-1].end

    @property
    def points(self) -> list[Point]:
        p = []
        for l in self:
            # TODO: remove duplicate points
            p.extend(l.points)
        return p

    @property
    def closed(self) -> "bool":
        return self[0].start == self[-1].end

    @closed.setter
    def closed(self, value: bool):
        if value != self.closed:
            if value:
                # just fill the gap using a straight line
                self.append(Line(self[-1].end, self[0].start))
            else:
                del self[-1]

    @property
    def area(self):
        """Calculates the area of the 2d PolyCurve.

        Returns:
            float: The area of the 2d poly curve.

        we are assuming the PolyCurve is wound counter-clockwise and is closed.
        """
        if not self.closed:
            raise ValueError(
                "the polycurve needs to be closed in order to calculate its area"
            )
        area: float = 0
        for line in self:
            if isinstance(line, Arc):
                origin = line.origin
                area += (line.start.x - line.end.x) * origin.y
                # now that we added the 'rectangle', let's add the sine wave

                # the arc is part of a circle. the circle can be represented as two opposite cosine waves, with the circle center being at 0, 0.
                # to calculate the area, we'll be using the integral of the cosine wave, which is the sine wave.
                radius = (line.origin - line.start).magnitude

                # area is negative if y < 0
                # area is measured from the -x side here, so at -radius, area == 0 and at +radius, area == circle_area
                # https://www.desmos.com/calculator/ykynwhoue6
                get_area = lambda pos: math.copysign(
                    (math.sin(((pos.x - origin.x) / radius) * (math.pi / 2)) + 1)
                    * radius,
                    pos.y - origin.y,
                )
                start_area = get_area(line.start)
                end_area = get_area(line.end)

                integral_area = start_area - end_area
                if integral_area < 0:
                    circle_area = (radius * radius) * math.pi
                    integral_area += circle_area
                area += integral_area
            else:
                # check direction of line
                # start - end, for counterclockwiseness
                # when start.x < end.x, this is a bottom line. we'll substract this from the area.
                dx = line.start.x - line.end.x
                averagey = (line.start.y + line.end.y) / 2
                area += dx * averagey
        return area

    @property
    def length(self) -> "float":
        """Calculates the total length of the PolyCurve.

        #### Returns:
        `float`: The total length of the PolyCurve.

        #### Example usage:
        ```python

        ```
        """

        return sum(curve.length for curve in self)

    # operators
    def __rmul__(self, transformer) -> "PolyCurve":
        return PolyCurve([transformer * curve for curve in self])

    # functions
    def segmentate_part(
        self, polygon_to_add_to: "Polygon", settings: SegmentationSettings
    ):
        for curve in self:
            curve.segmentate_part(polygon_to_add_to, settings)

    def scale(self, scale_factor: "float") -> "PolyCurve":
        """Scales the PolyCurve object by the given factor.

        #### Parameters:
        - `scale_factor`: The scaling factor.

        #### Returns:
        `PolyCurve`: Scaled PolyCurve object.

        #### Example usage:
        ```python

        ```
        """
        crvs = []
        for i in self.curves:
            if i.__class__.__name__ == "Arc":
                arcie = Arc(scale_factor * i.start, scale_factor * i.end)
                arcie.mid = scale_factor * i.mid
                crvs.append(arcie)
            elif i.__class__.__name__ == "Line":
                crvs.append(Line(scale_factor * i.start, scale_factor * i.end))
            else:
                print("Curvetype not found")
        crv = PolyCurve.by_joined_curves(crvs)
        return crv

    # static functions
    # TODO finish function
    @property
    def centroid(self) -> "Point":
        """Calculates the centroid of the PolyCurve. in 2D

        #### Returns:
        `Point`: The centroid point of the PolyCurve.

        #### Example usage:
        ```python

        ```
        """
        poly = Polygon.by_joined_curves(self)
        total_area = poly.area
        weighted_centroid = poly.centroid * total_area

        # now check if any lines are arcs. in that case, we need to adjust the centroid a bit

        for i in range(len(self)):
            current_line = self[i]
            if isinstance(current_line, Arc):
                # https://pickedshares.com/en/center-of-area-of-%E2%80%8B%E2%80%8Bgeometric-figures/#circlesegment
                # calculate the centroid
                arc_centroid = current_line.centroid
                arc_area = current_line.area

                total_area += arc_area
                # now that we have the centroid, we also need to calculate the area, and multiply the centroid by the area to give it a 'weight'
                weighted_centroid += arc_centroid * arc_area

        return weighted_centroid / total_area

    @classmethod
    def by_joined_curves(self, curvelst: "list[Curve]") -> "PolyCurve":
        """Creates a PolyCurve from a list of joined Line curves.

        #### Parameters:
        - `curvelst` (list[Line]): The list of Line curves to join.

        #### Returns:
        `PolyCurve`: The created PolyCurve object.

        #### Example usage:
        ```python

        ```
        """
        return PolyCurve(curvelst)

    @staticmethod
    def by_polygon(polygon: Polygon):
        return PolyCurve(polygon.curves)

    @staticmethod
    def by_points(points: "list[Point]") -> "PolyCurve":
        """Creates a PolyCurve from a list of points.

        #### Parameters:
        - `points` (list[Point]): The list of points defining the PolyCurve.

        #### Returns:
        `PolyCurve`: The created PolyCurve object.

        #### Example usage:
        ```python

        ```
        """
        return PolyCurve(Polygon(points).curves)

    @classmethod
    def unclosed_by_points(cls, points: "list[Point]") -> "PolyCurve":
        """Creates an unclosed PolyCurve from a list of points.

        #### Parameters:
        - `points` (list[Point]): The list of points defining the PolyCurve.

        #### Returns:
        `PolyCurve`: The created unclosed PolyCurve object.

        #### Example usage:
        ```python

        ```
        """
        plycrv = PolyCurve()
        for index, point in enumerate(points):
            plycrv.points.append(point)
            try:
                nextpoint = points[index + 1]
                plycrv.curves.append(Line(start=point, end=nextpoint))
            except:
                pass
        return plycrv


loaded_fonts = dict()


class Text:
    """The `Text` class is designed to represent and manipulate text within a coordinate system, allowing for the creation of text objects with specific fonts, sizes, and positions. It is capable of generating and translating text into a series of geometric representations."""

    def __init__(
        self, text: str = None, font_family = "Arial", cs=Matrix.identity(3), height=20
    ) -> "Text":
        """Initializes a new Text instance

        - `id` (str): A unique identifier for the text object.
        - `type` (str): The class name, "Text".
        - `text` (str, optional): The text string to be represented.
        - `font_family` (str, optional): The font family of the text, defaulting to "Arial".
        - `xyz` (Vector): The origin point of the text in the coordinate system.
        - `csglobal` (CoordinateSystem): The global coordinate system applied to the text.
        - `x`, `y`, `z` (float): The position offsets for the text within its coordinate system.
        - `scale` (float, optional): The scale factor applied to the text size.
        - `height` (float, optional): The height of the text characters.
        - `bbHeight` (float, optional): The bounding box height of the text.
        - `width` (float, optional): The calculated width of the text string.
        - `character_offset` (int): The offset between characters.
        - `space` (int): The space between words.
        - `curves` (list): A list of curves representing the text geometry.
        - `points` (list): A list of points derived from the text geometry.
        - `path_list` (list): A list containing the path data for each character.
        """

        self.text = text
        self.font_family = font_family
        self.xyz = cs.origin
        self.transform = cs
        self.x, self.y, self.z = 0, 0, 0
        self.scale = None
        self.height = height
        self.bbHeight = None
        self.width = None
        self.character_offset = 150
        self.space = 850
        self.curves = []
        # self.points = []
        self.path_list = self.load_path()

    def load_path(self) -> "str":
        """Loads the glyph paths for the specified text from a JSON file.
        This method fetches the glyph paths for each character in the text attribute, using a predefined font JSON file.

        #### Returns:
                str: A string representation of the glyph paths for the text.

        #### Example usage:
        ```python

        ```
        """
        file_name = "library/text/json/Calibri.json"
        if file_name not in loaded_fonts:
            with open(file_name, "r", encoding="utf-8") as file:
                loaded_fonts[file_name] = json.loads(file.read())
        glyph_data = loaded_fonts[file_name]
        output = []
        for letter in self.text:
            if letter in glyph_data:
                output.append(glyph_data[letter]["glyph-path"])
            elif letter == " ":
                output.append("space")

        letter = "o"
        if letter in glyph_data:
            self.load_o_example = [glyph_data[letter]["glyph-path"]]
        return output

    def write(self) -> "List[List[PolyCurve]]":
        """Generates a list of PolyCurve objects representing the text.
        Transforms the text into geometric representations based on the specified font, scale, and position.

        #### Returns:
                List[List[PolyCurve]]: A list of lists containing PolyCurve objects representing the text geometry.

        #### Example usage:
        ```python

        ```
        """
        # start ref_symbol
        path = self.load_o_example
        ref_points = []
        ref_allPoints = []
        for segment in path:
            pathx = parse_path(segment)
            for segment in pathx:
                segment_type = segment.__class__.__name__
                if isinstance(segment, Line):
                    ref_points.extend(
                        [
                            (segment.start.real, segment.start.imag),
                            (segment.end.real, segment.end.imag),
                        ]
                    )
                    ref_allPoints.extend(
                        [
                            (segment.start.real, segment.start.imag),
                            (segment.end.real, segment.end.imag),
                        ]
                    )
                elif isinstance(segment, CubicBezier):
                    ref_points.extend(segment.sample(10))
                    ref_allPoints.extend(segment.sample(10))
                elif isinstance(segment, QuadraticBezier):
                    for i in range(11):
                        t = i / 10.0
                        point = segment.point(t)
                        ref_points.append((point.real, point.imag))
                        ref_allPoints.append((point.real, point.imag))
                elif isinstance(segment, Arc):
                    ref_points.extend(segment.sample(10))
                    ref_allPoints.extend(segment.sample(10))
        height = self.calculate_bounding_box(ref_allPoints)[2]
        self.scale = self.height / height
        # end ref_symbol

        output_list = []
        for letter_path in self.path_list:
            points = []
            allPoints = []
            if letter_path == "space":
                self.x += self.space + self.character_offset
                pass
            else:
                path = parse_path(letter_path)
                for segment in path:
                    segment_type = segment.__class__.__name__
                    if segment_type == "Move":
                        if len(points) > 0:
                            points = []
                            allPoints.append("M")
                        subpath_started = True
                    elif subpath_started:
                        if segment_type == "Line":
                            points.extend(
                                [
                                    (segment.start.real, segment.start.imag),
                                    (segment.end.real, segment.end.imag),
                                ]
                            )
                            allPoints.extend(
                                [
                                    (segment.start.real, segment.start.imag),
                                    (segment.end.real, segment.end.imag),
                                ]
                            )
                        elif segment_type == "CubicBezier":
                            points.extend(segment.sample(10))
                            allPoints.extend(segment.sample(10))
                        elif segment_type == "QuadraticBezier":
                            for i in range(11):
                                t = i / 10.0
                                point = segment.point(t)
                                points.append((point.real, point.imag))
                                allPoints.append((point.real, point.imag))
                        elif segment_type == "Arc":
                            points.extend(segment.sample(10))
                            allPoints.extend(segment.sample(10))
                if points:
                    output_list.append(self.convert_points_to_polyline(allPoints))
                    width = self.calculate_bounding_box(allPoints)[1]
                    self.x += width + self.character_offset

                height = self.calculate_bounding_box(allPoints)[2]
                self.bbHeight = height
        pList = []
        for ply in flatten(output_list):
            translated = self.translate(ply)
            pList.append(translated)

        # for pl in pList:
        # 	for pt in pl.points:
        # 		self.points.append(pt)

        # print(f'Object text naar objects gestuurd.')
        return pList

    def translate(self, polyCurve: "PolyCurve") -> "PolyCurve":
        """Translates a PolyCurve according to the text object's global coordinate system and scale.

        #### Parameters:
                polyCurve (PolyCurve): The PolyCurve to be translated.

        #### Returns:
                PolyCurve: The translated PolyCurve.

        #### Example usage:
        ```python

        ```
        """
        combined_matrix = self.transform * Matrix.scale(
            Vector(self.scale, self.scale, self.scale)
        )
        return combined_matrix * polyCurve

    def calculate_bounding_box(self, points: "list[Point]") -> tuple:
        """Calculates the bounding box for a given set of points.

        #### Parameters:
                points (list): A list of points to calculate the bounding box for.

        #### Returns:
                tuple: A tuple containing the bounding box, its width, and its height.

        #### Example usage:
        ```python

        ```
        """

        points = [elem for elem in points if elem != "M"]
        ptList = [Point(pt[0], pt[1]) for pt in points]
        bounding_box_polyline = Rect.by_points(ptList)
        return (
            bounding_box_polyline,
            bounding_box_polyline.width,
            bounding_box_polyline.length,
        )

    def convert_points_to_polyline(self, points: "list[Point]") -> "PolyCurve":
        """Converts a list of points into a PolyCurve.
        This method is used to generate a PolyCurve from a series of points, typically derived from text path data.

        #### Parameters:
                points (list): A list of points to be converted into a PolyCurve.

        #### Returns:
                PolyCurve: A PolyCurve object representing the points.

        #### Example usage:
        ```python

        ```
        """
        output_list = []
        sub_lists = [[]]
        tempPoints = [elem for elem in points if elem != "M"]
        x_values = [point[0] for point in tempPoints]
        y_values = [point[1] for point in tempPoints]

        xmin = min(x_values)
        ymin = min(y_values)

        for item in points:
            if item == "M":
                sub_lists.append([])
            else:
                x = item[0] + self.x - xmin
                y = item[1] + self.y - ymin
                z = self.xyz.z
                eput = x, y, z
                sub_lists[-1].append(eput)
        output_list = [
            [Point(point[0], point[1], self.xyz.z) for point in element]
            for element in sub_lists
        ]

        polyline_list = [
            PolyCurve.by_points([Point(coord.x, coord.y, self.xyz.z) for coord in pts])
            for pts in output_list
        ]
        return polyline_list


# Maarten


class TickMark:
    # Dimension Tick Mark
    def __init__(self):
        self.name = None

        self.curves = []

    @staticmethod
    def by_curves(name, curves):
        TM = TickMark()
        TM.name = name
        TM.curves = curves
        return TM


TMDiagonal = TickMark.by_curves(
    "diagonal", [Line(start=Point(-100, -100, 0), end=Point(100, 100, 0))]
)


class DimensionType:
    def __init__(self):
        self.name = None

        self.font = None
        self.text_height = 2.5
        self.tick_mark: TickMark = TMDiagonal
        self.line_extension = 100

    @staticmethod
    def by_name_font_textheight_tick_mark_extension(
        name: str,
        font: str,
        text_height: float,
        tick_mark: TickMark,
        line_extension: float,
    ):
        DT = DimensionType()
        DT.name = name
        DT.font = font
        DT.text_height = text_height
        DT.tick_mark = tick_mark
        DT.line_extension = line_extension
        return DT


DT2_5_mm = DimensionType.by_name_font_textheight_tick_mark_extension(
    "2.5 mm", "calibri", 2.5, TMDiagonal, 100
)

DT1_8_mm = DimensionType.by_name_font_textheight_tick_mark_extension(
    "1.8 mm", "calibri", 2.5, TMDiagonal, 100
)


class Dimension:
    def __init__(self, start: Point, end: Point, dimension_type) -> None:

        self.start: Point = start
        self.text_height = 100
        self.end: Point = end
        self.scale = 0.1  # text
        self.dimension_type: DimensionType = dimension_type
        self.curves = []
        self.length: float = Line(start=self.start, end=self.end).length
        self.text = None
        self.geom()

    @staticmethod
    def by_startpoint_endpoint_offset(
        start: Point, end: Point, dimension_type: DimensionType, offset: float
    ):
        DS = Dimension()
        DS.start = start
        DS.end = end
        DS.dimension_type = dimension_type
        DS.geom()
        return DS

    def geom(self):
        # baseline
        baseline = Line(start=self.start, end=self.end)
        midpoint_text = baseline.mid
        direction = baseline.direction
        tick_mark_extension_point_1 = (
            self.start - direction * self.dimension_type.line_extension
        )
        tick_mark_extension_point_2 = (
            self.end + direction * self.dimension_type.line_extension
        )
        x = direction
        y = Vector.rotate(x, math.radians(90))
        z = Vector.z_axis
        cs_new_start = CoordinateSystem.by_origin_unit_axes(self.start, [x, y, z])
        cs_new_mid = CoordinateSystem.by_origin_unit_axes(midpoint_text, [x, y, z])
        cs_new_end = CoordinateSystem.by_origin_unit_axes(self.end, [x, y, z])
        self.curves.append(
            Line(tick_mark_extension_point_1, self.start)
        )  # extention_start
        self.curves.append(Line(tick_mark_extension_point_2, self.end))  # extention_end
        self.curves.append(Line(self.start, self.end))  # baseline
        # erg vieze oplossing. #Todo
        crvs = Line(
            start=self.dimension_type.tick_mark.curves[0].start,
            end=self.dimension_type.tick_mark.curves[0].end,
        )

        self.curves.append(
            cs_new_start * self.dimension_type.tick_mark.curves[0]
        )  # dimension tick start
        self.curves.append(cs_new_end * crvs)  # dimension tick end
        self.text = Text(
            text=str(round(self.length)),
            font_family=self.dimension_type.font,
            cs=cs_new_mid,
            height=self.text_height,
        ).write()

    def write(self, project):
        for i in self.curves:
            project.objects.append(i)
        for j in self.text:
            project.objects.append(j)


class BeamTag:
    def __init__(self):
        # Dimensions in 1/100 scale

        self.scale = 0.1
        self.cs: CoordinateSystem = CoordinateSystem()
        self.offset_x = 500
        self.offset_y = 100
        self.font_family = "calibri"
        self.text: str = "text"
        self.text_curves = None
        self.text_height = 100

    def __textobject(self):
        # cstextnew = cstext.translate(self.textoff_vector_local)
        self.text_curves = Text(
            text=self.text,
            font_family=self.font_family,
            height=self.text_height,
            cs=self.cs,
        ).write

    def by_cs_text(self, coordinate_system: CoordinateSystem, text):
        self.cs = coordinate_system
        self.text = text
        self.__textobject()
        return self

    def write(self, project):
        for x in self.text_curves():
            project.objects.append(x)
        return self

    @staticmethod
    def by_frame(frame):
        tag = BeamTag()
        frame_vector = frame.vector_normalised
        x = frame_vector
        y = Vector.rotate(x, math.radians(90))
        z = Vector.Z_Axis
        vx = Vector.scale(frame_vector, tag.offset_x)
        frame_width = PolyCurve.bounds(frame.curve)[4]
        vy = Vector.scale(y, frame_width * 0.5 + tag.offset_y)
        origintext = Point.translate(frame.start, vx)
        origintext = Point.translate(origintext, vy)
        csnew = CoordinateSystem(origintext, x, y, z)
        tag.cs = csnew
        tag.text = frame.name
        tag.__textobject()
        return tag


class ColumnTag:
    def __init__(self):
        # Dimensions in 1/100 scale

        self.width = 700
        self.height = 500
        self.factor = 3  # hellingsfacor leader
        self.scale = 0.1  # voor tekeningverschaling
        self.position = (
            "TL"  # TL, TR, BL, BR Top Left Top Right Bottom Left Bottom Right
        )
        self.transform: CoordinateSystem = CoordinateSystem()

        # self.textoff_vector_local: Vector = Vector(1,1,1)
        self.font_family = "calibri"
        self.curves = []
        # self.leadercurves()
        self.text: str = "text"
        self.text_height = 100
        self.text_offset_factor = 5
        self.textoff_vector_local: Vector = Vector(
            self.height / self.factor,
            self.height + self.height / self.text_offset_factor,
            0,
        )
        self.text_curves = None
        # self.textobject()

    def __leadercurves(self):
        self.startpoint = Point(0, 0, 0)
        self.midpoint = Point.translate(
            self.startpoint, Vector(self.height / self.factor, self.height, 0)
        )
        self.endpoint = Point.translate(self.midpoint, Vector(self.width, 0, 0))
        for line in [
            Line(start=self.startpoint, end=self.midpoint),
            Line(start=self.midpoint, end=self.endpoint),
        ]:
            self.curves.append(self.transform * line)

    def __textobject(self):

        cstextnew = CoordinateSystem.translate(self.textoff_vector_local) * self.transform
        self.text_curves = Text(
            text=self.text,
            font_family=self.font_family,
            height=self.text_height,
            cs=cstextnew,
        ).write

    def by_cs_text(self, coordinate_system: CoordinateSystem, text):
        self.transform = coordinate_system
        self.text = text
        self.__leadercurves()
        self.__textobject()
        return self


    @staticmethod
    def by_beam(beam, position="TL"):
        tag = ColumnTag()
        tag.position = position
        tag.transform = CoordinateSystem.translate(beam.start)
        tag.text = beam.name
        tag.__leadercurves()
        tag.__textobject()
        return tag


# class Label:
# class LabelType:
# class TextType:



class Color(Vector):
    """Documentation: output returns [r, g, b]"""

    def __init__(self, *args, **kwargs):
        Vector.__init__(self, *args, **kwargs)

    red = r = Vector.x
    green = g = Vector.y
    blue = b = Vector.z
    alpha = a = Vector.w

    axis_names = ["r", "g", "b", "a"]

    @property
    def int(self) -> int:
        """converts this color into an integer value

        Returns:
                int: the merged integer.
                this is assuming the color elements are whole integer values from 0 - 255
        """
        int_val = elem
        mult = 0x100
        for elem in self[1:]:
            int_val += elem * mult
            mult *= 0x100
        return int_val

    @property
    def hex(self):
        return "#%02x%02x%02x%02x" % (int(self.r), int(self.g), int(self.b), int(self.a))

    @staticmethod
    def axis_index(axis: str) -> int:
        """returns index of axis name.<br>
        raises a valueError when the name isn't valid.

        Args:
                axis (str): the name of the axis

        Returns:
                int: the index
        """
        return ["r", "g", "b", "a"].index(axis)

    @staticmethod
    def by_hex(hex: str) -> 'Color':
        """converts a heximal string to a color object.

        Args:
                hex (str): a heximal string, for example '#FF00FF88'

        Returns:
                Color: the color object
        """
        return (
            Color(
                int(hex[1:3], 16),
                int(hex[3:5], 16),
                int(hex[5:7], 16),
                int(hex[7:9], 16),
            )
            if len(hex) > 7
            else Color(int(hex[1:3], 16), int(hex[3:5], 16), int(hex[5:7], 16))
        )

    @staticmethod
    def by_cmyk(c, m, y, k) -> "Color":
        r = int((1 - c) * (1 - k) * 255)
        g = int((1 - m) * (1 - k) * 255)
        b = int((1 - y) * (1 - k) * 255)
        return Color(r, g, b)

    @staticmethod
    def by_gray_scale(brightness, channel_count=3) -> "Color":
        return Color([brightness] * channel_count)

    @staticmethod
    def by_rgb(*args, **kwargs):
        return Color(*args, **kwargs)

    @staticmethod
    def by_hsv(h, s, v):
        h /= 60.0
        c = v * s
        x = c * (1 - abs(h % 2 - 1))
        m = v - c
        if 0 <= h < 1:
            r, g, b = c, x, 0
        elif 1 <= h < 2:
            r, g, b = x, c, 0
        elif 2 <= h < 3:
            r, g, b = 0, c, x
        elif 3 <= h < 4:
            r, g, b = 0, x, c
        elif 4 <= h < 5:
            r, g, b = x, 0, c
        else:
            r, g, b = c, 0, x
        return Color(int((r + m) * 255), int((g + m) * 255), int((b + m) * 255))

    @staticmethod
    def by_hsl(h, s, l):
        c = (1 - abs(2 * l - 1)) * s
        x = c * (1 - abs(h / 60 % 2 - 1))
        m = l - c / 2
        if h < 60:
            r, g, b = c, x, 0
        elif h < 120:
            r, g, b = x, c, 0
        elif h < 180:
            r, g, b = 0, c, x
        elif h < 240:
            r, g, b = 0, x, c
        elif h < 300:
            r, g, b = x, 0, c
        else:
            r, g, b = c, 0, x
        return Color(int((r + m) * 255), int((g + m) * 255), int((b + m) * 255))

Color.red = Color(255, 0, 0)
Color.green = Color(0, 255, 0)
Color.blue = Color(0, 0, 255)



def rgb_to_int(rgb):
    r, g, b = [max(0, min(255, c)) for c in rgb]

    return (255 << 24) | (r << 16) | (g << 8) | b


class Material:
    def __init__(self, name: str, color: Color):
        self.name = name
        self.color = color


# Building Materials
BaseConcrete = Material("Concrete", Color.by_rgb([192, 192, 192]))
BaseTimber = Material("Timber", Color.by_rgb([191, 159, 116]))
BaseSteel = Material("Steel", Color.by_rgb([237, 28, 36]))
BaseOther = Material("Other", Color.by_rgb([150, 150, 150]))
BaseBrick = Material("Brick", Color.by_rgb([170, 77, 47]))
BaseBrickYellow = Material("BrickYellow", Color.by_rgb([208, 187, 147]))

# GIS Materials
BaseBuilding = Material("Building", Color.by_rgb([150, 28, 36]))
BaseWater = Material("Water", Color.by_rgb([139, 197, 214]))
BaseGreen = Material("Green", Color.by_rgb([175, 193, 138]))
BaseInfra = Material("Infra", Color.by_rgb([234, 234, 234]))
BaseRoads = Material("Infra", Color.by_rgb([140, 140, 140]))

# class Materialfinish



sqrt2 = math.sqrt(2)


# Hierachie:
# point 2D
# line 2D
# PolyCurve2D 2D
# profile is a parametric shape, resulting in a 2D curve
# section is een profiel met eigenschappen HEA200, 200,200,10,10,5 en eventuele rekenkundige eigenschappen.
# beam is een object wat in 3D zit met materiaal enz.


class Profile(Serializable):

    def __init__(
        self,
        name: str,
        description: str,
        IFC_profile_def: str,
        height: float,
        width: float,
        tw: float = None,
        tf: float = None,
    ):
        """Creates a profile.

        Args:
                name (str): _description_
                description (str): _description_
                IFC_profile_def (str): _description_
                height (_type_): _description_
                width (_type_): _description_
        """

        self.IFC_profile_def = IFC_profile_def

        self.name = name
        self.description = description
        self.curve = []
        self.height = height
        self.width = width
        self.tw = tw
        self.tf = tf

    def __str__(self):
        return f"{self.type} ({self.name})"


class CChannelParallelFlangeProfile(Profile):
    def __init__(self, name, height, width, tw, tf, r, ex):
        super().__init__(
            name,
            "C-channel with parallel flange",
            "IfcUShapeProfileDef",
            height,
            width,
            tw,
            tf,
        )

        # parameters

        self.r1 = r  # web fillet
        self.ex = ex  # centroid horizontal

        # describe points
        p1 = Point(-ex, -height / 2)  # left bottom
        p2 = Point(width - ex, -height / 2)  # right bottom
        p3 = Point(width - ex, -height / 2 + tf)
        p4 = Point(-ex + tw + r, -height / 2 + tf)  # start arc
        p5 = Point(-ex + tw + r, -height / 2 + tf + r)  # second point arc
        p6 = Point(-ex + tw, -height / 2 + tf + r)  # end arc
        p7 = Point(-ex + tw, height / 2 - tf - r)  # start arc
        p8 = Point(-ex + tw + r, height / 2 - tf - r)  # second point arc
        p9 = Point(-ex + tw + r, height / 2 - tf)  # end arc
        p10 = Point(width - ex, height / 2 - tf)
        p11 = Point(width - ex, height / 2)  # right top
        p12 = Point(-ex, height / 2)  # left top

        # describe curves
        l1 = Line(p1, p2)
        l2 = Line(p2, p3)
        l3 = Line(p3, p4)
        l4 = Arc.by_start_mid_end(p4, p5, p6)
        l5 = Line(p6, p7)
        l6 = Arc.by_start_mid_end(p7, p8, p9)
        l7 = Line(p9, p10)
        l8 = Line(p10, p11)
        l9 = Line(p11, p12)
        l10 = Line(p12, p1)

        self.curve = PolyCurve.by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10]
        )


class CChannelSlopedFlangeProfile(Profile):
    def __init__(self, name, height, width, tw, tf, r1, r2, tl, sa, ex):
        super().__init__(
            name,
            "C-channel with sloped flange",
            "IfcUShapeProfileDef",
            height,
            width,
            tw,
            tf,
        )

        self.r1 = r1  # web fillet
        r11 = r1 / sqrt2
        self.r2 = r2  # flange fillet
        r21 = r2 / sqrt2
        self.tl = tl  # flange thickness location from right
        self.sa = math.radians(sa)  # the angle of sloped flange in degrees
        self.ex = ex  # centroid horizontal

        # describe points
        p1 = Point(-ex, -height / 2)  # left bottom
        p2 = Point(width - ex, -height / 2)  # right bottom
        p3 = Point(
            width - ex, -height / 2 + tf - math.tan(self.sa) * tl - r2
        )  # start arc
        p4 = Point(
            width - ex - r2 + r21, -height / 2 + tf - math.tan(self.sa) * tl - r2 + r21
        )  # second point arc
        p5 = Point(
            width - ex - r2 + math.sin(self.sa) * r2,
            -height / 2 + tf - math.tan(self.sa) * (tl - r2),
        )  # end arc
        p6 = Point(
            -ex + tw + r1 - math.sin(self.sa) * r1,
            -height / 2 + tf + math.tan(self.sa) * (width - tl - tw - r1),
        )  # start arc
        p7 = Point(
            -ex + tw + r1 - r11,
            -height / 2 + tf + math.tan(self.sa) * (width - tl - tw - r1) + r1 - r11,
        )  # second point arc
        p8 = Point(
            -ex + tw, -height / 2 + tf + math.tan(self.sa) * (width - tl - tw) + r1
        )  # end arc
        p9 = Point(p8.x, -p8.y)  # start arc
        p10 = Point(p7.x, -p7.y)  # second point arc
        p11 = Point(p6.x, -p6.y)  # end arc
        p12 = Point(p5.x, -p5.y)  # start arc
        p13 = Point(p4.x, -p4.y)  # second point arc
        p14 = Point(p3.x, -p3.y)  # end arc
        p15 = Point(p2.x, -p2.y)  # right top
        p16 = Point(p1.x, -p1.y)  # left top

        # describe curves
        l1 = Line(p1, p2)
        l2 = Line(p2, p3)
        l3 = Arc.by_start_mid_end(p3, p4, p5)
        l4 = Line(p5, p6)
        l5 = Arc.by_start_mid_end(p6, p7, p8)
        l6 = Line(p8, p9)
        l7 = Arc.by_start_mid_end(p9, p10, p11)
        l8 = Line(p11, p12)
        l9 = Arc.by_start_mid_end(p12, p13, p14)
        l10 = Line(p14, p15)
        l11 = Line(p15, p16)
        l12 = Line(p16, p1)

        self.curve = PolyCurve([l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12])


class IShapeParallelFlangeProfile(Profile):
    def __init__(self, name, height, width, tw, tf, r):
        super().__init__(
            name,
            "I Shape profile with parallel flange",
            "IfcUShapeProfileDef",
            height,
            width,
            tw,
            tf,
        )

        self.r = r  # web fillet
        self.r1 = r1 = r / sqrt2

        # describe points
        p1 = Point(width / 2, -height / 2)  # right bottom
        p2 = Point(width / 2, -height / 2 + tf)
        p3 = Point(tw / 2 + r, -height / 2 + tf)  # start arc
        # second point arc
        p4 = Point(tw / 2 + r - r1, (-height / 2 + tf + r - r1))
        p5 = Point(tw / 2, -height / 2 + tf + r)  # end arc
        p6 = Point(tw / 2, height / 2 - tf - r)  # start arc
        p7 = Point(tw / 2 + r - r1, height / 2 - tf - r + r1)  # second point arc
        p8 = Point(tw / 2 + r, height / 2 - tf)  # end arc
        p9 = Point(width / 2, height / 2 - tf)
        p10 = Point((width / 2), (height / 2))  # right top
        p11 = Point(-p10.x, p10.y)  # left top
        p12 = Point(-p9.x, p9.y)
        p13 = Point(-p8.x, p8.y)  # start arc
        p14 = Point(-p7.x, p7.y)  # second point arc
        p15 = Point(-p6.x, p6.y)  # end arc
        p16 = Point(-p5.x, p5.y)  # start arc
        p17 = Point(-p4.x, p4.y)  # second point arc
        p18 = Point(-p3.x, p3.y)  # end arc
        p19 = Point(-p2.x, p2.y)
        p20 = Point(-p1.x, p1.y)

        # describe curves
        l1 = Line(p1, p2)
        l2 = Line(p2, p3)
        l3 = Arc.by_start_mid_end(p3, p4, p5)
        l4 = Line(p5, p6)
        l5 = Arc.by_start_mid_end(p6, p7, p8)
        l6 = Line(p8, p9)
        l7 = Line(p9, p10)
        l8 = Line(p10, p11)
        l9 = Line(p11, p12)
        l10 = Line(p12, p13)
        l11 = Arc.by_start_mid_end(p13, p14, p15)
        l12 = Line(p15, p16)
        l13 = Arc.by_start_mid_end(p16, p17, p18)
        l14 = Line(p18, p19)
        l15 = Line(p19, p20)
        l16 = Line(p20, p1)

        self.curve = PolyCurve(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16]
        )


class RectangleProfile(Profile):
    def __init__(self, name, width, height):
        super().__init__(name, "Rectangle", "IfcRectangleProfileDef", height, width)

        # describe points
        p1 = Point(width / 2, -height / 2)  # right bottom
        p2 = Point(width / 2, height / 2)  # right top
        p3 = Point(-width / 2, height / 2)  # left top
        p4 = Point(-width / 2, -height / 2)  # left bottom

        # describe curves
        l1 = Line(p1, p2)
        l2 = Line(p2, p3)
        l3 = Line(p3, p4)
        l4 = Line(p4, p1)

        self.curve = PolyCurve([l1, l2, l3, l4])


class RoundProfile(Profile):
    def __init__(self, name, r):
        super().__init__(name, "Round", "IfcCircleProfileDef", r * 2, r * 2)

        self.r = r

        dr = r / sqrt2  # grootste deel

        # describe points
        p1 = Point(r, 0)  # right middle
        p2 = Point(dr, dr)
        p3 = Point(0, r)  # middle top
        p4 = Point(-dr, dr)
        p5 = Point(-r, 0)  # left middle
        p6 = Point(-dr, -dr)
        p7 = Point(0, -r)  # middle bottom
        p8 = Point(dr, -dr)

        # describe curves
        l1 = Arc.by_start_mid_end(p1, p2, p3)
        l2 = Arc.by_start_mid_end(p3, p4, p5)
        l3 = Arc.by_start_mid_end(p5, p6, p7)
        l4 = Arc.by_start_mid_end(p7, p8, p1)

        self.curve = PolyCurve([l1, l2, l3, l4])


class RoundtubeProfile(Profile):
    def __init__(self, name, d, t):
        super().__init__(name, "Round Tube Profile", "IfcCircleHollowProfileDef", d, d)

        # parameters

        self.r = d / 2
        self.d = d
        self.t = t  # wall thickness
        dr = self.r / sqrt2  # grootste deel
        r = self.r
        ri = r - t
        dri = ri / sqrt2

        # describe points
        p1 = Point(r, 0)  # right middle
        p2 = Point(dr, dr)
        p3 = Point(0, r)  # middle top
        p4 = Point(-dr, dr)
        p5 = Point(-r, 0)  # left middle
        p6 = Point(-dr, -dr)
        p7 = Point(0, -r)  # middle bottom
        p8 = Point(dr, -dr)

        p9 = Point(ri, 0)  # right middle inner
        p10 = Point(dri, dri)
        p11 = Point(0, ri)  # middle top inner
        p12 = Point(-dri, dri)
        p13 = Point(-ri, 0)  # left middle inner
        p14 = Point(-dri, -dri)
        p15 = Point(0, -ri)  # middle bottom inner
        p16 = Point(dri, -dri)

        # describe curves
        l1 = Arc.by_start_mid_end(p1, p2, p3)
        l2 = Arc.by_start_mid_end(p3, p4, p5)
        l3 = Arc.by_start_mid_end(p5, p6, p7)
        l4 = Arc.by_start_mid_end(p7, p8, p1)

        l5 = Line(p1, p9)

        l6 = Arc.by_start_mid_end(p9, p10, p11)
        l7 = Arc.by_start_mid_end(p11, p12, p13)
        l8 = Arc.by_start_mid_end(p13, p14, p15)
        l9 = Arc.by_start_mid_end(p15, p16, p9)
        l10 = Line(p9, p1)

        self.curve = PolyCurve([l1, l2, l3, l4, l5, l6, l7, l8, l9, l10])


class LAngleProfile(Profile):
    def __init__(self, name, height, width, tw, tf, r1, r2, ex, ey):
        super().__init__(name, "LAngle", "IfcLShapeProfileDef", height, width, tw, tf)

        # parameters

        self.r1 = r1  # inner fillet
        r11 = r1 / sqrt2
        self.r2 = r2  # outer fillet
        r21 = r2 / sqrt2
        self.ex = ex  # from left
        self.ey = ey  # from bottom

        # describe points
        p1 = Point(-ex, -ey)  # left bottom
        p2 = Point(width - ex, -ey)  # right bottom
        p3 = Point(width - ex, -ey + tf - r2)  # start arc
        p4 = Point(width - ex - r2 + r21, -ey + tf - r2 + r21)  # second point arc
        p5 = Point(width - ex - r2, -ey + tf)  # end arc
        p6 = Point(-ex + tf + r1, -ey + tf)  # start arc
        p7 = Point(-ex + tf + r1 - r11, -ey + tf + r1 - r11)  # second point arc
        p8 = Point(-ex + tf, -ey + tf + r1)  # end arc
        p9 = Point(-ex + tf, height - ey - r2)  # start arc
        p10 = Point(-ex + tf - r2 + r21, height - ey - r2 + r21)  # second point arc
        p11 = Point(-ex + tf - r2, height - ey)  # end arc
        p12 = Point(-ex, height - ey)  # left top

        # describe curves
        l1 = Line(p1, p2)
        l2 = Line(p2, p3)
        l3 = Arc.by_start_mid_end(p3, p4, p5)
        l4 = Line(p5, p6)
        l5 = Arc.by_start_mid_end(p6, p7, p8)
        l6 = Line(p8, p9)
        l7 = Arc.by_start_mid_end(p9, p10, p11)
        l8 = Line(p11, p12)
        l9 = Line(p12, p1)

        self.curve = PolyCurve([l1, l2, l3, l4, l5, l6, l7, l8, l9])


class TProfileRounded(Profile):
    # ToDo: inner outer fillets in polycurve
    def __init__(self, name, height, width, tw, tf, r, r1, r2, ex, ey):
        super().__init__(name, "TProfile", "IfcTShapeProfileDef", height, width, tw, tf)

        self.r = r  # inner fillet
        self.r01 = r / sqrt2
        self.r1 = r1  # outer fillet flange
        r11 = r1 / sqrt2
        self.r2 = r2  # outer fillet top web
        r21 = r2 / sqrt2
        self.ex = ex  # from left
        self.ey = ey  # from bottom

        # describe points
        p1 = Point(-ex, -ey)  # left bottom
        p2 = Point(width - ex, -ey)  # right bottom
        p3 = Point(width - ex, -ey + tf - r1)  # start arc
        p4 = Point(width - ex - r1 + r11, -ey + tf - r1 + r11)  # second point arc
        p5 = Point(width - ex - r1, -ey + tf)  # end arc
        p6 = Point(0.5 * tw + r, -ey + tf)  # start arc
        p7 = Point(0.5 * tw + r - self.r01, -ey + tf + r - self.r01)  # second point arc
        p8 = Point(0.5 * tw, -ey + tf + r)  # end arc
        p9 = Point(0.5 * tw, -ey + height - r2)  # start arc
        p10 = Point(0.5 * tw - r21, -ey + height - r2 + r21)  # second point arc
        p11 = Point(0.5 * tw - r2, -ey + height)  # end arc

        p12 = Point(-p11.x, p11.y)
        p13 = Point(-p10.x, p10.y)
        p14 = Point(-p9.x, p9.y)
        p15 = Point(-p8.x, p8.y)
        p16 = Point(-p7.x, p7.y)
        p17 = Point(-p6.x, p6.y)
        p18 = Point(-p5.x, p5.y)
        p19 = Point(-p4.x, p4.y)
        p20 = Point(-p3.x, p3.y)

        # describe curves
        l1 = Line(p1, p2)

        l2 = Line(p2, p3)
        l3 = Arc.by_start_mid_end(p3, p4, p5)
        l4 = Line(p5, p6)
        l5 = Arc.by_start_mid_end(p6, p7, p8)
        l6 = Line(p8, p9)
        l7 = Arc.by_start_mid_end(p9, p10, p11)
        l8 = Line(p11, p12)

        l9 = Arc.by_start_mid_end(p12, p13, p14)
        l10 = Line(p14, p15)
        l11 = Arc.by_start_mid_end(p15, p16, p17)
        l12 = Line(p17, p18)
        l13 = Arc.by_start_mid_end(p18, p19, p20)
        l14 = Line(p20, p1)

        self.curve = PolyCurve(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14]
        )


class RectangleHollowSectionProfile(Profile):
    def __init__(self, name, height, width, t, r1, r2):
        super().__init__(
            name,
            "Rectangle Hollow Section",
            "IfcRectangleHollowProfileDef",
            height,
            width,
            tw=t,
            tf=t,
        )

        # parameters

        self.t = t  # thickness
        self.r1 = r1  # outer radius
        self.r2 = r2  # inner radius
        dr = r1 - r1 / sqrt2
        dri = r2 - r2 / sqrt2
        bi = width - t
        hi = height - t

        # describe points
        p1 = Point(-width / 2 + r1, -height / 2)  # left bottom end arc
        p2 = Point(width / 2 - r1, -height / 2)  # right bottom start arc
        p3 = Point(width / 2 - dr, -height / 2 + dr)  # right bottom mid arc
        p4 = Point(width / 2, -height / 2 + r1)  # right bottom end arc
        p5 = Point(p4.x, -p4.y)  # right start arc
        p6 = Point(p3.x, -p3.y)  # right mid arc
        p7 = Point(p2.x, -p2.y)  # right end arc
        p8 = Point(-p7.x, p7.y)  # left start arc
        p9 = Point(-p6.x, p6.y)  # left mid arc
        p10 = Point(-p5.x, p5.y)  # left end arc
        p11 = Point(p10.x, -p10.y)  # right bottom start arc
        p12 = Point(p9.x, -p9.y)  # right bottom mid arc

        # inner part
        p13 = Point(-bi / 2 + r2, -hi / 2)  # left bottom end arc
        p14 = Point(bi / 2 - r2, -hi / 2)  # right bottom start arc
        p15 = Point(bi / 2 - dri, -hi / 2 + dri)  # right bottom mid arc
        p16 = Point(bi / 2, -hi / 2 + r2)  # right bottom end arc
        p17 = Point(p16.x, -p16.y)  # right start arc
        p18 = Point(p15.x, -p15.y)  # right mid arc
        p19 = Point(p14.x, -p14.y)  # right end arc
        p20 = Point(-p19.x, p19.y)  # left start arc
        p21 = Point(-p18.x, p18.y)  # left mid arc
        p22 = Point(-p17.x, p17.y)  # left end arc
        p23 = Point(p22.x, -p22.y)  # right bottom start arc
        p24 = Point(p21.x, -p21.y)  # right bottom mid arc

        # describe outer curves
        l1 = Line(p1, p2)
        l2 = Arc.by_start_mid_end(p2, p3, p4)
        l3 = Line(p4, p5)
        l4 = Arc.by_start_mid_end(p5, p6, p7)
        l5 = Line(p7, p8)
        l6 = Arc.by_start_mid_end(p8, p9, p10)
        l7 = Line(p10, p11)
        l8 = Arc.by_start_mid_end(p11, p12, p1)

        l9 = Line(p1, p13)
        # describe inner curves
        l10 = Line(p13, p14)
        l11 = Arc.by_start_mid_end(p14, p15, p16)
        l12 = Line(p16, p17)
        l13 = Arc.by_start_mid_end(p17, p18, p19)
        l14 = Line(p19, p20)
        l15 = Arc.by_start_mid_end(p20, p21, p22)
        l16 = Line(p22, p23)
        l17 = Arc.by_start_mid_end(p23, p24, p13)

        l18 = Line(p13, p1)

        self.curve = PolyCurve(
            [
                l1,
                l2,
                l3,
                l4,
                l5,
                l6,
                l7,
                l8,
                l9,
                l10,
                l11,
                l12,
                l13,
                l14,
                l15,
                l16,
                l17,
                l18,
            ]
        )


class CProfile(Profile):
    def __init__(self, name, width, height, t, r1, ex):
        super().__init__(
            name, "Cold Formed C Profile", "Unknown", height, width, tw=t, tf=t
        )

        # parameters

        self.t = t  # flange thickness
        self.r1 = r1  # outer radius
        self.r2 = r1 - t  # inner radius
        r2 = r1 - t

        self.ex = ex
        self.ey = height / 2
        dr = r1 - r1 / sqrt2
        dri = r2 - r2 / sqrt2
        hi = height - t

        # describe points
        p1 = Point(width - ex, -height / 2)  # right bottom
        p2 = Point(r1 - ex, -height / 2)
        p3 = Point(dr - ex, -height / 2 + dr)
        p4 = Point(0 - ex, -height / 2 + r1)
        p5 = Point(p4.x, -p4.y)
        p6 = Point(p3.x, -p3.y)
        p7 = Point(p2.x, -p2.y)
        p8 = Point(p1.x, -p1.y)  # right top
        p9 = Point(width - ex, hi / 2)  # right top inner
        p10 = Point(t + r2 - ex, hi / 2)
        p11 = Point(t + dri - ex, hi / 2 - dri)
        p12 = Point(t - ex, hi / 2 - r2)
        p13 = Point(p12.x, -p12.y)
        p14 = Point(p11.x, -p11.y)
        p15 = Point(p10.x, -p10.y)
        p16 = Point(p9.x, -p9.y)  # right bottom inner
        # describe outer curves
        l1 = Line(p1, p2)  # bottom
        l2 = Arc.by_start_mid_end(p2, p3, p4)  # right outer fillet
        l3 = Line(p4, p5)  # left outer web
        l4 = Arc.by_start_mid_end(p5, p6, p7)  # left top outer fillet
        l5 = Line(p7, p8)  # outer top
        l6 = Line(p8, p9)
        l7 = Line(p9, p10)
        l8 = Arc.by_start_mid_end(p10, p11, p12)  # left top inner fillet
        l9 = Line(p12, p13)
        l10 = Arc.by_start_mid_end(p13, p14, p15)  # left botom inner fillet
        l11 = Line(p15, p16)
        l12 = Line(p16, p1)

        self.curve = PolyCurve([l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12])


class CProfileWithLips(Profile):
    def __init__(self, name, width, height, h1, t, r1, ex):
        super().__init__(
            name,
            "Cold Formed C Profile with Lips",
            "Unknown",
            height,
            width,
            tw=t,
            tf=t,
        )

        # parameters

        self.h1 = h1  # lip length
        self.t = t  # flange thickness
        self.r1 = r1  # outer radius
        self.r2 = r1 - t  # inner radius
        r2 = r1 - t

        self.ex = ex
        self.ey = height / 2
        dr = r1 - r1 / sqrt2
        dri = r2 - r2 / sqrt2
        hi = height - t

        # describe points
        p1 = Point(width - ex - r1, -height / 2)  # right bottom  before fillet
        p2 = Point(r1 - ex, -height / 2)
        p3 = Point(dr - ex, -height / 2 + dr)
        p4 = Point(0 - ex, -height / 2 + r1)
        p5 = Point(p4.x, -p4.y)
        p6 = Point(p3.x, -p3.y)
        p7 = Point(p2.x, -p2.y)
        p8 = Point(p1.x, -p1.y)  # right top before fillet
        p9 = Point(width - ex - dr, height / 2 - dr)  # middle point arc
        p10 = Point(width - ex, height / 2 - r1)  # end fillet
        p11 = Point(width - ex, height / 2 - h1)
        p12 = Point(width - ex - t, height / 2 - h1)  # bottom lip
        p13 = Point(width - ex - t, height / 2 - t - r2)  # start inner fillet right top
        p14 = Point(width - ex - t - dri, height / 2 - t - dri)
        p15 = Point(width - ex - t - r2, height / 2 - t)  # end inner fillet right top
        p16 = Point(0 - ex + t + r2, height / 2 - t)
        p17 = Point(0 - ex + t + dri, height / 2 - t - dri)
        p18 = Point(0 - ex + t, height / 2 - t - r2)

        p19 = Point(p18.x, -p18.y)
        p20 = Point(p17.x, -p17.y)
        p21 = Point(p16.x, -p16.y)
        p22 = Point(p15.x, -p15.y)
        p23 = Point(p14.x, -p14.y)
        p24 = Point(p13.x, -p13.y)
        p25 = Point(p12.x, -p12.y)
        p26 = Point(p11.x, -p11.y)
        p27 = Point(p10.x, -p10.y)
        p28 = Point(p9.x, -p9.y)

        # describe outer curves
        l1 = Line(p1, p2)
        l2 = Arc.by_start_mid_end(p2, p3, p4)
        l3 = Line(p4, p5)
        l4 = Arc.by_start_mid_end(p5, p6, p7)  # outer fillet right top
        l5 = Line(p7, p8)
        l6 = Arc.by_start_mid_end(p8, p9, p10)
        l7 = Line(p10, p11)
        l8 = Line(p11, p12)
        l9 = Line(p12, p13)
        l10 = Arc.by_start_mid_end(p13, p14, p15)
        l11 = Line(p15, p16)
        l12 = Arc.by_start_mid_end(p16, p17, p18)
        l13 = Line(p18, p19)  # inner web
        l14 = Arc.by_start_mid_end(p19, p20, p21)
        l15 = Line(p21, p22)
        l16 = Arc.by_start_mid_end(p22, p23, p24)
        l17 = Line(p24, p25)
        l18 = Line(p25, p26)
        l19 = Line(p26, p27)
        l20 = Arc.by_start_mid_end(p27, p28, p1)

        self.curve = PolyCurve(
            [
                l1,
                l2,
                l3,
                l4,
                l5,
                l6,
                l7,
                l8,
                l9,
                l10,
                l11,
                l12,
                l13,
                l14,
                l15,
                l16,
                l17,
                l18,
                l19,
                l20,
            ]
        )


class LProfileColdFormed(Profile):
    def __init__(self, name, width, height, t, r1, ex, ey):
        super().__init__(
            name, "Cold Formed L Profile", "Unknown", height, width, tw=t, tf=t
        )

        # parameters

        self.t = t  # flange thickness
        self.r1 = r1  # inner radius
        self.r2 = r1 - t  # outer radius
        self.ex = ex
        self.ey = ey
        r11 = r1 / math.sqrt(2)
        r2 = r1 + t
        r21 = r2 / math.sqrt(2)

        # describe points
        p1 = Point(-ex, -ey + r2)  # start arc left bottom
        p2 = Point(-ex + r2 - r21, -ey + r2 - r21)  # second point arc
        p3 = Point(-ex + r2, -ey)  # end arc
        p4 = Point(width - ex, -ey)  # right bottom
        p5 = Point(width - ex, -ey + t)
        p6 = Point(-ex + t + r1, -ey + t)  # start arc
        p7 = Point(-ex + t + r1 - r11, -ey + t + r1 - r11)  # second point arc
        p8 = Point(-ex + t, -ey + t + r1)  # end arc
        p9 = Point(-ex + t, ey)
        p10 = Point(-ex, ey)  # left top

        l1 = Arc.by_start_mid_end(p1, p2, p3)
        l2 = Line(p3, p4)
        l3 = Line(p4, p5)
        l4 = Line(p5, p6)
        l5 = Arc.by_start_mid_end(p6, p7, p8)
        l6 = Line(p8, p9)
        l7 = Line(p9, p10)
        l8 = Line(p10, p1)

        self.curve = PolyCurve([l1, l2, l3, l4, l5, l6, l7, l8])


class SigmaProfileWithLipsColdFormed(Profile):
    def __init__(self, name, width, height, t, r1, h1, h2, h3, b2, ex):
        super().__init__(
            name,
            "Cold Formed Sigma Profile with Lips",
            "Unknown",
            height,
            width,
            tw=t,
            tf=t,
        )

        # parameters

        self.h1 = h1  # LipLength
        self.h2 = h2  # MiddleBendLength
        self.h3 = h3  # TopBendLength
        self.h4 = h4 = (height - h2 - h3 * 2) / 2
        self.h5 = h5 = math.tan(0.5 * math.atan(b2 / h4)) * t
        self.b2 = b2  # MiddleBendWidth
        self.t = t  # flange thickness
        self.r1 = r1  # inner radius
        self.r2 = r2 = r1 + t  # outer radius
        self.ex = ex
        self.ey = ey = height / 2
        r11 = r11 = r1 / math.sqrt(2)
        r21 = r21 = r2 / math.sqrt(2)

        p1 = Point(-ex + b2, -h2 / 2)
        p2 = Point(-ex, -ey + h3)
        p3 = Point(-ex, -ey + r2)  # start arc left bottom
        p4 = Point(-ex + r2 - r21, -ey + r2 - r21)  # second point arc
        p5 = Point(-ex + r2, -ey)  # end arc
        p6 = Point(width - ex - r2, -ey)  # start arc
        p7 = Point(width - ex - r2 + r21, -ey + r2 - r21)  # second point arc
        p8 = Point(width - ex, -ey + r2)  # end arc
        p9 = Point(width - ex, -ey + h1)  # end lip
        p10 = Point(width - ex - t, -ey + h1)
        p11 = Point(width - ex - t, -ey + t + r1)  # start arc
        p12 = Point(width - ex - t - r1 + r11, -ey + t + r1 - r11)  # second point arc
        p13 = Point(width - ex - t - r1, -ey + t)  # end arc
        p14 = Point(-ex + t + r1, -ey + t)  # start arc
        p15 = Point(-ex + t + r1 - r11, -ey + t + r1 - r11)  # second point arc
        p16 = Point(-ex + t, -ey + t + r1)  # end arc
        p17 = Point(-ex + t, -ey + h3 - h5)
        p18 = Point(-ex + b2 + t, -h2 / 2 - h5)
        p19 = Point(p18.x, -p18.y)
        p20 = Point(p17.x, -p17.y)
        p21 = Point(p16.x, -p16.y)
        p22 = Point(p15.x, -p15.y)
        p23 = Point(p14.x, -p14.y)
        p24 = Point(p13.x, -p13.y)
        p25 = Point(p12.x, -p12.y)
        p26 = Point(p11.x, -p11.y)
        p27 = Point(p10.x, -p10.y)
        p28 = Point(p9.x, -p9.y)
        p29 = Point(p8.x, -p8.y)
        p30 = Point(p7.x, -p7.y)
        p31 = Point(p6.x, -p6.y)
        p32 = Point(p5.x, -p5.y)
        p33 = Point(p4.x, -p4.y)
        p34 = Point(p3.x, -p3.y)
        p35 = Point(p2.x, -p2.y)
        p36 = Point(p1.x, -p1.y)

        l1 = Line(p1, p2)
        l2 = Line(p2, p3)
        l3 = Arc.by_start_mid_end(p3, p4, p5)
        l4 = Line(p5, p6)
        l5 = Arc.by_start_mid_end(p6, p7, p8)
        l6 = Line(p8, p9)
        l7 = Line(p9, p10)
        l8 = Line(p10, p11)
        l9 = Arc.by_start_mid_end(p11, p12, p13)
        l10 = Line(p13, p14)
        l11 = Arc.by_start_mid_end(p14, p15, p16)
        l12 = Line(p16, p17)
        l13 = Line(p17, p18)
        l14 = Line(p18, p19)
        l15 = Line(p19, p20)
        l16 = Line(p20, p21)
        l17 = Arc.by_start_mid_end(p21, p22, p23)
        l18 = Line(p23, p24)
        l19 = Arc.by_start_mid_end(p24, p25, p26)
        l20 = Line(p26, p27)
        l21 = Line(p27, p28)
        l22 = Line(p28, p29)
        l23 = Arc.by_start_mid_end(p29, p30, p31)
        l24 = Line(p31, p32)
        l25 = Arc.by_start_mid_end(p32, p33, p34)
        l26 = Line(p34, p35)
        l27 = Line(p35, p36)
        l28 = Line(p36, p1)

        self.curve = PolyCurve(
            [
                l1,
                l2,
                l3,
                l4,
                l5,
                l6,
                l7,
                l8,
                l9,
                l10,
                l11,
                l12,
                l13,
                l14,
                l15,
                l16,
                l17,
                l18,
                l19,
                l20,
                l21,
                l22,
                l23,
                l24,
                l25,
                l26,
                l27,
                l28,
            ]
        )


class ZProfileColdFormed(Profile):
    def __init__(self, name, width, height, t, r1):
        super().__init__(
            name, "Cold Formed Z Profile", "Unknown", height, width, tw=t, tf=t
        )

        # parameters

        self.t = t  # flange thickness
        self.r1 = r1  # inner radius
        self.r2 = r2 = r1 + t  # outer radius
        self.ex = ex = width / 2
        self.ey = ey = height / 2
        r11 = r11 = r1 / math.sqrt(2)
        r21 = r21 = r2 / math.sqrt(2)

        p1 = Point(-0.5 * t, -ey + t + r1)  # start arc
        p2 = Point(-0.5 * t - r1 + r11, -ey + t + r1 - r11)  # second point arc
        p3 = Point(-0.5 * t - r1, -ey + t)  # end arc
        p4 = Point(-ex, -ey + t)
        p5 = Point(-ex, -ey)  # left bottom
        p6 = Point(-r2 + 0.5 * t, -ey)  # start arc
        p7 = Point(-r2 + 0.5 * t + r21, -ey + r2 - r21)  # second point arc
        p8 = Point(0.5 * t, -ey + r2)  # end arc
        p9 = Point(-p1.x, -p1.y)
        p10 = Point(-p2.x, -p2.y)
        p11 = Point(-p3.x, -p3.y)
        p12 = Point(-p4.x, -p4.y)
        p13 = Point(-p5.x, -p5.y)
        p14 = Point(-p6.x, -p6.y)
        p15 = Point(-p7.x, -p7.y)
        p16 = Point(-p8.x, -p8.y)

        l1 = Arc.by_start_mid_end(p1, p2, p3)
        l2 = Line(p3, p4)
        l3 = Line(p4, p5)
        l4 = Line(p5, p6)
        l5 = Arc.by_start_mid_end(p6, p7, p8)
        l6 = Line(p8, p9)
        l7 = Arc.by_start_mid_end(p9, p10, p11)
        l8 = Line(p11, p12)
        l9 = Line(p12, p13)
        l10 = Line(p13, p14)
        l11 = Arc.by_start_mid_end(p14, p15, p16)
        l12 = Line(p16, p1)

        self.curve = PolyCurve([l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12])


class ZProfileWithLipsColdFormed(Profile):
    def __init__(self, name, width, height, t, r1, h1):
        super().__init__(
            name,
            "Cold Formed Z Profile with Lips",
            "Unknown",
            height,
            width,
            tw=t,
            tf=t,
        )

        # parameters

        self.t = t  # flange thickness
        self.h1 = h1  # lip length
        self.r1 = r1  # inner radius
        self.r2 = r2 = r1 + t  # outer radius
        self.ex = ex = width / 2
        self.ey = ey = height / 2
        r11 = r11 = r1 / math.sqrt(2)
        r21 = r21 = r2 / math.sqrt(2)

        p1 = Point(-0.5 * t, -ey + t + r1)  # start arc
        p2 = Point(-0.5 * t - r1 + r11, -ey + t + r1 - r11)  # second point arc
        p3 = Point(-0.5 * t - r1, -ey + t)  # end arc
        p4 = Point(-ex + t + r1, -ey + t)  # start arc
        p5 = Point(-ex + t + r1 - r11, -ey + t + r1 - r11)  # second point arc
        p6 = Point(-ex + t, -ey + t + r1)  # end arc
        p7 = Point(-ex + t, -ey + h1)
        p8 = Point(-ex, -ey + h1)
        p9 = Point(-ex, -ey + r2)  # start arc
        p10 = Point(-ex + r2 - r21, -ey + r2 - r21)  # second point arc
        p11 = Point(-ex + r2, -ey)  # end arc
        p12 = Point(-r2 + 0.5 * t, -ey)  # start arc
        p13 = Point(-r2 + 0.5 * t + r21, -ey + r2 - r21)  # second point arc
        p14 = Point(0.5 * t, -ey + r2)  # end arc
        p15 = Point(-p1.x, -p1.y)
        p16 = Point(-p2.x, -p2.y)
        p17 = Point(-p3.x, -p3.y)
        p18 = Point(-p4.x, -p4.y)
        p19 = Point(-p5.x, -p5.y)
        p20 = Point(-p6.x, -p6.y)
        p21 = Point(-p7.x, -p7.y)
        p22 = Point(-p8.x, -p8.y)
        p23 = Point(-p9.x, -p9.y)
        p24 = Point(-p10.x, -p10.y)
        p25 = Point(-p11.x, -p11.y)
        p26 = Point(-p12.x, -p12.y)
        p27 = Point(-p13.x, -p13.y)
        p28 = Point(-p14.x, -p14.y)

        l1 = Arc.by_start_mid_end(p1, p2, p3)
        l2 = Line(p3, p4)
        l3 = Arc.by_start_mid_end(p4, p5, p6)
        l4 = Line(p6, p7)
        l5 = Line(p7, p8)
        l6 = Line(p8, p9)
        l7 = Arc.by_start_mid_end(p9, p10, p11)
        l8 = Line(p11, p12)
        l9 = Arc.by_start_mid_end(p12, p13, p14)
        l10 = Line(p14, p15)
        l11 = Arc.by_start_mid_end(p15, p16, p17)
        l12 = Line(p17, p18)
        l13 = Arc.by_start_mid_end(p18, p19, p20)
        l14 = Line(p20, p21)
        l15 = Line(p21, p22)
        l16 = Line(p22, p23)
        l17 = Arc.by_start_mid_end(p23, p24, p25)
        l18 = Line(p25, p26)
        l19 = Arc.by_start_mid_end(p26, p27, p28)
        l20 = Line(p28, p1)

        self.curve = PolyCurve(
            [
                l1,
                l2,
                l3,
                l4,
                l5,
                l6,
                l7,
                l8,
                l9,
                l10,
                l11,
                l12,
                l13,
                l14,
                l15,
                l16,
                l17,
                l18,
                l19,
                l20,
            ]
        )


class TProfile(Profile):
    def __init__(self, name, height, width, h1: float, b1: float):
        super().__init__(name, "T-profile", "Unknown", height, width)

        # parameters

        self.h1 = h1
        self.b1 = b1

        # describe points
        p1 = Point(b1 / 2, -height / 2)  # right bottom
        p2 = Point(b1 / 2, height / 2 - h1)  # right middle 1
        p3 = Point(width / 2, height / 2 - h1)  # right middle 2
        p4 = Point(width / 2, height / 2)  # right top
        p5 = Point(-width / 2, height / 2)  # left top
        p6 = Point(-width / 2, height / 2 - h1)  # left middle 2
        p7 = Point(-b1 / 2, height / 2 - h1)  # left middle 1
        p8 = Point(-b1 / 2, -height / 2)  # left bottom

        # describe curves
        l1 = Line(p1, p2)
        l2 = Line(p2, p3)
        l3 = Line(p3, p4)
        l4 = Line(p4, p5)
        l5 = Line(p5, p6)
        l6 = Line(p6, p7)
        l7 = Line(p7, p8)
        l8 = Line(p8, p1)

        self.curve = PolyCurve([l1, l2, l3, l4, l5, l6, l7, l8])


class LProfile(Profile):
    def __init__(self, name, height, width, h1: float, b1: float):
        super().__init__(name, "L-profile", "Unknown", height, width)

        # parameters

        self.h1 = h1
        self.b1 = b1

        # describe points
        p1 = Point(width / 2, -height / 2)  # right bottom
        p2 = Point(width / 2, -height / 2 + h1)  # right middle
        p3 = Point(-width / 2 + b1, -height / 2 + h1)  # middle
        p4 = Point(-width / 2 + b1, height / 2)  # middle top
        p5 = Point(-width / 2, height / 2)  # left top
        p6 = Point(-width / 2, -height / 2)  # left bottom

        # describe curves
        l1 = Line(p1, p2)
        l2 = Line(p2, p3)
        l3 = Line(p3, p4)
        l4 = Line(p4, p5)
        l5 = Line(p5, p6)
        l6 = Line(p6, p1)

        self.curve = PolyCurve([l1, l2, l3, l4, l5, l6])


class EProfile(Serializable):
    def __init__(self, name, height, width, h1):
        super().__init__(name, "E-profile", "Unknown", height, width)

        # parameters

        self.h1 = h1

        # describe points
        p1 = Point(width / 2, -height / 2)  # right bottom
        p2 = Point(width / 2, -height / 2 + h1)
        p3 = Point(-width / 2 + h1, -height / 2 + h1)
        p4 = Point(-width / 2 + h1, -h1 / 2)
        p5 = Point(width / 2, -h1 / 2)
        p6 = Point(width / 2, h1 / 2)
        p7 = Point(-width / 2 + h1, h1 / 2)
        p8 = Point(-width / 2 + h1, height / 2 - h1)
        p9 = Point(width / 2, height / 2 - h1)
        p10 = Point(width / 2, height / 2)
        p11 = Point(-width / 2, height / 2)
        p12 = Point(-width / 2, -height / 2)

        # describe curves
        l1 = Line(p1, p2)
        l2 = Line(p2, p3)
        l3 = Line(p3, p4)
        l4 = Line(p4, p5)
        l5 = Line(p5, p6)
        l6 = Line(p6, p7)
        l7 = Line(p7, p8)
        l8 = Line(p8, p9)
        l9 = Line(p9, p10)
        l10 = Line(p10, p11)
        l11 = Line(p11, p12)
        l12 = Line(p12, p1)

        self.curve = PolyCurve([l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12])


class NProfile(Serializable):
    def __init__(self, name, height, width, b1):
        super().__init__(name, "N-profile", "Unknown", height, width)

        # parameters

        self.b1 = b1

        # describe points
        p1 = Point(width / 2, -height / 2)  # right bottom
        p2 = Point(width / 2, height / 2)
        p3 = Point(width / 2 - b1, height / 2)
        p4 = Point(width / 2 - b1, -height / 2 + b1 * 2)
        p5 = Point(-width / 2 + b1, height / 2)
        p6 = Point(-width / 2, height / 2)
        p7 = Point(-width / 2, -height / 2)
        p8 = Point(-width / 2 + b1, -height / 2)
        p9 = Point(-width / 2 + b1, height / 2 - b1 * 2)
        p10 = Point(width / 2 - b1, -height / 2)

        # describe curves
        l1 = Line(p1, p2)
        l2 = Line(p2, p3)
        l3 = Line(p3, p4)
        l4 = Line(p4, p5)
        l5 = Line(p5, p6)
        l6 = Line(p6, p7)
        l7 = Line(p7, p8)
        l8 = Line(p8, p9)
        l9 = Line(p9, p10)
        l10 = Line(p10, p1)

        self.curve = PolyCurve([l1, l2, l3, l4, l5, l6, l7, l8, l9, l10])


class ArrowProfile(Profile):
    def __init__(self, name, length, width, b1, l1):
        super().__init__(name, "Arrow-profile", "Unknown", length, width)

        # parameters

        self.length = length  # length
        self.b1 = b1
        self.l1 = l1

        # describe points
        p1 = Point(0, length / 2)  # top middle
        p2 = Point(width / 2, -length / 2 + l1)
        # p3 = Point(b1 / 2, -length / 2 + l1)
        p3 = Point(b1 / 2, (-length / 2 + l1) + (length / 2) / 4)
        p4 = Point(b1 / 2, -length / 2)
        p5 = Point(-b1 / 2, -length / 2)
        # p6 = Point(-b1 / 2, -length / 2 + l1)
        p6 = Point(-b1 / 2, (-length / 2 + l1) + (length / 2) / 4)
        p7 = Point(-width / 2, -length / 2 + l1)

        # describe curves
        l1 = Line(p1, p2)
        l2 = Line(p2, p3)
        l3 = Line(p3, p4)
        l4 = Line(p4, p5)
        l5 = Line(p5, p6)
        l6 = Line(p6, p7)
        l7 = Line(p7, p1)

        self.curve = PolyCurve([l1, l2, l3, l4, l5, l6, l7])

jsonFile = (
    "https://raw.githubusercontent.com/3BMLabs/Project-Ocondat/master/steelprofile.json"
)
url = urllib.request.urlopen(jsonFile)
data = json.loads(url.read())


def is_rectangle_format(shape_name):
    match = re.match(r"^(\d{1,4})x(\d{1,4})$", shape_name)
    if match:
        width, height = int(match.group(1)), int(match.group(2))
        if 0 <= width <= 10000 and 0 <= height <= 10000:
            return True, width, height
    return False, 0, 0


class _getProfileDataFromDatabase:
    def __init__(self, name):
        self.name = name
        self.shape_coords = None
        self.shape_name = None
        self.synonyms = None
        for item in data:
            for i in item.values():
                synonymList = i[0]["synonyms"]
                if self.name.lower() in [synonym.lower() for synonym in synonymList]:
                    self.shape_coords = i[0]["shape_coords"]
                    self.shape_name = i[0]["shape_name"]
                    self.synonyms = i[0]["synonyms"]
        if self.shape_coords == None:
            check_rect, width, height = is_rectangle_format(name)
            if check_rect:
                self.shape_coords = [width, height]
                self.shape_name = "Rectangle"
                self.synonyms = name


def profile_by_name(name1) -> Profile:
    profile_data = _getProfileDataFromDatabase(name1)
    if profile_data == None:
        print(f"profile {name1} not recognised")
    profile_name = profile_data.shape_name
    if profile_name == None:
        structural_fallback_element = "HEA100"
        profile_data = _getProfileDataFromDatabase(structural_fallback_element)
        print(
            f"Error, profile '{name1}' not recognised, define in {jsonFile} | fallback: '{structural_fallback_element}'"
        )
        profile_name = profile_data.shape_name
    name = profile_data.name
    coords = profile_data.shape_coords
    if profile_name == "C-channel parallel flange":
        profile = CChannelParallelFlangeProfile(
            name, coords[0], coords[1], coords[2], coords[3], coords[4], coords[5]
        )
    elif profile_name == "C-channel sloped flange":
        profile = CChannelSlopedFlangeProfile(
            name,
            coords[0],
            coords[1],
            coords[2],
            coords[3],
            coords[4],
            coords[5],
            coords[6],
            coords[7],
            coords[8],
        )
    elif profile_name == "I-shape parallel flange":
        profile = IShapeParallelFlangeProfile(
            name, coords[0], coords[1], coords[2], coords[3], coords[4]
        )
    elif profile_name == "I-shape sloped flange":
        profile = IShapeParallelFlangeProfile(
            name, coords[0], coords[1], coords[2], coords[3], coords[4]
        )
        # Todo: add sloped flange shape
    elif profile_name == "Rectangle":
        profile = RectangleProfile(name, coords[0], coords[1])
    elif profile_name == "Round":
        profile = RoundProfile(name, coords[1])
    elif profile_name == "Round tube profile":
        profile = RoundtubeProfile(name, coords[0], coords[1])
    elif profile_name == "LAngle":
        profile = LAngleProfile(
            name,
            coords[0],
            coords[1],
            coords[2],
            coords[3],
            coords[4],
            coords[5],
            coords[6],
            coords[7],
        )
    elif profile_name == "TProfile":
        profile = TProfileRounded(
            name,
            coords[0],
            coords[1],
            coords[2],
            coords[3],
            coords[4],
            coords[5],
            coords[6],
            coords[7],
            coords[8],
        )
    elif profile_name == "Rectangle Hollow Section":
        profile = RectangleHollowSectionProfile(
            name, coords[0], coords[1], coords[2], coords[3], coords[4]
        )
    return profile


def justification_to_vector(
    plycrv2D: PolyCurve, XJustifiction, Yjustification, ey=None, ez=None
):

    # print(XJustifiction)
    xval = []
    yval = []
    for i in plycrv2D.curves:
        xval.append(i.start.x)
        yval.append(i.start.y)

    # Rect
    xmin = min(xval)
    xmax = max(xval)
    ymin = min(yval)
    ymax = max(yval)

    b = xmax - xmin
    h = ymax - ymin

    # print(b, h)

    dxleft = -xmax
    dxright = -xmin
    dxcenter = dxleft - 0.5 * b  # CHECK
    dxorigin = 0

    dytop = -ymax
    dybottom = -ymin
    dycenter = dytop - 0.5 * h  # CHECK
    dyorigin = 0

    if XJustifiction == "center":
        dx = dxorigin  # TODO
    elif XJustifiction == "left":
        dx = dxleft
    elif XJustifiction == "right":
        dx = dxright
    elif XJustifiction == "origin":
        dx = dxorigin  # TODO
    else:
        dx = 0

    if Yjustification == "center":
        dy = dyorigin  # TODO
    elif Yjustification == "top":
        dy = dytop
    elif Yjustification == "bottom":
        dy = dybottom
    elif Yjustification == "origin":
        dy = dyorigin  # TODO
    else:
        dy = 0

    # print(dx, dy)
    v1 = Vector(dx, dy)
    # v1 = Vector2(0, 0)

    return v1



class Extrusion(Meshable):
    # Extrude a 2D polycurve to a 3D mesh or solid
    """The Extrusion class represents the process of extruding a 2D polycurve into a 3D mesh or solid form. It is designed to handle geometric transformations and properties related to the extrusion process."""

    def __init__(self, polycurve: PolyCurve, extrusion_vector: Vector):
        """The Extrusion class extrudes a 3d polycurve into a 3D mesh or solid form.

        all the extrusion class does, is save a polycurve and an extrusion vector.
          the polycurve will be translated by the extrusion vector to get the 'top' face, the existing polycurve is the 'bottom' face.

        - `bottom_curve` (PolyCurve): the 3d polycurve defining the bottom face
        - `extrusion_vector` (Vector): we'll translate bottom_curve by this vector to get the top curve.
        """

        self.bottom_curve = PolyCurve(polycurve)
        """the 3d polycurve defining the bottom face"""
        self.extrusion_vector = Vector(extrusion_vector)
        """we'll translate bottom_curve by this vector to get the top curve."""

    @staticmethod
    def by_2d_polycurve_vector(
        polycurve: PolyCurve,
        start_point: Point,
        extrusion_vector: Vector,
        angle: float = 0,
    ) -> "Extrusion":
        """Creates an extrusion from a 2D polycurve along a specified vector.
        This method extrudes a 2D polycurve into a 3D form by translating it to a specified start point and direction. The extrusion is created perpendicular to the polycurve's plane, extending it to the specified height.

        #### Parameters:
        - `polycurve_2d` (PolyCurve): The 2D polycurve to be extruded.
        - `height` (float): The height of the extrusion.
        - `cs_old` (CoordinateSystem): The original coordinate system of the polycurve.
        - `start_point` (Point): The start point for the extrusion in the new coordinate system.
        - `direction_vector` (Vector): The direction vector along which the polycurve is extruded.

        #### Returns:
        `Extrusion`: An Extrusion object representing the 3D form of the extruded polycurve.

        #### Example usage:
        ```python
        extrusion = Extrusion.by_2d_polycurve_height_vector(polycurve_2d, 10, oldCS, startPoint, directionVec)
        ```
        """
        direction = extrusion_vector.normalized

        # since we don't have an up vector, we will need to determine how to rotate this extrusion ourselves. we assume that y must be up.
        if direction == Vector.z_axis:
            transform = Matrix.translate(start_point)
        else:
            # new x = horizontal (xy)
            x_vector = Vector.cross_product(direction, Vector.z_axis).normalized
            # new y = more vertical (contains at least a little bit of z)
            y_vector = Vector.cross_product(direction, x_vector)
            transform = Matrix.by_origin_unit_axes(
                start_point, [x_vector, y_vector, direction]
            )
        if angle != 0:
            transform = transform * Matrix.rotate(angle, Vector.up)
        # translate to 3d here
        return Extrusion(
            transform * (dimension_changer(3) * polycurve), extrusion_vector
        )

    @staticmethod
    def by_polycurve_height(
        polycurve: PolyCurve, height: float, offset: float = 0
    ) -> "Extrusion":
        """Creates an extrusion from a PolyCurve with a specified height and base elevation.
        This method generates a vertical extrusion of a given PolyCurve. The PolyCurve is first translated vertically by `dz_loc`, then extruded to the specified `height`, creating a solid form.
        assumes the polycurve is wound counterclockwise.

        #### Parameters:
        - `polycurve` (PolyCurve): The PolyCurve to be extruded. expected to be flat!
        - `height` (float): The height of the extrusion.
        - `offset` (float): The base elevation offset from the original plane of the PolyCurve.

        #### Returns:
        `Extrusion`: An Extrusion object that represents the 3D extruded form of the input PolyCurve.

        #### Example usage:
        ```python
        extrusion = Extrusion.by_polycurve_height(polycurve, 5, 0)
        ```
        """

        extrusion_direction = Vector.cross_product(
            (polycurve[1].end - polycurve[0].start).normalized,
            (polycurve[-1].end - polycurve[0].start).normalized,
        )

        return Extrusion(
            (
                polycurve
                if offset == 0
                else Matrix.translate(extrusion_direction * offset) * polycurve
            ),
            extrusion_direction * height,
        )

    @staticmethod
    def from_3d_rect(rect: Rect) -> Self:
        """Generates an extrusion representing a cuboid from the 3D bounding box dimensions.

        #### Returns:
        `Extrusion`: An Extrusion object that represents a cuboid, matching the dimensions and orientation of the bounding box.

        #### Example usage:
        ```python
        bbox2d = Rect().by_dimensions(length=100, width=50)
        cs = CoordinateSystem()
        bbox3d = BoundingBox3d().convert_boundingbox_2d(bbox2d, cs, height=30)
        cuboid = bbox3d.to_cuboid()
        # Generates a cuboid extrusion based on the 3D bounding box
        ```
        """
        return Extrusion(
            Matrix.translate(Vector(0, 0, rect.p0.z))
            * PolyCurve.by_points(rect.corners(2)),
            Vector(0, 0, rect.size.z),
        )

    def to_mesh(self, settings: TesselationSettings) -> Mesh:
        mesh = Mesh()

        segmentated_polygon = self.bottom_curve.segmentate(settings)
        point_count = len(segmentated_polygon)

        # bottom face (face winding is reversed, but vertice winding isn't)
        mesh.vertices += [Point(point) for point in segmentated_polygon]

        mesh.faces.append(list(reversed(range(point_count))))

        # top face
        mesh.faces.append(list(range(point_count, point_count * 2)))
        for point_index in range(point_count):
            mesh.vertices.append(
                segmentated_polygon[point_index] + self.extrusion_vector
            )

        # when the height of an extrusion is 0, we only have to add the top / bottom (it doesn't really matter) side mesh. it would just cause z-buffer glitching
        if self.extrusion_vector.length_squared > 0:
            # other faces

            # Sides
            for current_indice in range(point_count):
                next_indice = (current_indice + 1) % point_count
                face = [
                    current_indice,
                    next_indice,  # bottom
                    next_indice + point_count,
                    current_indice + point_count,  # top
                ]
                mesh.faces.append(face)
        mesh.set_solid_color(settings.fallback_color)
        return mesh



# ToDo Na update van color moet ook de colorlist geupdate worden
class Beam(Serializable, Meshable):
    def __init__(
        self,
        start: Point,
        end: Point,
        profile: Profile | str,
        name: str = "Beam",
        material: Material = BaseSteel,
        angle: float = 0,
        justification: list[str] | Vector = Vector(),
    ):
        if isinstance(profile, str):
            profile = profile_by_name(profile)

        if not isinstance(justification, Vector):
            justification = justification_to_vector(
                profile.curve, justification[0], justification[1]
            )

        self.name = name
        self.comments = None
        self.start = start
        self.end = end
        self.profile = profile
        self.material = material
        self.angle = angle
        self.justification = justification

        self.profile_data = (
            None  # 2D polycurve of the sectionprofile (DOUBLE TO BE REMOVED)
        )
        self.centerbottom = None

    @property
    def extrusion(self) -> Extrusion:
        """heavy!"""
        return Extrusion.by_2d_polycurve_vector(
            self.profile.curve, self.start, self.end - self.start
        )

    def to_mesh(self, settings: TesselationSettings) -> Mesh:
        self.extrusion.to_mesh(settings)


Column = Beam
# columns and beams are the same, the profiles are the same, but they function as beams or columns.


# Rule: line, whitespace, line whitespace etc., scale
HiddenLine1 = ["Hidden Line 1", [1, 1], 100]
# Rule: line, whitespace, line whitespace etc., scale
HiddenLine2 = ["Hidden Line 2", [2, 1], 100]
# Rule: line, whitespace, line whitespace etc., scale
Centerline = ["Center Line 1", [8, 2, 2, 2], 100]


def line_to_pattern(baseline: 'Line', pattern_obj) -> 'list':
	"""Converts a baseline (Line object) into a list of line segments based on a specified pattern.
	This function takes a line (defined by its start and end points) and a pattern object. The pattern object defines a repeating sequence of segments to be applied along the baseline. The function calculates the segments according to the pattern and returns a list of Line objects representing these segments.

	#### Parameters:
	- `baseline` (Line): The baseline along which the pattern is to be applied. This line is defined by its start and end points.
	- `pattern_obj` (Pattern): The pattern object defining the sequence of segments. The pattern object should have the following structure:
		- An integer representing the number of repetitions.
		- A list of floats representing the lengths of each segment in the pattern.
		- A float representing the scale factor for the lengths of the segments in the pattern.

	#### Returns:
	`list`: A list of Line objects that represent the line segments created according to the pattern along the baseline.

	#### Example usage:
	```python
	baseline = Line(Point(0, 0, 0), Point(10, 0, 0))
	pattern_obj = (3, [2, 1], 1)  # 3 repetitions, pattern of lengths 2 and 1, scale factor 1
	patterned_lines = line_to_pattern(baseline, pattern_obj)
	# patterned_lines will be a list of Line objects according to the pattern
	```

	The function works by calculating the total length of the pattern, the number of whole lengths of the pattern that fit into the baseline, and then generating the line segments according to these calculations. If the end of the baseline is reached before completing a pattern sequence, the last segment is adjusted to end at the baseline's end point.
	"""
	# this converts a line to list of lines based on a pattern
	origin = baseline.start
	dir = Vector.by_two_points(baseline.start, baseline.end)
	unityvect = dir.normalized

	Pattern = pattern_obj
	l = baseline.length
	patternlength = sum(Pattern[1]) * Pattern[2]
	# number of whole lengths of the pattern
	count = math.floor(l / patternlength)
	lines = []

	startpoint = origin
	ll = 0
	rl = 10000
	for i in range(count + 1):
		n = 0
		for i in Pattern[1]:
			deltaV = unityvect * (i * Pattern[2])
			dl = deltaV.length
			if rl < dl:  # this is the last line segment on the line where the pattern is going to be cut into pieces.
				endpoint = baseline.end
			else:
				endpoint = Point.translate(startpoint, deltaV)
			if n % 2:
				a = 1 + 1
			else:
				lines.append(Line(start=startpoint, end=endpoint))
			if rl < dl:
				break  # end of line reached
			startpoint = endpoint
			n = n + 1
			ll = ll + dl  # total length
			rl = l - ll  # remaining length within the pattern
		startpoint = startpoint
	return lines

def polycurve_to_pattern(polycurve: 'PolyCurve', pattern_obj) -> 'list':
	res = []
	for i in polycurve.curves:
		res.append(line_to_pattern(i,pattern_obj))
	return res

seqChar = "A B C D E F G H I J K L M N O P Q R S T U V W X Y Z AA AB AC"
seqNumber = "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24"


class GridheadType(Serializable):
    def __init__(
        self, name, diameter: float = 150, font_family="calibri", text_height=200
    ):

        self.name = name
        self.diameter = diameter
        self.curves = []
        self.diameter = 150
        self.text_height = 200
        self.font_family = font_family
        self.geom()

    @property
    def radius(self):
        return self.diameter / 2

    def geom(self):
        radius = self.radius
        self.curves.append(
            Arc.by_start_mid_end(
                Point(-radius, radius, 0),
                Point(0, radius * 2, 0),
                Point(radius, radius, 0),
            )
        )
        self.curves.append(
            Arc.by_start_mid_end(
                Point(-radius, radius, 0), Point(0, 0, 0), Point(radius, radius, 0)
            )
        )
        # origin is at center of circle


GHT30 = GridheadType("2.5 mm", 400, "calibri", 200)

GHT50 = GridheadType("GHT50", 600, "calibri", 350)


class GridHead:
    def __init__(self):

        self.grid_name: str = "A"
        self.grid_head_type = GHT50
        self.radius = GHT50.radius
        self.CS: CoordinateSystem = Matrix()
        self.x: float = 0.5
        self.y: float = 0
        self.text_curves = []
        self.curves = []
        self.__textobject()
        self.__geom()

    def __geom(self):
        # CStot = CoordinateSystem.translate(self.CS,Vector(0,self.grid_head_type.radius,0))
        for i in self.grid_head_type.curves:
            self.curves.append(self.CS * i)

    def __textobject(self):
        cs_text = self.CS
        # to change after center text function is implemented
        cs_text_new = CoordinateSystem.move_local(cs_text, -100, 40, 0)
        self.text_curves = Text(
            text=self.grid_name,
            font_family=self.grid_head_type.font_family,
            height=self.grid_head_type.text_height,
            cs=cs_text_new,
        ).write()

    @staticmethod
    def by_name_gridheadtype_y(name, cs: CoordinateSystem, gridhead_type, y: float):
        GH = GridHead()
        GH.grid_name = name
        GH.grid_head_type = gridhead_type
        GH.CS = cs
        GH.x = 0.5
        GH.y = y
        GH.__textobject()
        GH.__geom()
        return GH

    def write(self, project):
        for x in self.text_curves:
            project.objects.append(x)
        for y in self.curves:
            project.objects.append(y)


class GridLine:
    def __init__(self):
        self.line = None
        self.start = None
        self.end = None
        self.direction: Vector = Vector(0, 1, 0)
        self.grid_head_type = GHT50
        self.name = None
        self.bulbStart = False
        self.bulbEnd = True
        self.cs_end: CoordinateSystem = CoordinateSystem()  # Maarten
        self.grid_heads = []

    def __cs(self, line):
        self.direction = line.direction
        vect3 = Vector.rotate(self.direction, math.radians(-90))
        self.cs_end = CoordinateSystem.by_origin_unit_axes(
            line.end, [vect3, self.direction, Vector.z_axis]
        )

    @classmethod
    def by_startpoint_endpoint(cls, line, name):
        # Create panel by polycurve
        g1 = GridLine()
        g1.start = line.start
        g1.end = line.start
        g1.name = name
        g1.__cs(line)
        g1.line = line_to_pattern(line, Centerline)
        # g1.__grid_heads()
        return g1

    def __grid_heads(self):
        if self.bulbEnd == True:
            self.grid_heads.append(
                GridHead.by_name_gridheadtype_y(
                    self.name, self.cs_end, self.grid_head_type, 0
                )
            )

    def write(self, project):
        for x in self.line:
            project.objects.append(x)
        for y in self.grid_heads:
            y.write(project)
        return self


def parse_grid_distances(grid_axis_description: str) -> list[float]:
    # Function to create grids from the format 0, 4x5400, 4000, 4000 to absolute XYZ-values
    distances = []
    distances.append(0)
    distance = 0.0
    # GridsNew.append(distance)
    for sub_grid_description in grid_axis_description.split():
        # del Grids[0]
        if "x" in sub_grid_description:
            spl = sub_grid_description.split("x")
            count = int(spl[0])
            width = float(spl[1])
            distance += width
            for index in range(count):
                distance += width
                distances.append(distance)
        else:
            distance = distance + float(sub_grid_description)
            distances.append(distance)
    return distances


class Grid:
    # rectangle Gridsystem
    def __init__(self):
        self.gridsX = None
        self.gridsY = None
        self.dimensions = []
        self.name = None

    @classmethod
    def by_spacing_labels(cls, spacingX, labelsX, spacingY, labelsY, gridExtension):
        gs = Grid()
        # Create gridsystem
        # spacingXformat = "0 3000 3000 3000"
        GridEx = gridExtension

        GridsX = parse_grid_distances(spacingX)
        Xmax = max(GridsX)
        GridsXLable = labelsX.split()
        GridsY = parse_grid_distances(spacingY)
        Ymax = max(GridsY)
        GridsYLable = labelsY.split()

        gridsX = []
        dimensions = []
        count = 0
        ymaxdim1 = Ymax + GridEx - 300
        ymaxdim2 = Ymax + GridEx - 0
        xmaxdim1 = Xmax + GridEx - 300
        xmaxdim2 = Xmax + GridEx - 0
        for i in GridsX:
            gridsX.append(
                GridLine.by_startpoint_endpoint(
                    Line(Point(i, -GridEx, 0), Point(i, Ymax + GridEx, 0)),
                    GridsXLable[count],
                )
            )
            try:
                dim = Dimension(
                    Point(i, ymaxdim1, 0),
                    Point(GridsX[count + 1], ymaxdim1, 0),
                    DT2_5_mm,
                )
                gs.dimensions.append(dim)
            except:
                pass
            count = count + 1

        # Totaal maatvoering 1
        dim = Dimension(
            Point(GridsX[0], ymaxdim2, 0), Point(Xmax, ymaxdim2, 0), DT2_5_mm
        )
        gs.dimensions.append(dim)

        # Totaal maatvoering 2
        dim = Dimension(
            Point(xmaxdim2, GridsY[0], 0), Point(xmaxdim2, Ymax, 0), DT2_5_mm
        )
        gs.dimensions.append(dim)

        gridsY = []
        count = 0
        for i in GridsY:
            gridsY.append(
                GridLine.by_startpoint_endpoint(
                    Line(Point(-GridEx, i, 0), Point(Xmax + GridEx, i, 0)),
                    GridsYLable[count],
                )
            )
            try:
                dim = Dimension(
                    Point(xmaxdim1, i, 0), Point(xmaxdim1, GridsY[count + 1], 0)
                )  # ,DT3_5_mm)
                gs.dimensions.append(dim)
            except:
                pass
            count = count + 1
        gs.gridsX = gridsX
        gs.gridsY = gridsY
        return gs

    def write(self, project):
        for x in self.gridsX:
            project.objects.append(x)
            for i in x.grid_heads:
                i.write(project)
        for y in self.gridsY:
            project.objects.append(y)
            for j in y.grid_heads:
                j.write(project)
        for z in self.dimensions:
            z.write(project)
        return self


class Door:
	def __init__(self):
		
		self.name = None
		self.verts = None
		self.faces = None
		self.topsurface = None
		self.bottomsurface = None
		# self.polycurve = None or self.profile
		self.parms = None

	@classmethod
	def by_mesh(self, verts=list, faces=list):
		door = Door()
		door.verts = verts
		door.faces = faces
		return door

	def __str__(self) -> str:
		return f"{self.type}(Name={self.name})"

class BuildingPy(Serializable):
    def __init__(self, name=None, number=None):
        self.name: str = name
        self.number: str = number
        # settings
        self.debug: bool = True
        self.objects = []
        self.units = "mm"
        self.decimals = 3  # not fully implemented yet

        self.origin = Point(0, 0, 0)
        self.default_font = "calibri"
        self.scale = 1000
        self.font_height = 500
        self.repr_round = 3
        # prefix objects (name)
        # Geometry settings

        # export selection info
        self.domain = None
        self.applicationId = "OPEN-AEC BuildingPy"

        # different settings for company's?

        self.round: bool = (
            False  # If True then arcs will be segmented. Can be used in Speckle.
        )

        # functie polycurve of iets van een class/def
        self.autoclose: bool = True  # new self.closed

        # nodes
        self.node_merge = True  # False not yet created
        self.node_diameter = 250
        self.node_threshold = 50

        # Speckle settings
        self.speckleserver = "app.speckle.systems"

        # FreeCAD settings

    def save(self, file_name="project/data.json"):
        Serializable.save(file_name)

        type_count = defaultdict(int)
        for serialized_item in self.objects:
            # item = json.loads(serialized_item)
            type_count[serialized_item.__class__.__name__] += 1

        total_items = len(self.objects)

        print(f"\nTotal saved items to '{file_name}': {total_items}")
        print("Type counts:")
        for item_type, count in type_count.items():
            print(f"{item_type}: {count}")
            
    @staticmethod
    def open(path="project/data.json") -> 'BuildingPy':
        filename, file_extension = os.path.splitext(path)
        project = BuildingPy()
        match file_extension:
            case ".json":
                project.open(path)
            case ".ifc":
                from exchange.IFC import LoadIFC
                LoadIFC(path, project)

    def to_speckle(self, streamid, commitstring=None):
        from exchange.speckle import (
            translateObjectsToSpeckleObjects,
            TransportToSpeckle,
        )

        speckleobj = translateObjectsToSpeckleObjects(self, self.objects)
        TransportToSpeckle(self.speckleserver, streamid, speckleobj, commitstring)

    def to_freecad(self):
        from exchange.Freecad_Bupy import translateObjectsToFreeCAD

        translateObjectsToFreeCAD(self.objects)

    def to_ifc(self, name="My IFC Project"):
        from exchange.IFC import translateObjectsToIFC, CreateIFC

        ifc_project = CreateIFC()
        ifc_project.add_project(name)
        ifc_project.add_site("My Site")
        ifc_project.add_building("Building A")
        ifc_project.add_story("Ground Floor")
        ifc_project.add_story("G2Floor")
        translateObjectsToIFC(self.objects, ifc_project)
        ifc_project.export(f"{name}.ifc")

    def __iadd__(self, new_object):
        self.objects.append(new_object)
        return self


# [!not included in BP singlefile - end]



class Floor:
	def __init__(self):
		
		self.extrusion = None
		self.thickness = 0
		self.name = None
		self.description = None
		self.perimeter: float = 0
		self.mai = None
		self.origincurve = None
		self.points = None
		self.thickness = None



class Interval:
    """The `Interval` class is designed to represent a mathematical interval, providing a start and end value along with functionalities to handle intervals more comprehensively in various applications."""

    def __init__(self, start: float, end: float):
        """Initializes a new Interval instance.

        - `start` (float): The starting value of the interval.
        - `end` (float): The ending value of the interval.
        - `interval` (list, optional): A list that may represent subdivided intervals or specific points within the start and end bounds, depending on the context or method of subdivision.

        """
        self.start = start
        self.end = end
        self.interval = None

    @classmethod
    def by_start_end_count(self, start: float, end: float, count: int) -> "Interval":
        """Generates a list of equidistant points within the interval.

        This method divides the interval between the start and end values into (count - 1) segments, returning an Interval object containing these points.

        #### Parameters:
                start (float): The starting value of the interval.
                end (float): The ending value of the interval.
                count (int): The total number of points to generate, including the start and end values.

        #### Returns:
                Interval: An Interval instance with its `interval` attribute populated with the generated points.

        #### Example usage:
        ```python

        ```
        """
        intval = []
        numb = start
        delta = end - start
        for i in range(count):
            intval.append(numb)
            numb = numb + (delta / (count - 1))
        self.interval = intval
        return self

    def __str__(self) -> str:
        """Generates a string representation of the Interval.

        #### Returns:
                str: A string representation of the Interval, primarily indicating its class name.

        #### Example usage:
        ```python

        ```
        """
        return f"{__class__.__name__}"


class Level:
	def __init__(self):
		
		self.name = None
		self.polycurve = None
		self.plane = None
		self.parms = None
		self.elevation = None

	@classmethod
	def by_point(self, point=Point, name=str):
		if isinstance(point, Point):
			Lvl = Level()
			XY_plane = [Vector(x=1, y=0, z=0), Vector(x=0, y=1, z=0)]
			Lvl.plane = Plane.by_two_vectors_origin(
				XY_plane[0], XY_plane[1], point)
			Lvl.polycurve = Rect_XY(Point.to_vector(point), 1000, 1000)
			Lvl.elevation = point.z
			if name != None:
				Lvl.name = name
			return Lvl
		elif isinstance(point, Point):
			pass  # 0

	def __str__(self) -> str:
		return f"{self.type}(Name={self.name}, Elevation={self.elevation})"

# check if there are innercurves inside the outer curve.


class Surface:
	"""Represents a surface object created from PolyCurves."""
	def __init__(self) -> 'Surface':
		"""This class is designed to manage and manipulate surfaces derived from PolyCurve objects. It supports the generation of mesh representations, serialization/deserialization, and operations like filling and voiding based on PolyCurve inputs.
	   
		- `type` (str): The class name, "Surface".
		- `mesh` (list): A list of meshes that represent the surface.
		- `length` (float): The total length of the PolyCurves defining the surface.
		- `area` (float): The area of the surface, excluding any inner PolyCurves.
		- `offset` (float): An offset value for the surface.
		- `name` (str): The name of the surface.
		- `id` (str): A unique identifier for the surface.
		- `PolyCurveList` (list): A list of PolyCurve objects that define the surface.
		- `origincurve` (PolyCurve): The original PolyCurve from which the surface was created.
		- `color` (int): The color of the surface, represented as an integer.
		- `colorlst` (list): A list of color values associated with the surface.
		"""       
		self.mesh = []
		self.offset = 0
		self.name = None
		
		self.outer_Polygon = None
		self.inner_Polygon = []

		self.outer_Surface = None
		self.inner_Surface = []
		# self.byPatch = self.fill(self)
		# if color is None:
		#     self.color = Color.rgb_to_int(Color.Components("gray"))
		# else:
		#     self.color = color



	@classmethod
	def by_patch_inner_and_outer(self, Polygons: 'list[Polygon]') -> 'Surface':
		valid_polygons = [p for p in Polygons if p is not None]
		sorted_polygons = sorted(valid_polygons, key=lambda p: p.length, reverse=True)

		if len(sorted_polygons) == 0:
			raise ValueError("No valid polygons provided")

		outer_Polygon = sorted_polygons[0]

		inner_Polygon = sorted_polygons[1:] if len(sorted_polygons) > 1 else []

		return self.by_patch(outer_Polygon, inner_Polygon)


	@classmethod
	def by_patch(self, outer_Polygon: Polygon, inner_Polygon: 'list[Polygon]' = None) -> 'Surface':
		srf = Surface()
		srf.outer_Polygon = outer_Polygon
		srf.inner_Polygon = inner_Polygon
		srf.outer_Surface = Extrusion.by_polycurve_height(outer_Polygon, 0, 0)
		srf.inner_Surface = []
		if inner_Polygon != None:
			for inner in srf.inner_Polygon:
				srf.inner_Surface.append(Extrusion.by_polycurve_height(inner, 0, 0))

		return srf

	def void(self, polyCurve: PolyCurve):
		"""Creates a void in the Surface based on the specified PolyCurve.
		This method identifies and removes a part of the Surface that intersects with the given PolyCurve, effectively creating a void in the Surface. It then updates the surface's mesh and color list to reflect this change.

		#### Parameters:
		- `polyCurve` (`PolyCurve`): The PolyCurve object that defines the area of the Surface to be voided.

		#### Example usage:
		```python
		surface.void(polyCurve)
		# A void is now created in the surface based on the specified PolyCurve.
		```
		"""
		# Find the index of the extrusion that intersects with the polyCurve
		pass

	def __id__(self):
		"""Returns the unique identifier of the Surface.
		This method provides a way to retrieve the unique ID of the Surface, which can be useful for tracking or identifying surfaces within a larger system.

		#### Returns:
		`str`: The unique identifier of the Surface.

		#### Example usage:
		```python
		id_str = surface.__id__()
		print(id_str)
		# Outputs the ID of the surface.
		```
		"""

	def __str__(self) -> str:
		return f"{self.__class__.__name__}({self.outer_Polygon}, {self.inner_Polygon})"

	

class NurbsSurface:  # based on point data / degreeU&countU / degreeV&countV?
	"""Represents a NURBS (Non-Uniform Rational B-Spline) surface."""
	def __init__(self) -> 'NurbsSurface':
		"""NurbsSurface is a mathematical model representing a 3D surface in terms of NURBS, a flexible method to represent curves and surfaces. It encompasses properties such as ID and type but is primarily defined by its control points, weights, and degree in the U and V directions.

		- `id` (str): A unique identifier for the NurbsSurface.
		- `type` (str): Class name, "NurbsSurface".
		"""
		

	def __id__(self) -> 'str':
		"""Returns the unique identifier of the NurbsSurface object.
		This method provides a standardized way to access the unique ID of the NurbsSurface, useful for identification and tracking purposes within a system that handles multiple surfaces.

		#### Returns:
		`str`: The unique identifier of the NurbsSurface, prefixed with "id:".

		#### Example usage:
		```python
		nurbs_surface = NurbsSurface()
		print(nurbs_surface.__id__())
		# Output format: "id:{unique_id}"
		```
		"""
		return f"id:{self.id}"

	def __str__(self) -> 'str':
		"""Generates a string representation of the NurbsSurface object.
		This method creates a string that summarizes the NurbsSurface, typically including its class name and potentially its unique ID, providing a concise overview of the object when printed or logged.

		#### Returns:
		`str`: A string representation of the NurbsSurface object.

		#### Example usage:
		```python
		nurbs_surface = NurbsSurface()
		print(nurbs_surface)
		# Output: "NurbsSurface({self})"
		```
		"""
		return f"{__class__.__name__}({self})"


class PolySurface:
	"""Represents a compound surface consisting of multiple connected surfaces."""
	def __init__(self) -> None:
		"""PolySurface is a geometric entity that represents a complex surface made up of several simpler surfaces. These simpler surfaces are typically connected along their edges. Attributes include an ID and type, with functionalities to manipulate and query the composite surface structure.
		
		- `id` (str): A unique identifier for the PolySurface.
		- `type` (str): Class name, "PolySurface".
		"""
		

	def __id__(self) -> 'str':
		"""Returns the unique identifier of the PolySurface object.
		Similar to the NurbsSurface, this method provides the unique ID of the PolySurface, facilitating its identification and tracking across various operations or within data structures that involve multiple surfaces.

		#### Returns:
		`str`: The unique identifier of the PolySurface, prefixed with "id:".

		#### Example usage:
		```python
		poly_surface = PolySurface()
		print(poly_surface.__id__())
		# Output format: "id:{unique_id}"
		```
		"""
		return f"id:{self.id}"

	def __str__(self) -> 'str':
		"""Generates a string representation of the PolySurface object.
		Provides a simple string that identifies the PolySurface, mainly through its class name. This is helpful for debugging, logging, or any scenario where a quick textual representation of the object is beneficial.

		#### Returns:
		`str`: A string representation of the PolySurface object.

		#### Example usage:
		```python
		poly_surface = PolySurface()
		print(poly_surface)
		# Output: "PolySurface({self})"
		```
		"""
		return f"{__class__.__name__}({self})"

# EVERYWHERE FOR EACH OBJECT A ROTATION/POSITION
# Make sure that the objects can be merged!


class WurksRaster3d(Serializable):
    def __init__(self):

        self.bottom = None
        self.top = None
        self.name = "x"
        self.lines = None

    def by_line(self, lines: Line, bottom: float, top: float):
        self.bottom = Vector(0, 0, bottom)
        self.top = Vector(0, 0, top)
        self.lines = lines

        surfList = []
        for line in self.lines:
            pts = []
            pts.append(Point.translate(line.start, self.bottom))
            pts.append(Point.translate(line.end, self.bottom))
            pts.append(Point.translate(line.end, self.top))
            pts.append(Point.translate(line.start, self.top))
            project.objects.append(Surface(PolyCurve.by_points(pts)))
            surfList.append(Surface(PolyCurve.by_points(pts)))

        print(f"{len(surfList)}* {self.__class__.__name__} has been created")


class WurksPedestal:
    def __init__(self):
        self.topfilename = "temp\\jonathan\\pedestal_top.dxf"
        self.basefilename = "temp\\jonathan\\pedestal_foot.dxf"
        self.diameter = 10
        self.topheight = 3
        self.baseheight = 3
        self.cache = {}
        self.top_dxf = None
        self.base_dxf = None

    def load_dxf(self, filename):
        if filename in self.cache:
            return self.cache[filename]
        else:
            dxf = ReadDXF(filename).polycurve
            self.cache[filename] = dxf
            return dxf

    def load_top_dxf(self):
        if self.top_dxf is None:
            self.top_dxf = self.load_dxf(self.topfilename)
        return self.top_dxf

    def load_base_dxf(self):
        if self.base_dxf is None:
            self.base_dxf = self.load_dxf(self.basefilename)
        return self.base_dxf

    def by_point(self, points, height, rotation=None):
        if isinstance(points, Point):
            points = [points]

        top = self.load_top_dxf()
        base = self.load_base_dxf()

        for point in points:
            topcenter = Point.difference(top.centroid(), point)
            translated_top = top.translate(Point.to_vector(topcenter))
            project.objects.append(
                Extrusion.by_polycurve_height(translated_top, self.topheight, 0)
            )

            frame = Rect(
                Vector(
                    x=(translated_top.centroid().x) - (self.diameter / 2),
                    y=(translated_top.centroid().y) - (self.diameter / 2),
                    z=point.z - self.topheight,
                ),
                self.diameter,
                self.diameter,
            )
            project.objects.append(
                Extrusion.by_polycurve_height(
                    frame, height - self.baseheight - self.topheight, 0
                )
            )

            basecenter = Point.difference(base.centroid(), point)
            translated_base = base.translate(Point.to_vector(basecenter))
            project.objects.append(
                Extrusion.by_polycurve_height(translated_base, self.baseheight, -height)
            )

        print(f"{len(points)}* {self.__class__.__name__} has been created")

    pass  # pootje, voet diameter(vierkant), verstelbare hoogte inregelen,


class WurksComputerFloor:  # centerpoint / rotation / panel pattern / ply
    pass  # some type of floor object


class WurksFloorFinish:
    pass  # direction / pattern / ect


class WorkPlane:
    def __init__(self):
        self.length = None
        self.width = None
        self.points = []

    def create(self, length: float = None, width: float = None) -> str:
        self.length = length or 1000
        self.width = width or 1000
        rect = Rect(Vector(0, 0, 0), self.length, self.width)
        for pt in rect.points:
            self.points.append(pt)
        project.objects.append(rect)
        print(f"1* {self.__class__.__name__} has been created")
        return Rect(Vector(0, 0, 0), self.length, self.width)

    pass  # pootje, voet diameter(vierkant), verstelbare hoogte inregelen,


WorkPlane = WorkPlane()
# rotation(Vector)/#volume/#scale



class Panel(Serializable, Meshable):
    # Panel
    def __init__(self, extrusion: Extrusion, material: Material, name: str = None):
        self.extrusion = extrusion
        self.material = material
        self.name = name

    def to_mesh(self, settings: TesselationSettings) -> Mesh:
        colorSettings = TesselationSettings(settings.max_angle, self.material.color.int)
        return self.extrusion.to_mesh(colorSettings)

    @classmethod
    def by_polycurve_thickness(
        self,
        polycurve: PolyCurve,
        thickness: float,
        offset: float = 0,
        name: str = None,
        material=BaseTimber,
    ):
        # Create panel by polycurve
        p1 = Panel(
            Extrusion.by_polycurve_height(polycurve, thickness, offset), material, name
        )
        return p1

    @classmethod
    def by_baseline_height(
        self,
        baseline: Line,
        height: float,
        thickness: float,
        name: str = None,
        material=BaseTimber,
    ):
        # place panel vertical from baseline
        return Panel(
            Extrusion.by_polycurve_height(
                PolyCurve.by_points(
                    [
                        baseline.start,
                        baseline.end,
                        baseline.end + Vector(0, 0, height),
                        baseline.start + Vector(0, 0, height),
                    ]
                ),
                thickness,
                0,
            ),
            material,
            name,
        )


MIN_DEPTH = 5
ERROR = 1e-12


def segment_length(curve, start, end, start_point, end_point, error, min_depth, depth):
    """Recursively approximates the length by straight lines"""
    mid = (start + end) / 2
    mid_point = curve.point(mid)
    length = abs(end_point - start_point)
    first_half = abs(mid_point - start_point)
    second_half = abs(end_point - mid_point)

    length2 = first_half + second_half
    if (length2 - length > error) or (depth < min_depth):
        # Calculate the length of each segment:
        depth += 1
        return segment_length(
            curve, start, mid, start_point, mid_point, error, min_depth, depth
        ) + segment_length(
            curve, mid, end, mid_point, end_point, error, min_depth, depth
        )
    # This is accurate enough.
    return length2


class PathSegment(ABC):
    @abstractmethod
    def point(self, pos):
        """Returns the coordinate point (as a complex number) of a point on the path,
        as expressed as a floating point number between 0 (start) and 1 (end).
        """

    @abstractmethod
    def tangent(self, pos):
        """Returns a vector (as a complex number) representing the tangent of a point
        on the path as expressed as a floating point number between 0 (start) and 1 (end).
        """

    @abstractmethod
    def length(self, error=ERROR, min_depth=MIN_DEPTH):
        """Returns the length of a path.

        The CubicBezier and Arc lengths are non-exact and iterative and you can select to
        either do the calculations until a maximum error has been achieved, or a minimum
        number of iterations.
        """


class NonLinear(PathSegment):
    """A line that is not straight

    The base of Arc, QuadraticBezier and CubicBezier
    """


class Linear(PathSegment):
    """A straight line

    The base for Line() and Close().
    """

    def __init__(self, start, end, relative=False):
        self.start = start
        self.end = end
        self.relative = relative

    def __ne__(self, other):
        if not isinstance(other, Line):
            return NotImplemented
        return not self == other

    def point(self, pos):
        distance = self.end - self.start
        return self.start + distance * pos

    def tangent(self, pos):
        return self.end - self.start

    def length(self, error=None, min_depth=None):
        distance = self.end - self.start
        return sqrt(distance.real**2 + distance.imag**2)


class Line(Linear):
    def __init__(self, start, end, relative=False, vertical=False, horizontal=False):
        self.start = start
        self.end = end
        self.relative = relative
        self.vertical = vertical
        self.horizontal = horizontal

    def __repr__(self):
        return f"Line(start={self.start}, end={self.end})"

    def __eq__(self, other):
        if not isinstance(other, Line):
            return NotImplemented
        return self.start == other.start and self.end == other.end

    def _d(self, previous):
        x = self.end.real
        y = self.end.imag
        if self.relative:
            x -= previous.end.real
            y -= previous.end.imag

        if self.horizontal and self.is_horizontal_from(previous):
            cmd = "h" if self.relative else "H"
            return f"{cmd} {x:G},{y:G}"

        if self.vertical and self.is_vertical_from(previous):
            cmd = "v" if self.relative else "V"
            return f"{cmd} {y:G}"

        cmd = "l" if self.relative else "L"
        return f"{cmd} {x:G},{y:G}"

    def is_vertical_from(self, previous):
        return self.start == previous.end and self.start.real == self.end.real

    def is_horizontal_from(self, previous):
        return self.start == previous.end and self.start.imag == self.end.imag


class CubicBezier(NonLinear):
    def __init__(self, start, control1, control2, end, relative=False, smooth=False):
        self.start = start
        self.control1 = control1
        self.control2 = control2
        self.end = end
        self.relative = relative
        self.smooth = smooth

    def __repr__(self):
        return (
            f"CubicBezier(start={self.start}, control1={self.control1}, "
            f"control2={self.control2}, end={self.end}, smooth={self.smooth})"
        )

    def __eq__(self, other):
        if not isinstance(other, CubicBezier):
            return NotImplemented
        return (
            self.start == other.start
            and self.end == other.end
            and self.control1 == other.control1
            and self.control2 == other.control2
        )

    def __ne__(self, other):
        if not isinstance(other, CubicBezier):
            return NotImplemented
        return not self == other

    def _d(self, previous):
        c1 = self.control1
        c2 = self.control2
        end = self.end

        if self.relative and previous:
            c1 -= previous.end
            c2 -= previous.end
            end -= previous.end

        if self.smooth and self.is_smooth_from(previous):
            cmd = "s" if self.relative else "S"
            return f"{cmd} {c2.real:G},{c2.imag:G} {end.real:G},{end.imag:G}"

        cmd = "c" if self.relative else "C"
        return f"{cmd} {c1.real:G},{c1.imag:G} {c2.real:G},{c2.imag:G} {end.real:G},{end.imag:G}"

    def is_smooth_from(self, previous):
        """Checks if this segment would be a smooth segment following the previous"""
        if isinstance(previous, CubicBezier):
            return self.start == previous.end and (self.control1 - self.start) == (
                previous.end - previous.control2
            )
        else:
            return self.control1 == self.start

    def set_smooth_from(self, previous):
        assert isinstance(previous, CubicBezier)
        self.start = previous.end
        self.control1 = previous.end - previous.control2 + self.start
        self.smooth = True

    def point(self, pos):
        """Calculate the x,y position at a certain position of the path"""
        return (
            ((1 - pos) ** 3 * self.start)
            + (3 * (1 - pos) ** 2 * pos * self.control1)
            + (3 * (1 - pos) * pos**2 * self.control2)
            + (pos**3 * self.end)
        )

    def tangent(self, pos):
        return (
            -3 * (1 - pos) ** 2 * self.start
            + 3 * (1 - pos) ** 2 * self.control1
            - 6 * pos * (1 - pos) * self.control1
            - 3 * pos**2 * self.control2
            + 6 * pos * (1 - pos) * self.control2
            + 3 * pos**2 * self.end
        )

    def length(self, error=ERROR, min_depth=MIN_DEPTH):
        """Calculate the length of the path up to a certain position"""
        start_point = self.point(0)
        end_point = self.point(1)
        return segment_length(self, 0, 1, start_point, end_point, error, min_depth, 0)


class QuadraticBezier(NonLinear):
    def __init__(self, start, control, end, relative=False, smooth=False):
        self.start = start
        self.end = end
        self.control = control
        self.relative = relative
        self.smooth = smooth

    def __repr__(self):
        return (
            f"QuadraticBezier(start={self.start}, control={self.control}, "
            f"end={self.end}, smooth={self.smooth})"
        )

    def __eq__(self, other):
        if not isinstance(other, QuadraticBezier):
            return NotImplemented
        return (
            self.start == other.start
            and self.end == other.end
            and self.control == other.control
        )

    def __ne__(self, other):
        if not isinstance(other, QuadraticBezier):
            return NotImplemented
        return not self == other

    def _d(self, previous):
        control = self.control
        end = self.end
        if self.relative and previous:
            control -= previous.end
            end -= previous.end

        if self.smooth and self.is_smooth_from(previous):
            cmd = "t" if self.relative else "T"
            return f"{cmd} {end.real:G},{end.imag:G}"

        cmd = "q" if self.relative else "Q"
        return f"{cmd} {control.real:G},{control.imag:G} {end.real:G},{end.imag:G}"

    def is_smooth_from(self, previous):
        """Checks if this segment would be a smooth segment following the previous"""
        if isinstance(previous, QuadraticBezier):
            return self.start == previous.end and (self.control - self.start) == (
                previous.end - previous.control
            )
        else:
            return self.control == self.start

    def set_smooth_from(self, previous):
        assert isinstance(previous, QuadraticBezier)
        self.start = previous.end
        self.control = previous.end - previous.control + self.start
        self.smooth = True

    def point(self, pos):
        return (
            (1 - pos) ** 2 * self.start
            + 2 * (1 - pos) * pos * self.control
            + pos**2 * self.end
        )

    def tangent(self, pos):
        return (
            self.start * (2 * pos - 2)
            + (2 * self.end - 4 * self.control) * pos
            + 2 * self.control
        )

    def length(self, error=None, min_depth=None):
        a = self.start - 2 * self.control + self.end
        b = 2 * (self.control - self.start)

        try:
            # For an explanation of this case, see
            # http://www.malczak.info/blog/quadratic-bezier-curve-length/
            A = 4 * (a.real**2 + a.imag**2)
            B = 4 * (a.real * b.real + a.imag * b.imag)
            C = b.real**2 + b.imag**2

            Sabc = 2 * sqrt(A + B + C)
            A2 = sqrt(A)
            A32 = 2 * A * A2
            C2 = 2 * sqrt(C)
            BA = B / A2

            s = (
                A32 * Sabc
                + A2 * B * (Sabc - C2)
                + (4 * C * A - B**2) * log((2 * A2 + BA + Sabc) / (BA + C2))
            ) / (4 * A32)
        except (ZeroDivisionError, ValueError):
            if abs(a) < 1e-10:
                s = abs(b)
            else:
                k = abs(b) / abs(a)
                if k >= 2:
                    s = abs(b) - abs(a)
                else:
                    s = abs(a) * (k**2 / 2 - k + 1)
        return s


class Arc(NonLinear):
    def __init__(self, start, radius, rotation, arc, sweep, end, relative=False):
        """radius is complex, rotation is in degrees,
        large and sweep are 1 or 0 (True/False also work)"""

        self.start = start
        self.radius = radius
        self.rotation = rotation
        self.arc = bool(arc)
        self.sweep = bool(sweep)
        self.end = end
        self.relative = relative

        self._parameterize()

    def __repr__(self):
        return (
            f"Arc(start={self.start}, radius={self.radius}, rotation={self.rotation}, "
            f"arc={self.arc}, sweep={self.sweep}, end={self.end})"
        )

    def __eq__(self, other):
        if not isinstance(other, Arc):
            return NotImplemented
        return (
            self.start == other.start
            and self.end == other.end
            and self.radius == other.radius
            and self.rotation == other.rotation
            and self.arc == other.arc
            and self.sweep == other.sweep
        )

    def __ne__(self, other):
        if not isinstance(other, Arc):
            return NotImplemented
        return not self == other

    def _d(self, previous):
        end = self.end
        cmd = "a" if self.relative else "A"
        if self.relative:
            end -= previous.end

        return (
            f"{cmd} {self.radius.real:G},{self.radius.imag:G} {self.rotation:G} "
            f"{int(self.arc):d},{int(self.sweep):d} {end.real:G},{end.imag:G}"
        )

    def _parameterize(self):
        # Conversion from endpoint to center parameterization
        # http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
        if self.start == self.end:
            # This is equivalent of omitting the segment, so do nothing
            return

        if self.radius.real == 0 or self.radius.imag == 0:
            # This should be treated as a straight line
            return

        cosr = cos(radians(self.rotation))
        sinr = sin(radians(self.rotation))
        dx = (self.start.real - self.end.real) / 2
        dy = (self.start.imag - self.end.imag) / 2
        x1prim = cosr * dx + sinr * dy
        x1prim_sq = x1prim * x1prim
        y1prim = -sinr * dx + cosr * dy
        y1prim_sq = y1prim * y1prim

        rx = self.radius.real
        rx_sq = rx * rx
        ry = self.radius.imag
        ry_sq = ry * ry

        # Correct out of range radii
        radius_scale = (x1prim_sq / rx_sq) + (y1prim_sq / ry_sq)
        if radius_scale > 1:
            radius_scale = sqrt(radius_scale)
            rx *= radius_scale
            ry *= radius_scale
            rx_sq = rx * rx
            ry_sq = ry * ry
            self.radius_scale = radius_scale
        else:
            # SVG spec only scales UP
            self.radius_scale = 1

        t1 = rx_sq * y1prim_sq
        t2 = ry_sq * x1prim_sq
        c = sqrt(abs((rx_sq * ry_sq - t1 - t2) / (t1 + t2)))

        if self.arc == self.sweep:
            c = -c
        cxprim = c * rx * y1prim / ry
        cyprim = -c * ry * x1prim / rx

        self.center = complex(
            (cosr * cxprim - sinr * cyprim) + ((self.start.real + self.end.real) / 2),
            (sinr * cxprim + cosr * cyprim) + ((self.start.imag + self.end.imag) / 2),
        )

        ux = (x1prim - cxprim) / rx
        uy = (y1prim - cyprim) / ry
        vx = (-x1prim - cxprim) / rx
        vy = (-y1prim - cyprim) / ry
        n = sqrt(ux * ux + uy * uy)
        p = ux
        theta = degrees(acos(p / n))
        if uy < 0:
            theta = -theta
        self.theta = theta % 360

        n = sqrt((ux * ux + uy * uy) * (vx * vx + vy * vy))
        p = ux * vx + uy * vy
        d = p / n
        # In certain cases the above calculation can through inaccuracies
        # become just slightly out of range, f ex -1.0000000000000002.
        if d > 1.0:
            d = 1.0
        elif d < -1.0:
            d = -1.0
        delta = degrees(acos(d))
        if (ux * vy - uy * vx) < 0:
            delta = -delta
        self.delta = delta % 360
        if not self.sweep:
            self.delta -= 360

    def point(self, pos):
        if self.start == self.end:
            # This is equivalent of omitting the segment
            return self.start

        if self.radius.real == 0 or self.radius.imag == 0:
            # This should be treated as a straight line
            distance = self.end - self.start
            return self.start + distance * pos

        angle = radians(self.theta + (self.delta * pos))
        cosr = cos(radians(self.rotation))
        sinr = sin(radians(self.rotation))
        radius = self.radius * self.radius_scale

        x = (
            cosr * cos(angle) * radius.real
            - sinr * sin(angle) * radius.imag
            + self.center.real
        )
        y = (
            sinr * cos(angle) * radius.real
            + cosr * sin(angle) * radius.imag
            + self.center.imag
        )
        return complex(x, y)

    def tangent(self, pos):
        angle = radians(self.theta + (self.delta * pos))
        cosr = cos(radians(self.rotation))
        sinr = sin(radians(self.rotation))
        radius = self.radius * self.radius_scale

        x = cosr * cos(angle) * radius.real - sinr * sin(angle) * radius.imag
        y = sinr * cos(angle) * radius.real + cosr * sin(angle) * radius.imag
        return complex(x, y) * complex(0, 1)

    def length(self, error=ERROR, min_depth=MIN_DEPTH):
        """The length of an elliptical arc segment requires numerical
        integration, and in that case it's simpler to just do a geometric
        approximation, as for cubic bezier curves.
        """
        if self.start == self.end:
            # This is equivalent of omitting the segment
            return 0

        if self.radius.real == 0 or self.radius.imag == 0:
            # This should be treated as a straight line
            distance = self.end - self.start
            return sqrt(distance.real**2 + distance.imag**2)

        if self.radius.real == self.radius.imag:
            # It's a circle, which simplifies this a LOT.
            radius = self.radius.real * self.radius_scale
            return abs(radius * self.delta * pi / 180)

        start_point = self.point(0)
        end_point = self.point(1)
        return segment_length(self, 0, 1, start_point, end_point, error, min_depth, 0)


class Move:
    """Represents move commands. Does nothing, but is there to handle
    paths that consist of only move commands, which is valid, but pointless.
    """

    def __init__(self, to, relative=False):
        self.start = self.end = to
        self.relative = relative

    def __repr__(self):
        return "Move(to=%s)" % self.start

    def __eq__(self, other):
        if not isinstance(other, Move):
            return NotImplemented
        return self.start == other.start

    def __ne__(self, other):
        if not isinstance(other, Move):
            return NotImplemented
        return not self == other

    def _d(self, previous):
        cmd = "M"
        x = self.end.real
        y = self.end.imag
        if self.relative:
            cmd = "m"
            if previous:
                x -= previous.end.real
                y -= previous.end.imag
        return f"{cmd} {x:G},{y:G}"

    def point(self, pos):
        return self.start

    def tangent(self, pos):
        return 0

    def length(self, error=ERROR, min_depth=MIN_DEPTH):
        return 0


class Close(Linear):
    """Represents the closepath command"""

    def __eq__(self, other):
        if not isinstance(other, Close):
            return NotImplemented
        return self.start == other.start and self.end == other.end

    def __repr__(self):
        return f"Close(start={self.start}, end={self.end})"

    def _d(self, previous):
        return "z" if self.relative else "Z"


class Path(MutableSequence):
    """A Path is a sequence of path segments"""

    def __init__(self, *segments):
        self._segments = list(segments)
        self._length = None
        self._lengths = None
        # Fractional distance from starting point through the end of each segment.
        self._fractions = []

    def __getitem__(self, index):
        return self._segments[index]

    def __setitem__(self, index, value):
        self._segments[index] = value
        self._length = None

    def __delitem__(self, index):
        del self._segments[index]
        self._length = None

    def insert(self, index, value):
        self._segments.insert(index, value)
        self._length = None

    def reverse(self):
        # Reversing the order of a path would require reversing each element
        # as well. That's not implemented.
        raise NotImplementedError

    def __len__(self):
        return len(self._segments)

    def __repr__(self):
        return "Path(%s)" % (", ".join(repr(x) for x in self._segments))

    def __eq__(self, other):

        if not isinstance(other, Path):
            return NotImplemented
        if len(self) != len(other):
            return False
        for s, o in zip(self._segments, other._segments):
            if not s == o:
                return False
        return True

    def __ne__(self, other):
        if not isinstance(other, Path):
            return NotImplemented
        return not self == other

    def _calc_lengths(self, error=ERROR, min_depth=MIN_DEPTH):
        if self._length is not None:
            return

        lengths = [
            each.length(error=error, min_depth=min_depth) for each in self._segments
        ]
        self._length = sum(lengths)
        if self._length == 0:
            self._lengths = lengths
        else:
            self._lengths = [each / self._length for each in lengths]
        # Calculate the fractional distance for each segment to use in point()
        fraction = 0
        for each in self._lengths:
            fraction += each
            self._fractions.append(fraction)

    def _find_segment(self, pos, error=ERROR):
        # Shortcuts
        if pos == 0.0:
            return self._segments[0], pos
        if pos == 1.0:
            return self._segments[-1], pos

        self._calc_lengths(error=error)

        # Fix for paths of length 0 (i.e. points)
        if self._length == 0:
            return self._segments[0], 0.0

        # Find which segment the point we search for is located on:
        i = bisect(self._fractions, pos)
        if i == 0:
            segment_pos = pos / self._fractions[0]
        else:
            segment_pos = (pos - self._fractions[i - 1]) / (
                self._fractions[i] - self._fractions[i - 1]
            )
        return self._segments[i], segment_pos

    def point(self, pos, error=ERROR):
        segment, pos = self._find_segment(pos, error)
        return segment.point(pos)

    def tangent(self, pos, error=ERROR):
        segment, pos = self._find_segment(pos, error)
        return segment.tangent(pos)

    def length(self, error=ERROR, min_depth=MIN_DEPTH):
        self._calc_lengths(error, min_depth)
        return self._length

    def d(self):
        parts = []
        previous_segment = None

        for segment in self:
            parts.append(segment._d(previous_segment))
            previous_segment = segment

        return " ".join(parts)


COMMANDS = set("MmZzLlHhVvCcSsQqTtAa")
UPPERCASE = set("MZLHVCSQTA")

COMMAND_RE = re.compile(r"([MmZzLlHhVvCcSsQqTtAa])")
FLOAT_RE = re.compile(rb"^[-+]?\d*\.?\d*(?:[eE][-+]?\d+)?")


class InvalidPathError(ValueError):
    pass


# The argument sequences from the grammar, made sane.
# u: Non-negative number
# s: Signed number or coordinate
# c: coordinate-pair, which is two coordinates/numbers, separated by whitespace
# f: A one character flag, doesn't need whitespace, 1 or 0
ARGUMENT_SEQUENCE = {
    "M": "c",
    "Z": "",
    "L": "c",
    "H": "s",
    "V": "s",
    "C": "ccc",
    "S": "cc",
    "Q": "cc",
    "T": "c",
    "A": "uusffc",
}


def strip_array(arg_array):
    """Strips whitespace and commas"""
    # EBNF wsp:(#x20 | #x9 | #xD | #xA) + comma: 0x2C
    while arg_array and arg_array[0] in (0x20, 0x9, 0xD, 0xA, 0x2C):
        arg_array[0:1] = b""


def pop_number(arg_array):
    res = FLOAT_RE.search(arg_array)
    if not res or not res.group():
        raise InvalidPathError(f"Expected a number, got '{arg_array}'.")
    number = float(res.group())
    start = res.start()
    end = res.end()
    arg_array[start:end] = b""
    strip_array(arg_array)

    return number


def pop_unsigned_number(arg_array):
    number = pop_number(arg_array)
    if number < 0:
        raise InvalidPathError(f"Expected a non-negative number, got '{number}'.")
    return number


def pop_coordinate_pair(arg_array):
    x = pop_number(arg_array)
    y = pop_number(arg_array)
    return complex(x, y)


def pop_flag(arg_array):
    flag = arg_array[0]
    arg_array[0:1] = b""
    strip_array(arg_array)
    if flag == 48:  # ASCII 0
        return False
    if flag == 49:  # ASCII 1
        return True


FIELD_POPPERS = {
    "u": pop_unsigned_number,
    "s": pop_number,
    "c": pop_coordinate_pair,
    "f": pop_flag,
}


def _commandify_path(pathdef):
    """Splits path into commands and arguments"""
    token = None
    for x in COMMAND_RE.split(pathdef):
        x = x.strip()
        if x in COMMANDS:
            if token is not None:
                yield token
            if x in ("z", "Z"):
                # The end command takes no arguments, so add a blank one
                token = (x, "")
            else:
                token = (x,)
        elif x:
            if token is None:
                raise InvalidPathError(f"Path does not start with a command: {pathdef}")
            token += (x,)
    yield token


def _tokenize_path(pathdef):
    for command, args in _commandify_path(pathdef):
        # Shortcut this for the close command, that doesn't have arguments:
        if command in ("z", "Z"):
            yield (command,)
            continue

        # For the rest of the commands, we parse the arguments and
        # yield one command per full set of arguments
        arg_sequence = ARGUMENT_SEQUENCE[command.upper()]
        arguments = bytearray(args, "ascii")
        implicit = False
        while arguments:
            command_arguments = []
            for i, arg in enumerate(arg_sequence):
                try:
                    command_arguments.append(FIELD_POPPERS[arg](arguments))
                except InvalidPathError as e:
                    if i == 0 and implicit:
                        return  # Invalid character in path, treat like a comment
                    raise InvalidPathError(
                        f"Invalid path element {command} {args}"
                    ) from e

            yield (command,) + tuple(command_arguments)
            implicit = True

            # Implicit Moveto commands should be treated as Lineto commands.
            if command == "m":
                command = "l"
            elif command == "M":
                command = "L"


def parse_path(pathdef):
    segments = path.Path()
    start_pos = None
    last_command = None
    current_pos = 0

    for token in _tokenize_path(pathdef):
        command = token[0]
        relative = command.islower()
        command = command.upper()
        if command == "M":
            pos = token[1]
            if relative:
                current_pos += pos
            else:
                current_pos = pos
            segments.append(path.Move(current_pos, relative=relative))
            start_pos = current_pos

        elif command == "Z":
            # For Close commands the "relative" argument just preserves case,
            # it has no different in behavior.
            segments.append(path.Close(current_pos, start_pos, relative=relative))
            current_pos = start_pos

        elif command == "L":
            pos = token[1]
            if relative:
                pos += current_pos
            segments.append(path.Line(current_pos, pos, relative=relative))
            current_pos = pos

        elif command == "H":
            hpos = token[1]
            if relative:
                hpos += current_pos.real
            pos = complex(hpos, current_pos.imag)
            segments.append(
                path.Line(current_pos, pos, relative=relative, horizontal=True)
            )
            current_pos = pos

        elif command == "V":
            vpos = token[1]
            if relative:
                vpos += current_pos.imag
            pos = complex(current_pos.real, vpos)
            segments.append(
                path.Line(current_pos, pos, relative=relative, vertical=True)
            )
            current_pos = pos

        elif command == "C":
            control1 = token[1]
            control2 = token[2]
            end = token[3]

            if relative:
                control1 += current_pos
                control2 += current_pos
                end += current_pos

            segments.append(
                path.CubicBezier(
                    current_pos, control1, control2, end, relative=relative
                )
            )
            current_pos = end

        elif command == "S":
            # Smooth curve. First control point is the "reflection" of
            # the second control point in the previous path.
            control2 = token[1]
            end = token[2]

            if relative:
                control2 += current_pos
                end += current_pos

            if last_command in "CS":
                # The first control point is assumed to be the reflection of
                # the second control point on the previous command relative
                # to the current point.
                control1 = current_pos + current_pos - segments[-1].control2
            else:
                # If there is no previous command or if the previous command
                # was not an C, c, S or s, assume the first control point is
                # coincident with the current point.
                control1 = current_pos

            segments.append(
                path.CubicBezier(
                    current_pos, control1, control2, end, relative=relative, smooth=True
                )
            )
            current_pos = end

        elif command == "Q":
            control = token[1]
            end = token[2]

            if relative:
                control += current_pos
                end += current_pos

            segments.append(
                path.QuadraticBezier(current_pos, control, end, relative=relative)
            )
            current_pos = end

        elif command == "T":
            # Smooth curve. Control point is the "reflection" of
            # the second control point in the previous path.
            end = token[1]

            if relative:
                end += current_pos

            if last_command in "QT":
                # The control point is assumed to be the reflection of
                # the control point on the previous command relative
                # to the current point.
                control = current_pos + current_pos - segments[-1].control
            else:
                # If there is no previous command or if the previous command
                # was not an Q, q, T or t, assume the first control point is
                # coincident with the current point.
                control = current_pos

            segments.append(
                path.QuadraticBezier(
                    current_pos, control, end, smooth=True, relative=relative
                )
            )
            current_pos = end

        elif command == "A":
            # For some reason I implemented the Arc with a complex radius.
            # That doesn't really make much sense, but... *shrugs*
            radius = complex(token[1], token[2])
            rotation = token[3]
            arc = token[4]
            sweep = token[5]
            end = token[6]

            if relative:
                end += current_pos

            segments.append(
                path.Arc(
                    current_pos, radius, rotation, arc, sweep, end, relative=relative
                )
            )
            current_pos = end

        # Finish up the loop in preparation for next command
        last_command = command

    return segments



class Room:
    def __init__(self):

        self.name = None
        self.extrusion = None
        self.verts = None
        self.faces = None
        self.topsurface = None
        self.bottomsurface = None
        self.parms = None



class System:
    """Represents a generic system with a defined direction."""

    def __init__(self):
        """Initializes a new System instance.

        - `type` (str): The class name, indicating the object type as "System".
        - `name` (str, optional): The name of the system.
        - `id` (str): A unique identifier for the system instance.
        - `polycurve` (PolyCurve, optional): An optional PolyCurve associated with the system.
        - `direction` (Vector): A Vector indicating the primary direction of the system.
        """
        self.name = None

        self.polycurve = None
        self.direction: Vector = Vector(1, 0, 0)


class DivisionSystem:
    # This class provides divisionsystems. It returns lists with floats based on a length.
    """The `DivisionSystem` class manages division systems, providing functionalities to calculate divisions and spacings based on various criteria."""

    def __init__(self):
        """Initializes a new DivisionSystem instance.

        - `type` (str): The class name, "DivisionSystem".
        - `name` (str): The name of the division system.
        - `id` (str): A unique identifier for the division system instance.
        - `system_length` (float): The total length of the system to be divided.
        - `spacing` (float): The spacing between divisions.
        - `distance_first` (float): The distance of the first division from the start of the system.
        - `width_stud` (float): The width of a stud, applicable in certain division strategies.
        - `fixed_number` (int): A fixed number of divisions.
        - `modifier` (int): A modifier value that adjusts the number of divisions or their placement.
        - `distances` (list): A list containing the cumulative distances of each division from the start.
        - `spaces` (list): A list containing the spaces between each division.
        - `system` (str): A string indicating the current system strategy (e.g., "fixed_distance_unequal_division").
        """
        self.name = None

        self.system_length: float = 100
        self.spacing: float = 10
        self.distance_first: float = 5
        self.width_stud: float = 10
        self.fixed_number: int = 2
        self.modifier: int = 0
        self.distances = []  # List with sum of distances
        self.spaces = []  # List with spaces between every divison
        self.system: str = "fixed_distance_unequal_division"

    def __fixed_number_equal_spacing(self):
        """Calculates divisions based on a fixed number with equal spacing.
        This internal method sets up divisions across the system length, ensuring each division is equally spaced. It is triggered by configurations that require a fixed number of divisions, automatically adjusting the spacing to fit the total length.

        #### Effects:
        - Sets the division system name to "fixed_number_equal_spacing".
        - Calculates equal spacing between divisions based on the total system length and the fixed number of divisions.
        - Resets the modifier to 0, as it is not applicable in this configuration.
        - Assigns the calculated spacing to `distance_first` to maintain consistency at the start of the system.
        """
        self.name = "fixed_number_equal_spacing"
        self.distances = Interval.by_start_end_count(
            0, self.system_length, self.fixed_number
        )
        self.spacing = self.system_length / self.fixed_number
        self.modifier = 0
        self.distance_first = self.spacing

    def __fixed_distance_unequal_division(self):
        """Configures divisions with a fixed starting distance followed by unequal divisions.
        This internal method configures the division system to start with a specified distance for the first division, then continues with divisions spaced according to `spacing`. If the total length cannot be evenly divided, the last division's spacing may differ.

        #### Effects:
        - Sets the division system name to "fixed_distance_unequal_division".
        - Calculates the number of divisions based on the spacing and the total system length minus the first division's distance.
        - Generates a list of distances where each division should occur, considering the initial distance and spacing.
        """
        self.name = "fixed_distance_unequal_division"
        rest_length = self.system_length - self.distance_first
        number_of_studs = int(rest_length / self.spacing)
        number_of_studs = number_of_studs + self.modifier
        distance = self.distance_first
        for i in range(number_of_studs + 1):
            if distance < self.system_length:
                self.distances.append(distance)
            else:
                break
            distance = distance + self.spacing

    def __fixed_distance_equal_division(self):
        """Creates divisions with equal spacing across the total system length.
        An internal method that evenly distributes divisions across the system's length. It takes into account the total length and the desired spacing to calculate the number of divisions, ensuring they are equally spaced.

        #### Effects:
        - Sets the division system name to "fixed_distance_equal_division".
        - Calculates the number of divisions based on the desired spacing and total length.
        - Determines the starting distance for the first division to ensure all divisions, including the first and last, are equally spaced within the system length.
        """
        self.name = "fixed_distance_equal_division"
        number_of_studs = int(self.system_length / self.spacing)
        number_of_studs = number_of_studs + self.modifier
        sum_length_studs_x_spacing = (number_of_studs - 1) * self.spacing
        rest_length = self.system_length - sum_length_studs_x_spacing
        distance = rest_length / 2
        for i in range(number_of_studs):
            self.distances.append(distance)
            distance = distance + self.spacing

    def by_fixed_distance_unequal_division(
        self, length: float, spacing: float, distance_first: float, modifier: int
    ) -> "DivisionSystem":
        """Configures the division system for unequal divisions with a specified distance first.
        This method sets up the division system to calculate divisions based on a fixed initial distance, followed by unevenly spaced divisions according to the specified parameters.

        #### Parameters:
        - `length` (float): The total length of the system to be divided.
        - `spacing` (float): The target spacing between divisions.
        - `distance_first` (float): The distance of the first division from the system's start.
        - `modifier` (int): An integer modifier to adjust the calculation of divisions.

        #### Returns:
        `DivisionSystem`: The instance itself, updated with the new division configuration.

        #### Example usage:
        ```python
        division_system = DivisionSystem()
        division_system.by_fixed_distance_unequal_division(100, 10, 5, 0)
        ```
        """
        self.system_length = length
        self.modifier = modifier
        self.spacing = spacing
        self.distance_first = distance_first
        self.system = "fixed_distance_unequal_division"
        self.__fixed_distance_unequal_division()
        return self

    def by_fixed_distance_equal_division(
        self, length: float, spacing: float, modifier: int
    ) -> "DivisionSystem":
        """Configures the division system for equal divisions with fixed spacing.
        This method sets up the division system to calculate divisions based on a fixed spacing between each division across the total system length. The modifier can adjust the calculation slightly but maintains equal spacing.

        #### Parameters:
        - `length` (float): The total length of the system to be divided.
        - `spacing` (float): The spacing between each division.
        - `modifier` (int): An integer modifier to fine-tune the division process.

        #### Returns:
        `DivisionSystem`: The instance itself, updated with the new division configuration.

        #### Example usage:
        ```python
        division_system = DivisionSystem()
        division_system.by_fixed_distance_equal_division(100, 10, 0)
        ```
        """
        self.system_length = length
        self.modifier = modifier
        self.spacing = spacing
        self.system = "fixed_distance_equal_division"
        self.__fixed_distance_equal_division()
        return self

    def by_fixed_number_equal_spacing(
        self, length: float, number: int
    ) -> "DivisionSystem":
        """Establishes the division system for a fixed number of divisions with equal spacing.
        This method arranges for a certain number of divisions to be spaced equally across the system length. It calculates the required spacing based on the total length and desired number of divisions.

        #### Parameters:
        - `length` (float): The total length of the system to be divided.
        - `number` (int): The fixed number of divisions to be created.

        #### Returns:
        `DivisionSystem`: The instance itself, updated with the new division configuration.

        #### Example usage:
        ```python
        division_system = DivisionSystem()
        division_system.by_fixed_number_equal_spacing(100, 5)
        ```
        """
        self.system_length = length
        self.system = "fixed_number_equal_spacing"
        self.spacing = length / number
        self.modifier = 0
        distance = self.spacing
        for i in range(number - 1):
            self.distances.append(distance)
            distance = distance + self.spacing
        self.distance_first = self.spacing
        return self

        #  fixed_number_equal_interior_fill
        #  maximum_spacing_equal_division
        #  maximum_spacing_unequal_division
        #  minimum_spacing_equal_division
        #  minimum_spacing_unequal_division


class RectangleSystem:
    # Reclangle Left Bottom is in Local XYZ. Main direction parallel to height direction vector. Top is z=0
    """The `RectangleSystem` class is designed to represent and manipulate rectangular systems, focusing on dimensions, frame types, and panel arrangements within a specified coordinate system."""

    def __init__(self):
        """Initializes a new RectangleSystem instance.

        - `type` (str): Class name, indicating the object type as "RectangleSystem".
        - `name` (str, optional): The name of the rectangle system.
        - `id` (str): A unique identifier for the rectangle system instance.
        - `height` (float): The height of the rectangle system.
        - `width` (float): The width of the rectangle system.
        - `bottom_frame_type` (Rectangle): A `Rectangle` instance for the bottom frame type.
        - `top_frame_type` (Rectangle): A `Rectangle` instance for the top frame type.
        - `left_frame_type` (Rectangle): A `Rectangle` instance for the left frame type.
        - `right_frame_type` (Rectangle): A `Rectangle` instance for the right frame type.
        - `inner_frame_type` (Rectangle): A `Rectangle` instance for the inner frame type.
        - `material` (BaseTimber): The material used for the system, pre-defined as `BaseTimber`.
        - `inner_width` (float): The computed inner width of the rectangle system, excluding the width of the left and right frames.
        - `inner_height` (float): The computed inner height of the rectangle system, excluding the height of the top and bottom frames.
        - `coordinatesystem` (CSGlobal): A global coordinate system applied to the rectangle system.
        - `local_coordinate_system` (CSGlobal): A local coordinate system specific to the rectangle system.
        - `division_system` (DivisionSystem, optional): A `DivisionSystem` instance to manage divisions within the rectangle system.
        - `inner_frame_objects` (list): A list of inner frame objects within the rectangle system.
        - `outer_frame_objects` (list): A list of outer frame objects.
        - `panel_objects` (list): A list of panel objects used within the system.
        - `symbolic_inner_mother_surface` (PolyCurve, optional): A symbolic representation of the inner mother surface.
        - `symbolic_inner_panels` (list, optional): Symbolic representations of inner panels.
        - `symbolic_outer_grids` (list): Symbolic representations of outer grids.
        - `symbolic_inner_grids` (list): Symbolic representations of inner grids.
        """
        self.name = None

        self.height = 3000
        self.width = 2000
        self.bottom_frame_type = RectangleProfile("bottom_frame_type", 38, 184)
        self.top_frame_type = RectangleProfile("top_frame_type", 38, 184)
        self.left_frame_type = RectangleProfile("left_frame_type", 38, 184)
        self.right_frame_type = RectangleProfile("left_frame_type", 38, 184)
        self.inner_frame_type = RectangleProfile("inner_frame_type", 38, 184)

        self.material = BaseTimber
        self.inner_width: float = 0
        self.inner_height: float = 0
        # self.openings = []
        # self.subsystems = []
        self.division_system = None
        self.inner_frame_objects = []
        self.outer_frame_objects = []
        self.panel_objects = []
        self.symbolic_inner_mother_surface = None
        self.symbolic_inner_panels = None
        self.symbolic_outer_grids = []
        self.symbolic_inner_grids = []

    def __inner_panels(self):
        """Calculates and creates inner panel objects for the RectangleSystem.
        This method iteratively calculates the positions and dimensions of inner panels based on the division system's distances and the inner frame type's width. It populates the `panel_objects` list with created panels.

        #### Effects:
        - Populates `panel_objects` with Panel instances representing the inner panels of the rectangle system.
        """
        # First Inner panel
        i = self.division_system.distances[0]
        point1 = self.mother_surface_origin_point_x_zero
        point2 = Point.translate(
            self.mother_surface_origin_point_x_zero,
            Vector(i - self.inner_frame_type.b * 0.5, 0, 0),
        )
        point3 = Point.translate(
            self.mother_surface_origin_point_x_zero,
            Vector(i - self.inner_frame_type.b * 0.5, self.inner_height, 0),
        )
        point4 = Point.translate(
            self.mother_surface_origin_point_x_zero, Vector(0, self.inner_height, 0)
        )
        self.panel_objects.append(
            Panel.by_polycurve_thickness(
                PolyCurve.by_points([point1, point2, point3, point4, point1]),
                184,
                0,
                "innerpanel",
                rgb_to_int([255, 240, 160]),
            )
        )
        count = 0
        # In between
        for i in self.division_system.distances:
            try:
                point1 = Point.translate(
                    self.mother_surface_origin_point_x_zero,
                    Vector(
                        self.division_system.distances[count]
                        + self.inner_frame_type.b * 0.5,
                        0,
                        0,
                    ),
                )
                point2 = Point.translate(
                    self.mother_surface_origin_point_x_zero,
                    Vector(
                        self.division_system.distances[count + 1]
                        - self.inner_frame_type.b * 0.5,
                        0,
                        0,
                    ),
                )
                point3 = Point.translate(
                    self.mother_surface_origin_point_x_zero,
                    Vector(
                        self.division_system.distances[count + 1]
                        - self.inner_frame_type.b * 0.5,
                        self.inner_height,
                        0,
                    ),
                )
                point4 = Point.translate(
                    self.mother_surface_origin_point_x_zero,
                    Vector(
                        self.division_system.distances[count]
                        + self.inner_frame_type.b * 0.5,
                        self.inner_height,
                        0,
                    ),
                )
                self.panel_objects.append(
                    Panel.by_polycurve_thickness(
                        PolyCurve.by_points([point1, point2, point3, point4, point1]),
                        184,
                        0,
                        "innerpanel",
                        rgb_to_int([255, 240, 160]),
                    )
                )
                count = count + 1
            except:
                # Last panel
                point1 = Point.translate(
                    self.mother_surface_origin_point_x_zero,
                    Vector(
                        self.division_system.distances[count]
                        + self.inner_frame_type.b * 0.5,
                        0,
                        0,
                    ),
                )
                point2 = Point.translate(
                    self.mother_surface_origin_point_x_zero,
                    Vector(self.inner_width + self.left_frame_type.b, 0, 0),
                )
                point3 = Point.translate(
                    self.mother_surface_origin_point_x_zero,
                    Vector(
                        self.inner_width + self.left_frame_type.b, self.inner_height, 0
                    ),
                )
                point4 = Point.translate(
                    self.mother_surface_origin_point_x_zero,
                    Vector(
                        self.division_system.distances[count]
                        + self.inner_frame_type.b * 0.5,
                        self.inner_height,
                        0,
                    ),
                )
                self.panel_objects.append(
                    Panel.by_polycurve_thickness(
                        PolyCurve.by_points([point1, point2, point3, point4, point1]),
                        184,
                        0,
                        "innerpanel",
                        rgb_to_int([255, 240, 160]),
                    )
                )
                count = count + 1

    def __inner_mother_surface(self):
        """Determines the inner mother surface dimensions and creates its symbolic representation.
        Calculates the inner width and height by subtracting the frame widths from the total width and height. It then constructs a symbolic PolyCurve representing the mother surface within the rectangle system's frames.

        #### Effects:
        - Updates `inner_width` and `inner_height` attributes based on frame dimensions.
        - Creates a symbolic PolyCurve `symbolic_inner_mother_surface` representing the inner mother surface.
        """
        # Inner mother surface is the surface within the outer frames dependent on the width of the outer frametypes.
        self.inner_width = self.width - self.left_frame_type.b - self.right_frame_type.b
        self.inner_height = (
            self.height - self.top_frame_type.b - self.bottom_frame_type.b
        )
        self.mother_surface_origin_point = Point(
            self.left_frame_type.b, self.bottom_frame_type.b, 0
        )
        self.mother_surface_origin_point_x_zero = Point(0, self.bottom_frame_type.b, 0)
        self.symbolic_inner_mother_surface = PolyCurve.by_points(
            [
                self.mother_surface_origin_point,
                Point.translate(
                    self.mother_surface_origin_point, Vector(self.inner_width, 0, 0)
                ),
                Point.translate(
                    self.mother_surface_origin_point,
                    Vector(self.inner_width, self.inner_height, 0),
                ),
                Point.translate(
                    self.mother_surface_origin_point, Vector(0, self.inner_height, 0)
                ),
                self.mother_surface_origin_point,
            ]
        )

    def __inner_frames(self):
        """Creates inner frame objects based on division distances within the rectangle system.
        Utilizes the division distances to place vertical frames across the inner width of the rectangle system. These frames are represented both as Frame objects within the system and as symbolic lines for visualization.

        #### Effects:
        - Generates Frame objects for each division, placing them vertically within the rectangle system.
        - Populates `inner_frame_objects` with these Frame instances.
        - Adds symbolic representations of these frames to `symbolic_inner_grids`.
        """
        for i in self.division_system.distances:
            start_point = Point.translate(
                self.mother_surface_origin_point_x_zero, Vector(i, 0, 0)
            )
            end_point = Point.translate(
                self.mother_surface_origin_point_x_zero, Vector(i, self.inner_height, 0)
            )
            self.inner_frame_objects.append(
                Beam.by_start_point_endpoint_curve_justification(
                    start_point,
                    end_point,
                    self.inner_frame_type.curve,
                    "innerframe",
                    "center",
                    "top",
                    0,
                    self.material,
                )
            )
            self.symbolic_inner_grids.append(Line(start=start_point, end=end_point))

    def __outer_frames(self):
        """Generates the outer frame objects for the rectangle system.
        Creates Frame objects for the bottom, top, left, and right boundaries of the rectangle system. Each frame is defined by its start and end points, along with its type and material. Symbolic lines representing these frames are also generated for visualization.

        #### Effects:
        - Creates Frame instances for the outer boundaries of the rectangle system and adds them to `outer_frame_objects`.
        - Generates symbolic Line instances for each outer frame and adds them to `symbolic_outer_grids`.
        """
        bottomframe = Beam.by_start_point_endpoint_curve_justification(
            Point(0, 0, 0),
            Point(self.width, 0, 0),
            self.bottom_frame_type.curve,
            "bottomframe",
            "left",
            "top",
            0,
            self.material,
        )
        self.symbolic_outer_grids.append(
            Line(start=Point(0, 0, 0), end=Point(self.width, 0, 0))
        )

        topframe = Beam.by_start_point_endpoint_curve_justification(
            Point(0, self.height, 0),
            Point(self.width, self.height, 0),
            self.top_frame_type.curve,
            "bottomframe",
            "right",
            "top",
            0,
            self.material,
        )
        self.symbolic_outer_grids.append(
            Line(start=Point(0, self.height, 0), end=Point(self.width, self.height, 0))
        )

        leftframe = Beam.by_start_point_endpoint_curve_justification(
            Point(0, self.bottom_frame_type.b, 0),
            Point(0, self.height - self.top_frame_type.b, 0),
            self.left_frame_type.curve,
            "leftframe",
            "right",
            "top",
            0,
            self.material,
        )
        self.symbolic_outer_grids.append(
            Line(
                start=Point(0, self.bottom_frame_type.b, 0),
                end=Point(0, self.height - self.top_frame_type.b, 0),
            )
        )

        rightframe = Beam.by_start_point_endpoint_curve_justification(
            Point(self.width, self.bottom_frame_type.b, 0),
            Point(self.width, self.height - self.top_frame_type.b, 0),
            self.right_frame_type.curve,
            "leftframe",
            "left",
            "top",
            0,
            self.material,
        )
        self.symbolic_outer_grids.append(
            Line(
                start=Point(self.width, self.bottom_frame_type.b, 0),
                end=Point(self.width, self.height - self.top_frame_type.b, 0),
            )
        )

        self.outer_frame_objects.append(bottomframe)
        self.outer_frame_objects.append(topframe)
        self.outer_frame_objects.append(leftframe)
        self.outer_frame_objects.append(rightframe)

    def by_width_height_divisionsystem_studtype(
        self,
        width: float,
        height: float,
        frame_width: float,
        frame_height: float,
        division_system: DivisionSystem,
        filling: bool,
    ) -> "RectangleSystem":
        """Configures the rectangle system with specified dimensions, division system, and frame types.
        This method sets the dimensions of the rectangle system, configures the frame types based on the provided dimensions, and applies a division system to generate inner frames. Optionally, it can also fill the system with panels based on the inner divisions.

        #### Parameters:
        - `width` (float): The width of the rectangle system.
        - `height` (float): The height of the rectangle system.
        - `frame_width` (float): The width of the frame elements.
        - `frame_height` (float): The height (thickness) of the frame elements.
        - `division_system` (DivisionSystem): The division system to apply for inner divisions.
        - `filling` (bool): A flag indicating whether to fill the divided areas with panels.

        #### Returns:
        `RectangleSystem`: The instance itself, updated with the new configuration.

        #### Example usage:
        ```python
        rectangle_system = RectangleSystem()
        rectangle_system.by_width_height_divisionsystem_studtype(2000, 3000, 38, 184, divisionSystem, True)
        ```
        """
        self.width = width
        self.height = height
        self.bottom_frame_type = RectangleProfile(
            "bottom_frame_type", frame_width, frame_height
        )
        self.top_frame_type = RectangleProfile(
            "top_frame_type", frame_width, frame_height
        )
        self.left_frame_type = RectangleProfile(
            "left_frame_type", frame_width, frame_height
        )
        self.right_frame_type = RectangleProfile(
            "left_frame_type", frame_width, frame_height
        )
        self.inner_frame_type = RectangleProfile(
            "inner_frame_type", frame_width, frame_height
        )
        self.division_system = division_system
        self.__inner_mother_surface()
        self.__inner_frames()
        self.__outer_frames()
        if filling:
            self.__inner_panels()
        else:
            pass
        return self


class pattern_system:
    """The `pattern_system` class is designed to define and manipulate patterns for architectural or design applications. It is capable of generating various patterns based on predefined or dynamically generated parameters."""

    def __init__(self):
        """Initializes a new pattern_system instance."""
        self.name = None

        self.pattern = None
        self.basepanels = []  # contains a list with basepanels of the system
        # contains a list sublists with Vector which represent the repetition of the system
        self.vectors = []

    def stretcher_bond_with_joint(
        self,
        name: str,
        brick_width: float,
        brick_length: float,
        brick_height: float,
        joint_width: float,
        joint_height: float,
    ):
        """Configures a stretcher bond pattern with joints for the pattern_system.
        Establishes the fundamental vectors and base panels for a stretcher bond, taking into account brick dimensions and joint sizes. This pattern alternates bricks in each row, offsetting them by half a brick length.

        #### Parameters:
        - `name` (str): Name of the pattern configuration.
        - `brick_width` (float): Width of the brick.
        - `brick_length` (float): Length of the brick.
        - `brick_height` (float): Height of the brick.
        - `joint_width` (float): Width of the joint between bricks.
        - `joint_height` (float): Height of the joint between brick layers.

        #### Returns:
        The instance itself, updated with the stretcher bond pattern configuration.

        #### Example usage:
        ```python

        ```
        """
        self.name = name
        # Vectors of panel 1
        V1 = Vector(0, (brick_height + joint_height) * 2, 0)  # dy
        V2 = Vector(brick_length + joint_width, 0, 0)  # dx
        self.vectors.append([V1, V2])

        # Vectors of panel 2
        V3 = Vector(0, (brick_height + joint_height) * 2, 0)  # dy
        V4 = Vector(brick_length + joint_width, 0, 0)  # dx
        self.vectors.append([V3, V4])

        dx = (brick_length + joint_width) / 2
        dy = brick_height + joint_height

        PC1 = PolyCurve().by_points(
            [
                Point(0, 0, 0),
                Point(0, brick_height, 0),
                Point(brick_length, brick_height, 0),
                Point(brick_length, 0, 0),
                Point(0, 0, 0),
            ]
        )
        PC2 = PolyCurve().by_points(
            [
                Point(dx, dy, 0),
                Point(dx, brick_height + dy, 0),
                Point(brick_length + dx, brick_height + dy, 0),
                Point(brick_length + dx, dy, 0),
                Point(dx, dy, 0),
            ]
        )
        BasePanel1 = Panel.by_polycurve_thickness(
            PC1, brick_width, 0, "BasePanel1", BaseBrick
        )
        BasePanel2 = Panel.by_polycurve_thickness(
            PC2, brick_width, 0, "BasePanel2", BaseBrick
        )

        self.basepanels.append(BasePanel1)
        self.basepanels.append(BasePanel2)
        return self

    def tile_bond_with_joint(
        self,
        name: str,
        tile_width: float,
        tile_height: float,
        tile_thickness: float,
        joint_width: float,
        joint_height: float,
    ):
        """Configures a tile bond pattern with specified dimensions and joint sizes for the pattern_system.
        Defines a simple tiling pattern where tiles are laid out in rows and columns, separated by specified joint widths and heights. This method sets up base panels to represent individual tiles and their arrangement vectors.

        #### Parameters:
        - `name` (str): The name of the tile bond pattern configuration.
        - `tile_width` (float): The width of a single tile.
        - `tile_height` (float): The height of a single tile.
        - `tile_thickness` (float): The thickness of the tile.
        - `joint_width` (float): The width of the joint between adjacent tiles.
        - `joint_height` (float): The height of the joint between tile rows.

        #### Returns:
        The instance itself, updated with the tile bond pattern configuration.

        #### Example Usage:
        ```python
        pattern_system = pattern_system()
        pattern_system.tile_bond_with_joint('TilePattern', 200, 300, 10, 5, 5)
        ```
        This configures the `pattern_system` with a tile bond pattern named 'TilePattern', where each tile measures 200x300x10 units, with 5 units of spacing between tiles.
        """
        self.name = name
        # Vectors of panel 1
        V1 = Vector(0, (tile_height + joint_height), 0)  # dy
        V2 = Vector(tile_width + joint_width, 0, 0)  # dx
        self.vectors.append([V1, V2])

        PC1 = PolyCurve().by_points(
            [
                Point(0, 0, 0),
                Point(0, tile_height, 0),
                Point(tile_width, tile_height, 0),
                Point(tile_width, 0, 0),
            ]
        )
        BasePanel1 = Panel.by_polycurve_thickness(
            PC1, tile_thickness, 0, "BasePanel1", BaseBrick
        )

        self.basepanels.append(BasePanel1)
        return self

    def cross_bond_with_joint(
        self,
        name: str,
        brick_width: float,
        brick_length: float,
        brick_height: float,
        joint_width: float,
        joint_height: float,
    ):
        """Configures a cross bond pattern with joints for the pattern_system.
        Sets up a complex brick laying pattern combining stretcher (lengthwise) and header (widthwise) bricks in alternating rows, creating a cross bond appearance. This method defines the base panels and their positioning vectors to achieve the cross bond pattern.

        #### Parameters:
        - `name` (str): The name of the cross bond pattern configuration.
        - `brick_width` (float): The width of a single brick.
        - `brick_length` (float): The length of the brick.
        - `brick_height` (float): The height of the brick layer.
        - `joint_width` (float): The width of the joint between bricks.
        - `joint_height` (float): The height of the joint between brick layers.

        #### Returns:
        The instance itself, updated with the cross bond pattern configuration.

        #### Example Usage:
        ```python
        pattern_system = pattern_system()
        pattern_system.cross_bond_with_joint('CrossBondPattern', 90, 190, 80, 10, 10)
        ```
        In this configuration, `pattern_system` is set to a cross bond pattern named 'CrossBondPattern', with bricks measuring 90x190x80 units and 10 units of joint spacing in both directions.
        """
        self.name = name
        lagenmaat = brick_height + joint_height
        # Vectors of panel 1 (strek)
        V1 = Vector(0, (brick_height + joint_height) * 4, 0)  # dy spacing
        V2 = Vector(brick_length + joint_width, 0, 0)  # dx spacing
        self.vectors.append([V1, V2])

        # Vectors of panel 2 (koppen 1)
        V3 = Vector(0, (brick_height + joint_height) * 2, 0)  # dy spacing
        V4 = Vector(brick_length + joint_width, 0, 0)  # dx spacing
        self.vectors.append([V3, V4])

        dx2 = (brick_width + joint_width) / 2  # start x offset
        dy2 = lagenmaat  # start y offset

        # Vectors of panel 3 (strekken)
        V5 = Vector(0, (brick_height + joint_height) * 4, 0)  # dy spacing
        V6 = Vector(brick_length + joint_width, 0, 0)  # dx spacing
        self.vectors.append([V5, V6])

        dx3 = (brick_length + joint_width) / 2  # start x offset
        dy3 = lagenmaat * 2  # start y offset

        # Vectors of panel 4 (koppen 2)
        V7 = Vector(0, (brick_height + joint_height) * 2, 0)  # dy spacing
        V8 = Vector(brick_length + joint_width, 0, 0)  # dx spacing
        self.vectors.append([V7, V8])

        dx4 = (brick_width + joint_width) / 2 + (
            brick_width + joint_width
        )  # start x offset
        dy4 = lagenmaat  # start y offset

        PC1 = PolyCurve().by_points(
            [
                Point(0, 0, 0),
                Point(0, brick_height, 0),
                Point(brick_length, brick_height, 0),
                Point(brick_length, 0, 0),
                Point(0, 0, 0),
            ]
        )
        PC2 = PolyCurve().by_points(
            [
                Point(dx2, dy2, 0),
                Point(dx2, brick_height + dy2, 0),
                Point(brick_width + dx2, brick_height + dy2, 0),
                Point(brick_width + dx2, dy2, 0),
                Point(dx2, dy2, 0),
            ]
        )
        PC3 = PolyCurve().by_points(
            [
                Point(dx3, dy3, 0),
                Point(dx3, brick_height + dy3, 0),
                Point(brick_length + dx3, brick_height + dy3, 0),
                Point(brick_length + dx3, dy3, 0),
                Point(dx3, dy3, 0),
            ]
        )
        PC4 = PolyCurve().by_points(
            [
                Point(dx4, dy4, 0),
                Point(dx4, brick_height + dy4, 0),
                Point(brick_width + dx4, brick_height + dy4, 0),
                Point(brick_width + dx4, dy4, 0),
                Point(dx4, dy4, 0),
            ]
        )

        BasePanel1 = Panel.by_polycurve_thickness(
            PC1, brick_width, 0, "BasePanel1", BaseBrick
        )
        BasePanel2 = Panel.by_polycurve_thickness(
            PC2, brick_width, 0, "BasePanel2", BaseBrick
        )
        BasePanel3 = Panel.by_polycurve_thickness(
            PC3, brick_width, 0, "BasePanel3", BaseBrick
        )
        BasePanel4 = Panel.by_polycurve_thickness(
            PC4, brick_width, 0, "BasePanel4", BaseBrickYellow
        )

        self.basepanels.append(BasePanel1)
        self.basepanels.append(BasePanel2)
        self.basepanels.append(BasePanel3)
        self.basepanels.append(BasePanel4)

        return self


def pattern_geom(
    pattern_system, width: float, height: float, start_point: Point = None
) -> list[Panel]:
    """Generates a geometric pattern based on a pattern_system within a specified area.
    Takes a pattern_system and fills a defined width and height area starting from an optional start point with the pattern described by the system.

    #### Parameters:
    - `pattern_system`: The pattern_system instance defining the pattern.
    - `width` (float): Width of the area to fill with the pattern.
    - `height` (float): Height of the area to fill with the pattern.
    - `start_point` (Point, optional): Starting point for the pattern generation.

    #### Returns:
    `list[Panel]`: A list of Panel instances constituting the generated pattern.

    #### Example usage:
    ```python

    ```
    """
    start_point = start_point or Point(0, 0, 0)
    test = pattern_system
    panels = []

    for i, j in zip(test.basepanels, test.vectors):
        ny = int(height / (j[0].y))  # number of panels in y-direction
        nx = int(width / (j[1].x))  # number of panels in x-direction
        PC = i.origincurve
        thickness = i.thickness
        color = i.colorint

        # YX ARRAY
        yvectdisplacement = j[0]
        yvector = Point.to_vector(start_point)
        xvectdisplacement = j[1]
        xvector = Vector(0, 0, 0)

        ylst = []
        for k in range(ny):
            yvector = yvectdisplacement + yvector
            for l in range(nx):
                # Copy in x-direction
                xvector = xvectdisplacement + xvector
                xyvector = yvector + xvector
                # translate curve in x and y-direction
                PCNew = PolyCurve.copy_translate(PC, xyvector)
                pan = Panel.by_polycurve_thickness(PCNew, thickness, 0, "name", color)
                panels.append(pan)
            xvector = Vector.sum(
                xvectdisplacement,
                Vector(-test.basepanels[0].origincurve.curves[1].length, 0, 0),
            )
    return panels



class Wall:
	def __init__(self):
		
		self.name = None
		self.verts = None
		self.faces = None
		# self.polycurve = None or self.profile
		self.parms = None


	@classmethod
	def by_mesh(self, verts=list, faces=list):
		wall = Wall()
		wall.verts = [vertex * project.scale for vertex in verts]
		wall.faces = list(faces)
		return wall

	def __str__(self) -> str:
		return f"{self.type}(Name={self.name})"

