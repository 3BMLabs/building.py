#[BuildingPy] DO NOT EDIT THIS FILE. IT IS GENERATED FROM THE SOURCE CODE
try:
    from collections.abc import MutableSequence
except ImportError:
    from collections import MutableSequence

import sys
from pathlib import Path
from typing import List
import json
from packages.svg.path import parse_path
from typing import Any, List
import copy
import pickle
from functools import reduce
import struct
from typing import Self
import importlib
import string, random, json
import urllib
import xml.etree.ElementTree as ET
from math import sqrt, cos, sin, acos, degrees, radians, log, pi
from bisect import bisect
from abc import ABC, abstractmethod
import re
from packages.svg.path import path
import sys, math
import math
import operator
from typing import Self, Union
import sys, os, math
from typing import Union
from objects import profile
import sys, os, math, json
from collections import defaultdict
import urllib.request


class Serializable:
    @property
    def type(self):
        return __class__.__name__
    @staticmethod
    def serialize_type(obj) -> dict:
        """Save the type of an object to a dictionary.

        Args:
            obj: the object to get the type of

        Returns:
            dict: a dictionary with keys 'module' and 'type'
        """
        return {
            'module': obj.__module__,
            'type': obj.__class__.__name__
            }
        
    def serialize(self) -> dict:
        """serialize members of this object into a dictionary

        Returns:
            dict: a dictionary of all members. the members will serialize themselves, when necessary.
        """
        return self.__dict__
    
    def toJson(self) -> str:
        """converts a serializable object to json

        Returns:
            str: a json string
        """
        return json.dumps(self, default=lambda x: 
            #when a variable is not compatible with the standard json serialization functions, it's probably one of our classes.
            x.serialize() | self.serialize_type(x)
            )
    
    @staticmethod
    def deserialize_type(data):
        """Creates an new object from the provided data."""
        if isinstance(data, dict):
            if 'type' in data:
                #module_name =  # data.pop('__module__')
                module = importlib.import_module(data.pop('module'))
                type = getattr(module, data.pop('type'))

                if hasattr(type, 'deserialize'):
                    obj = type.deserialize(data)
                else:
                    obj = type.__new__(type)
                    #we assume obj is an instance of Serializable
                    obj.deserialize_members(data)
                #obj.deserialize(data)
                return obj
            #else:
            #    return {key: Serializable.deserialize_type(value) for key, value in data.items()}
        elif isinstance(data, list):
            return [Serializable.deserialize_type(item) for item in data]
        return data
    
    def deserialize_members(self, data : dict):
        """Deserializes the object from the provided data."""
    #    #raise NotImplementedError()
        for key, value in data.items():
            setattr(self, key, self.deserialize_type(value))
    
    def save(self, file_name):
        # we can possibly add an override function we can call on class objects. but for now, this will work fine
        serialized_data = self.toJson()
        with open(file_name, 'w') as file:
            file.write(serialized_data)
            
    def open(self, file_name):
        with open(file_name) as file:
            self.deserialize_members(json.load(file))
            # self.__dict__ = json.load(file)
    def __repr__(self) -> str:
        return str(self)
def to_array(*args) -> list:
    """converts the arguments into an array.

    Returns:
        list: the arguments provided, converted to a list.
    """
    return args[0] if len(args) == 1 and hasattr(args[0], "__getitem__") else list(args)


class Coords(Serializable, list):
    """
    a shared base class for point and vector. contains the x, y and z coordinates.
    operations you do with these coords will apply for the children.
    for example: Vector(2, 4, 6) / 2 = Vector(1, 2, 3)
    or: Vector(2,5) ** 2 = Vector(4, 25)
    Vectors can also be nested.
    """
    def __init__(self, *args, **kwargs) -> 'Coords':
        arrayArgs:list = to_array(*args)

        list.__init__(self, arrayArgs)
        Serializable.__init__(self)

        for kwarg in kwargs.items():
            self.set_axis_by_name(kwarg[0], kwarg[1])            

    def __str__(self):
        return self.__class__.__name__ + '(' + ','.join([f'{axis_name}={((v * 100) // 1 ) / 100 }' for v, axis_name in zip(self, self.axis_names)]) + ')'
    
    axis_names = ['x', 'y', 'z', 'w']
    
    @property
    def x(self): return self[0]
    @x.setter
    def x(self, value): self[0] = value
        
    @property
    def y(self): return self[1]
    @y.setter
    def y(self, value): self[1] = value

    @property
    def z(self): return self[2]
    @z.setter
    def z(self, value): self[2] = value

    @property
    def w(self): return self[3]
    @w.setter
    def w(self, value): self[3] = value
    
    @property
    def squared_magnitude(self):
        result = 0
        for axis_value in self:
            result += axis_value * axis_value
        return result
    
    @property
    def magnitude(self): 
        """the 'length' could also mean the axis count. this makes it more clear.
        Returns:
            the length
        """
        return math.sqrt(self.squared_magnitude)
    
    @magnitude.setter
    def magnitude(self, value):
        """Rescales the vector to have the specified length.

        #### Parameters:
        - `vector_1` (`Vector`): The vector to be rescaled.
        - `newlength` (float): The desired length of the vector.

        #### Returns:
        `Vector`: A new Vector object representing the rescaled vector.

        #### Example usage:
        ```python
        vector = Vector(3, 4, 0)
        new_vector = Vector.new_length(vector, 5)
        # Vector(X = 3.000, Y = 4.000, Z = 0.000)
        ```
        """
        self *= value / self.magnitude
    
    @property
    def normalized(self):
        """Returns the normalized form of the vector.
        The normalized form of a vector is a vector with the same direction but with a length (magnitude) of 1.

        #### Returns:
        `Vector`: A new Vector object representing the normalized form of the input vector.

        #### Example usage:
        ```python
        vector1 = Vector(3, 0, 4)
        normalized_vector = vector1.normalized
        # Vector(X = 0.600, Y = 0.000, Z = 0.800)
        ```
        """
        sqm = self.squared_magnitude
        
        return self / math.sqrt(sqm) if sqm > 0 else Coords()
    
    @property
    def angle(self) -> float:
        """output range: -PI to PI

        Returns:
            float: the arc tangent of y / x in radians
        """
        #treat this normal vector as a triangle. we know all sides but want to know the angle.
        #tan(deg) = other side / straight side
        #deg = atan(other side / straight side)
        return math.atan2(self.x, self.y)
    
    @staticmethod
    def angle_between(vector_1: 'Coords', vector_2: 'Coords') -> float:
        """Computes the angle in degrees between two coords.
        The angle between two coords is the angle required to rotate one vector onto the other, measured in degrees.

        #### Parameters:
        - `vector_1` (`Vector`): The first vector.
        - `vector_2` (`Vector`): The second vector.

        #### Returns:
        `float`: The angle in degrees between the input coords.

        #### Example usage:
        ```python
        vector1 = Vector(1, 0, 0)
        vector2 = Vector(0, 1, 0)
        angle = Vector.angle_between(vector1, vector2)
        # 90
        ```
        """
        dot_product = Coords.dot_product(vector_1, vector_2)
        length_vector_1 = vector_1.magnitude
        length_vector_2 = vector_2.magnitude

        if length_vector_1 == 0 or length_vector_2 == 0:
            return 0

        cos_angle = dot_product / (length_vector_1 * length_vector_2)
        cos_angle = max(-1.0, min(cos_angle, 1.0))
        return math.acos(cos_angle)

    @staticmethod
    def dot_product(vector_1: 'Coords', vector_2: 'Coords') -> 'float':
        """Computes the dot product of two vectors.
        The dot product of two vectors is a scalar quantity equal to the sum of the products of their corresponding components. It gives insight into the angle between the vectors.

        #### Parameters:
        - `vector_1` (`Coords`): The first vector.
        - `vector_2` (`Coords`): The second vector.

        #### Returns:
        `float`: The dot product of the input vectors.

        #### Example usage:
        ```python
        vector1 = Vector(1, 2, 3)
        vector2 = Vector(4, 5, 6)
        dot_product = Vector.dot_product(vector1, vector2)
        # 32
        ```
        """
        total = 0
        for i in range(len(vector_1)):
            total += vector_1[i] * vector_2 [i]
        return total
    
    @staticmethod
    def distance_squared(point_1: 'Coords', point_2: 'Coords') -> float:
        """Computes the Euclidean distance between two 3D points.

        #### Parameters:
        - `point_1` (Coords): The first point.
        - `point_2` (Coords): The second point.

        #### Returns:
        `float`: The Euclidean distance between `point_1` and `point_2`.

        #### Example usage:
    	```python
        point_1 = Coords(0, 0, 400)
        point_2 = Coords(300, 0, 400)
        output = Coords.distance(point_1, point_2) 
        # 90000
        ```
        """
        return (point_2 - point_1).squared_magnitude
    
    @staticmethod
    def distance(point_1: 'Coords', point_2: 'Coords') -> float:
        """Computes the Euclidean distance between two 3D points.

        #### Parameters:
        - `point_1` (Coords): The first point.
        - `point_2` (Coords): The second point.

        #### Returns:
        `float`: The Euclidean distance between `point_1` and `point_2`.

        #### Example usage:
    	```python
        point_1 = Coords(0, 0, 400)
        point_2 = Coords(300, 0, 400)
        output = Coords.distance(point_1, point_2) 
        # 90000
        ```
        """
        return (point_2 - point_1).magnitude
    
    @staticmethod
    def axis_index(axis:str) -> int:
        """returns index of axis name.<br>
        raises a valueError when the name isn't valid.

        Args:
            axis (str): the name of the axis

        Returns:
            int: the index
        """
        return Coords.axis_names.index(axis.lower())

    def change_axis_count(self,axis_count: int):
        """in- or decreases the amount of axes to the preferred axis count.

        Args:
            axis_count (int): the new amount of axes
        """
        if axis_count > len(self):
            diff = axis_count + 1 - len(self)
            self.extend([0] * diff)
        else:
            self = self[:axis_count]
    def set_axis(self, axis_index: int, value) -> int | None:
        """sets an axis with the specified index to the value. will resize when the coords can't contain them.

        Args:
            axis_index (int): the index of the axis, for example 2
            value: the value to set the axis to

        Returns:
            int: the new size when resized, -1 when the axis is invalid, None when the value was just set.
        """

        if axis_index >= len(self):
            self.extend([0] * (axis_index - len(self)))
            self.extend([value])
            return axis_index
        self[axis_index] = value
        return None
        
    def set_axis_by_name(self, axis_name: str, value) -> int | None:
        """sets an axis with the specified name to the value. will resize when the coords can't contain them.

        Args:
            axis_name (str): the name of the axis, for example 'x'
            value: the value to set the axis to

        Returns:
            int: the new size when resized, -1 when the axis is invalid, None when the value was just set.
        """
        return self.set_axis(Coords.axis_index(axis_name), value)
    
    @staticmethod
    def by_two_points(point_1: 'Coords', point_2: 'Coords') -> 'Coords':
        """Computes the vector between two points.

        #### Parameters:
        - `point_1` (`Coords`): The starting point.
        - `point_2` (`Coords`): The ending point.

        #### Returns:
        `Vector`: A new Vector object representing the vector between the two points.

        #### Example usage:
        ```python
        point1 = Point(1, 2, 3)
        point2 = Point(4, 6, 8)
        vector = Vector.by_two_points(point1, point2)
        # Vector(X = 3, Y = 4, Z = 5)
        ```
        """
        return point_2 - point_1
        
    def volume(self):
        result = 1
        for val in self:
            result *= val
        return result
        
    #useful for sorting
    def compare(self, other):
        for axis in range(len(self)):
            if self[axis] != other[axis]:
                return other[axis] - self[axis]
        return 0
    
    def ioperate_2(self, op: operator, other):
        try:
            for index in range(len(self)):
                self[index] = op(self[index], other[index])
        except TypeError:
            #variable doesn't support index
            #https://stackoverflow.com/questions/7604380/check-for-operator
            for index in range(len(self)):
                self[index] = op(self[index], other)
        return self
    
    def operate_2(self, op:operator, other):
        result = Coords([0] * len(self))
        try:
            for index in range(len(self)):
                result[index] = op(self[index], other[index])
        except TypeError:
            #variable doesn't support index
            #https://stackoverflow.com/questions/7604380/check-for-operator
            for index in range(len(self)):
                result[index] = op(self[index], other)
        return result
    def operate_1(self, op:operator):
        result = Coords([0] * len(self))
        for index in range(len(self)):
            result[index] = op(self[index])
        return result
    
    def __add__(self, other):
        """Calculates the sum of two vectors.
        
        equivalent to the + operator.
        
        """
        return self.operate_2(operator.__add__,other)
    
    sum = __add__
    
    def __sub__(self, other):
        """Calculates the difference between two Vector objects.
        This method returns a new Vector object that is the result of subtracting the components of `vector_2` from `vector_1`.

        equivalent to the - operator.

        #### Parameters:
        - `vector_1` (`Vector`): The minuend vector.
        - `vector_2` (`Vector`): The subtrahend vector.

        #### Returns:
        `Vector`: A new Vector object resulting from the component-wise subtraction of `vector_2` from `vector_1`.

        #### Example usage:
        ```python
        vector1 = Vector(5, 7, 9)
        vector2 = Vector(1, 2, 3)
        result = Vector.diff(vector1, vector2)
        # Vector(X = 4.000, Y = 5.000, Z = 6.000)
        ```
        """
        return self.operate_2(operator.__sub__,other)
    

    difference = diff = substract = __sub__
    
    def __truediv__(self, other):
        """Divides the components of the first vector by the corresponding components of the second vector.
        This method performs component-wise division. If any component of `vector_2` is 0, the result for that component will be undefined.

        equivalent to the / operator.

        #### Parameters:
        - `vector_1` (`Vector`): The numerator vector.
        - `vector_2` (`Vector`): The denominator vector.

        #### Returns:
        `Vector`: A new Vector object resulting from the component-wise division.

        #### Example usage:
        ```python
        vector1 = Vector(10, 20, 30)
        vector2 = Vector(2, 4, 5)
        result = Vector.divide(vector1, vector2)
        # Vector(X = 5.000, Y = 5.000, Z = 6.000)
        ```
        """
        return self.operate_2(operator.__truediv__,other)
    
    divide = __truediv__
    
    def __mul__(self, other):
        """Scales the vector by the specified scale factor.

        equivalent to the * operator.

        #### Parameters:
        - `vector` (`Vector`): The vector to be scaled.
        - `scalefactor` (float): The scale factor.

        #### Returns:
        `Vector`: A new Vector object representing the scaled vector.

        #### Example usage:
        ```python
        vector = Vector(1, 2, 3)
        scaled_vector = Vector.scale(vector, 2)
        # Vector(X = 2, Y = 4, Z = 6)
        ```
        """
        return self.operate_2(operator.__mul__,other)
    product = scale = __rmul__ = __mul__
    
    
    
    def __pow__(self, power: float) -> Self:
        """raises the vector to a certain power.
        
        equivalent to the ** operator.

        Returns:
            Self: a vector with all components raised to the specified power
        """
        return self.ioperate_2(operator.__pow__)
    
    def __neg__(self) -> Self:
        """negates this vector.

        equivalent to the - operator.

        Returns:
            Self: a vector with all components negated.
        """
        return self.operate_1(operator.__neg__)
    
    reverse = __neg__
    
    @staticmethod
    def square(self) -> 'Coords':
        """
        Computes the square of each component of the input vector.

        #### Parameters:
        - `vector_1` (`Vector`): The input vector.

        #### Returns:
        `Vector`: A new Vector object representing the square of each component of the input vector.

        #### Example usage:
        ```python
        vector = Vector(2, 3, 4)
        squared_vector = Vector.square(vector)
        # Vector(X = 4, Y = 9, Z = 16)
        ```
        """
        return self ** 2
    
    
    #i operators. these operate on self (+=, *=, etc)
    
    def __iadd__(self, other) -> Self:
        """Translates the point by a given vector.        

        equivalent to the += operator.
        
        #### Parameters:
        - `point` (Point): The point to be translated.
        - `vector` (Vector): The translation vector.

        #### Returns:
        `Point`: Translated point.

        #### Example usage:
    	```python
        point = Point(23, 1, 23)
        vector = Vector(93, 0, -19)
        output = Point.translate(point, vector)
        # Point(X = 116.000, Y = 1.000, Z = 4.000)
        ```
        """
        return self.ioperate_2(operator.__iadd__,other)

    translate = __iadd__
    
    def __isub__(self, other) -> Self:
        return self.ioperate_2(operator.__isub__,other)
    
    def __imul__(self, other) -> Self:
        return self.ioperate_2(operator.__imul__,other)
    
    def __itruediv__(self, other) -> Self:
        return self.ioperate_2(operator.__itruediv__,other)
    
X_axis = Coords(1, 0, 0)

Y_Axis = Coords(0, 1, 0)

Z_Axis = Coords(0, 0, 1)

class ID(Serializable):
    def __init__(self) -> None:
        self.id = None
        self.object = None
        self.name = None
        self.generateID()

    def generateID(self) -> None:
        id = ""
        lengthID = 12
        random_source = string.ascii_uppercase + string.digits
        for x in range(lengthID):
            id += random.choice(random_source)

        id_list = list(id)
        self.id = f"#"+"".join(id_list)
        return f"test {self.__class__.__name__}"

    def str(self) -> str:
        return f"{self.id}"

def generateID() -> ID:
    return ID()

def find_in_list_of_list(mylist, char):
    for sub_list in mylist:
        if char in sub_list:
            return (mylist.index(sub_list))
    raise ValueError("'{char}' is not in list".format(char=char))


def findjson(id, json_string):
    #faster way to search in json
    results = []

    def _decode_dict(a_dict):
        try:
            results.append(a_dict[id])
        except KeyError:
            pass
        return a_dict

    json.loads(json_string, object_hook=_decode_dict) # Return value ignored.
    return results

def list_transpose(lst):
    #list of lists, transpose columns/rows
    newlist = list(map(list, zip(*lst)))
    return newlist

def is_null(lst):
    return all(el is None for el in lst)

def clean_list(input_list, preserve_indices=True):
    if not input_list:
        return input_list
    
    culled_list = []

    if preserve_indices:
        if is_null(input_list):
            return None
        
        j = len(input_list) - 1
        while j >= 0 and input_list[j] is None:
            j -= 1

        for i in range(j + 1):
            sublist = input_list[i]

            if isinstance(sublist, list):
                val = clean_list(sublist, preserve_indices)
                culled_list.append(val)
            else:
                culled_list.append(input_list[i])
    else:
        if is_null(input_list):
            return []
        
        for el in input_list:
            if isinstance(el, list):
                if not is_null(el):
                    val = clean_list(el, preserve_indices=False)
                    if val:
                        culled_list.append(val)
            elif el is not None:
                culled_list.append(el)
            
    return culled_list

def flatten(list:list[list]):
    """convert 2d list to 1d list

    Args:
        list (list[list]): a list of lists

    Returns:
        a list containing all elements: _description_
    """
    return [elem for sublist in list for elem in sublist]
    #if type(lst) != list:
    #    lst = [lst]
    #flat_list = []
    #for sublist in lst:
    #    try:
    #        for item in sublist:
    #            flat_list.append(item)
    #    except:
    #        flat_list.append(sublist)
    #return flat_list

def all_true(lst):
    for element in lst:
        if not element:
            return False
    return True

def replace_at_index(object, index, new_object):
    if index < 0 or index >= len(object):
        raise IndexError("Index out of range")
    return object[:index] + new_object + object[index+1:]

def xmldata(myurl, xPathStrings):
    urlFile = urllib.request.urlopen(myurl)
    tree = ET.parse(urlFile)
    xPathResults = []
    for xPathString in xPathStrings:
        a = tree.findall(xPathString)
        xPathResulttemp2 = []
        for xPathResult in a:
            xPathResulttemp2.append(xPathResult.text)
        xPathResults.append(xPathResulttemp2)
    return xPathResults

# from project.fileformat import project


class Point(Coords):
    """Represents a point in 3D space with x, y, and z coordinates."""
    def __init__(self, *args, **kwargs) -> 'Point':
        """Initializes a new Point instance with the given x, y, and z coordinates.

        - `x` (float): X-coordinate of the point.
        - `y` (float): Y-coordinate of the point.
        - `z` (float): Z-coordinate of the point.
        """
        super().__init__(*args, **kwargs)
        self.units = "mm"

    @staticmethod
    def distance_list(points: list['Point']) -> float:
        """Calculates distances between points in a list.
        
        #### Parameters:
        - `points` (list): List of points.

        #### Returns:
        `float`: Total distance calculated between all the points in the list.

        #### Example usage:
    	```python
        point_1 = Point(231, 13, 76)
        point_2 = Point(71, 12.3, -232)
        point_3 = Point(2, 71, -102)
        output = Point.distance_list([point_1, point_2, point_3])
        # [(<geometry.point.Point object at 0x00000226BD9CAB90>, <geometry.point.Point object at 0x00000226BA3BCFD0>, 158.45090722365714), (<geometry.point.Point object at 0x00000226BF20F710>, <geometry.point.Point object at 0x00000226BA3BCFD0>, 295.78539517697624), (<geometry.point.Point object at 0x00000226BF20F710>, <geometry.point.Point object at 0x00000226BD9CAB90>, 347.07994756251765)]
        ```
        """
        distances = []
        for i in range(len(points)):
            for j in range(i+1, len(points)):
                distances.append(
                    (points[i], points[j], Point.distance(points[i], points[j])))
        distances.sort(key=lambda x: x[2])
        return distances

    @staticmethod
    def origin(point_1: 'Point', point_2: 'Point') -> 'Point':
        """Computes the midpoint between two points.        
        
        #### Parameters:
        - `point_1` (Point): First point.
        - `point_2` (Point): Second point.
        
        #### Returns:
        `Point`: Midpoint between the two input points.

        #### Example usage:
    	```python
        point_1 = Point(100.23, 182, 19)
        point_2 = Point(81, 0.1, -901)
        output = Point.origin(point_1, point_2)
        # Point(X = 90.615, Y = 91.050, Z = -441.000)
        ```
        """
        return Point(
            (point_1.x + point_2.x) / 2,
            (point_1.y + point_2.y) / 2,
            (point_1.z + point_2.z) / 2
        )

    @staticmethod
    def rotate_XY(point: 'Point', beta: float, dz: float) -> 'Point':
        """Rotates the point about the Z-axis by a given angle.        
        
        #### Parameters:
        - `point` (Point): Point to be rotated.
        - `beta` (float): Angle of rotation in degrees.
        - `dz` (float): Offset in the z-coordinate.

        #### Returns:
        `Point`: Rotated point.

        #### Example usage:
    	```python
        point_1 = Point(19, 30, 12.3)
        output = Point.rotate_XY(point_1, 90, 12)
        # Point(X = -30.000, Y = 19.000, Z = 24.300)
        ```
        """
        return Point(
            math.cos(math.radians(beta))*point.x -
            math.sin(math.radians(beta))*point.y,
            math.sin(math.radians(beta))*point.x +
            math.cos(math.radians(beta))*point.y,
            point.z + dz
        )

    @staticmethod
    def intersect(point_1: 'Point', point_2: 'Point') -> 'bool':
        """Checks if two points intersect.        
        
        #### Parameters:
        - `point_1` (Point): First point.
        - `point_2` (Point): Second point.

        #### Returns:
        `boolean`: True if points intersect, False otherwise.

        #### Example usage:
    	```python
        point_1 = Point(23, 1, 23)
        point_2 = Point(93, 0, -19)
        output = Point.intersect(point_1, point_2)
        # False
        ```
        """
        return point_1.x == point_2.x and point_1.y == point_2.y and point_1.z == point_2.z

    @staticmethod
    def from_matrix(list: list) -> 'Point':
        """Converts a list to a Point object.        
        
        #### Parameters:
        Converts a list to a Point object.

        #### Returns:
        `Point`: Point object created from the list.

        #### Example usage:
    	```python
        point_1 = [19, 30, 12.3]
        output = Point.from_matrix(point_1)
        # Point(X = 19.000, Y = 30.000, Z = 12.300)
        ```
        """
        return Point(list)


class CoordinateSystem:
    """Represents a coordinate system in 3D space defined by an origin point and normalized x, y, and z axis vectors."""
    def __init__(self, origin: Point, x_axis, y_axis, z_axis) -> 'CoordinateSystem':
        """Initializes a new CoordinateSystem instance with the given origin and axis vectors.
        The axis vectors are normalized to ensure they each have a length of 1, providing a standard basis for the coordinate system.

        - `origin` (Point): The origin point of the coordinate system.
        - `x_axis` (Vector): The initial vector representing the X-axis before normalization.
        - `y_axis` (Vector): The initial vector representing the Y-axis before normalization.
        - `z_axis` (Vector): The initial vector representing the Z-axis before normalization.
        """
        from abstract.vector import Vector
        
        self.Origin = origin
        self.X_axis = x_axis
        self.Y_axis = y_axis
        self.Z_axis = z_axis

    @classmethod
    def by_origin(coordinate_system, origin: Point) -> 'CoordinateSystem':
        """Creates a CoordinateSystem with a specified origin.

        #### Parameters:
        - `origin` (`Point`): The origin point of the new coordinate system.

        #### Returns:
        `CoordinateSystem`: A new CoordinateSystem object with the specified origin.

        #### Example usage:
        ```python

        ```
        """
        from abstract.coordinatesystem import X_axis, Y_Axis, Z_Axis
        return coordinate_system(origin, x_axis=X_axis, y_axis=Y_Axis, z_axis=Z_Axis)

    @staticmethod
    def translate(cs_old, direction):
        """Translates a CoordinateSystem by a given direction vector.

        #### Parameters:
        - `cs_old` (CoordinateSystem): The original coordinate system to be translated.
        - `direction` (Vector): The direction vector along which the coordinate system is to be translated.

        #### Returns:
        `CoordinateSystem`: A new CoordinateSystem object translated from the original one.

        #### Example usage:
        ```python

        ```
        """

        from abstract.vector import Vector
        new_origin = Point.translate(cs_old.Origin, direction)

        X_axis = Vector(1, 0, 0)

        Y_Axis = Vector(0, 1, 0)

        Z_Axis = Vector(0, 0, 1)

        CSNew = CoordinateSystem(
            new_origin, x_axis=X_axis, y_axis=Y_Axis, z_axis=Z_Axis)

        CSNew.Origin = new_origin
        return CSNew

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y and self.z == other.z

    @staticmethod
    def by_point_main_vector(self, new_origin_coordinatesystem: Point, DirectionVectorZ):
        """Creates a new CoordinateSystem at a given point, oriented along a specified direction vector.
        This method establishes a new coordinate system by defining its origin and its Z-axis direction. The X and Y axes are determined based on the given Z-axis to form a right-handed coordinate system. If the calculated X or Y axis has a zero length (in cases of alignment with the global Z-axis), default axes are used.

        #### Parameters:
        - `new_origin_coordinatesystem` (`Point`): The origin point of the new coordinate system.
        - `DirectionVectorZ` (Vector): The direction vector that defines the Z-axis of the new coordinate system.

        #### Returns:
        `CoordinateSystem`: A new CoordinateSystem object oriented along the specified direction vector with its origin at the given point.

        #### Example usage:
        ```python

        ```
        """
        from abstract.vector import Vector
        vz = DirectionVectorZ
        vz = Vector.normalize(vz)
        vx = Vector.perpendicular(vz)[0]
        try:
            vx = Vector.normalize(vx)
        except:
            vx = Vector(1, 0, 0)
        vy = Vector.perpendicular(vz)[1]
        try:
            vy = Vector.normalize(vy)
        except:
            vy = Vector(0, 1, 0)
        CSNew = CoordinateSystem(new_origin_coordinatesystem, vx, vy, vz)
        return CSNew

    @staticmethod
    def move_local(cs_old, x: float, y: float, z: float):
        """Moves a CoordinateSystem in its local coordinate space by specified displacements.

        #### Parameters:
        - `cs_old` (CoordinateSystem): The original coordinate system to be moved.
        - `x` (float): The displacement along the local X-axis.
        - `y` (float): The displacement along the local Y-axis.
        - `z` (float): The displacement along the local Z-axis.

        #### Returns:
        `CoordinateSystem`: A new CoordinateSystem object moved in its local coordinate space.

        #### Example usage:
        ```python

        ```
        """
        
        from abstract.vector import Vector

        xloc_vect_norm = cs_old.X_axis
        xdisp = Vector.scale(xloc_vect_norm, x)
        yloc_vect_norm = cs_old.X_axis
        ydisp = Vector.scale(yloc_vect_norm, y)
        zloc_vect_norm = cs_old.X_axis
        zdisp = Vector.scale(zloc_vect_norm, z)
        disp = xdisp + ydisp + zdisp
        CS = CoordinateSystem.translate(cs_old, disp)
        return CS

    @staticmethod
    def translate_origin(origin1, origin2):
        """Calculates the translation needed to move from one origin to another.

        #### Parameters:
        - `origin1` (Point): The starting origin point.
        - `origin2` (Point): The ending origin point.

        #### Returns:
        `Point`: A new Point object representing the translated origin.

        #### Example usage:
        ```python
        
        ```
        """
        origin1_n = Point.to_matrix(origin1)
        origin2_n = Point.to_matrix(origin2)

        new_origin_n = origin1_n + (origin2_n - origin1_n)
        return Point(new_origin_n[0], new_origin_n[1], new_origin_n[2])

    @staticmethod
    def calculate_rotation_matrix(xaxis_1, yaxis_1, zaxis_1, xaxis_2, yaxis_2, zaxis_2):
        """Calculates the rotation matrix needed to align one coordinate system with another.

        #### Parameters:
        - `xaxis_1`, `yaxis_1`, `zaxis_1` (Vector): The axes of the initial coordinate system.
        - `xaxis_2`, `yaxis_2`, `zaxis_2` (Vector): The axes of the target coordinate system.

        #### Returns:
        Rotation Matrix (list of lists): A matrix representing the rotation needed to align the first coordinate system with the second.

        #### Example usage:
        ```python
        
        ```
        """
        from abstract.vector import Vector

        R1 = [Vector.to_matrix(xaxis_1), Vector.to_matrix(
            yaxis_1), Vector.to_matrix(zaxis_1)]

        R2 = [Vector.to_matrix(xaxis_2), Vector.to_matrix(
            yaxis_2), Vector.to_matrix(zaxis_2)]

        R1_transposed = list(map(list, zip(*R1)))
        R2_transposed = list(map(list, zip(*R2)))

        rotation_matrix = Vector.dot_product(Vector.from_matrix(
            R2_transposed), Vector.length(Vector.from_matrix(R1_transposed)))
        return rotation_matrix

    @staticmethod
    def normalize(point: Point) -> list:
        """Normalizes a vector to have a length of 1.
        This method calculates the normalized (unit) version of a given vector, making its length equal to 1 while preserving its direction. If the input vector has a length of 0 (i.e., it is a zero vector), the method returns the original vector.

        #### Parameters:
        - `point` (list of float): A vector represented as a list of three floats, corresponding to its x, y, and z components, respectively.

        #### Returns:
        list of float: The normalized vector as a list of three floats. If the original vector is a zero vector, returns the original vector.

        #### Example usage:
        ```python
        
        ```
        """
        norm = (point[0]**2 + point[1]**2 + point[2]**2)**0.5
        return [point[0] / norm, point[1] / norm, point[2] / norm] if norm > 0 else point


def transform_point(point_local: Point, coordinate_system_old: CoordinateSystem, new_origin: Point, direction_vector) -> Point:
    """Transforms a point from one coordinate system to another based on a new origin and a direction vector.
    This function calculates the new position of a point when the coordinate system is changed. The new coordinate system is defined by a new origin point and a direction vector that specifies the orientation of the Z-axis. The X and Y axes are computed to form a right-handed coordinate system. This method takes into account the original position of the point in the old coordinate system to accurately calculate its position in the new coordinate system.

    #### Parameters:
    - `point_local` (Point): The point to be transformed, given in the local coordinate system.
    - `coordinate_system_old` (CoordinateSystem): The original coordinate system the point is in.
    - `new_origin` (Point): The origin of the new coordinate system.
    - `direction_vector` (Vector): The direction vector defining the new Z-axis of the coordinate system.

    #### Returns:
    Point: The transformed point in the new coordinate system.

    #### Example usage:
    ```python
    
    ```
    """
    from abstract.vector import Vector

    direction_vector = Vector.to_matrix(direction_vector)
    new_origin = Point.to_matrix(new_origin)
    vz_norm = Vector.length(Vector(*direction_vector))
    vz = [direction_vector[0] / vz_norm, direction_vector[1] /
          vz_norm, direction_vector[2] / vz_norm]

    vx = [-vz[1], vz[0], 0]
    vx_norm = Vector.length(Vector(*vx))

    if vx_norm == 0:
        vx = [1, 0, 0]
    else:
        vx = [vx[0] / vx_norm, vx[1] / vx_norm, vx[2] / vx_norm]

    vy = Vector.cross_product(Vector(*vz), Vector(*vx))
    vy_norm = Vector.length(vy)
    if vy_norm != 0:
        vy = [vy.x / vy_norm, vy.y / vy_norm, vy.z / vy_norm]
    else:
        vy = [0, 1, 0]

    point_1 = point_local
    CSNew = CoordinateSystem(Point.from_matrix(new_origin), Vector.from_matrix(
        vx), Vector.from_matrix(vy), Vector.from_matrix(vz))
    vector_1 = Point.difference(coordinate_system_old.Origin, CSNew.Origin)

    vector_2 = Vector.product(point_1.x, CSNew.X_axis)
    vector_3 = Vector.product(point_1.y, CSNew.Y_axis)
    vector_4 = Vector.product(point_1.z, CSNew.Z_axis)
    vtot = Vector(vector_1.x + vector_2.x + vector_3.x + vector_4.x, vector_1.y + vector_2.y +
                   vector_3.y + vector_4.y, vector_1.z + vector_2.z + vector_3.z + vector_4.z)
    pointNew = Point.translate(Point(0, 0, 0), vtot)

    return pointNew


def transform_point_2(PointLocal: Point, CoordinateSystemNew: CoordinateSystem) -> Point:
    """Transforms a point from its local coordinate system to a new coordinate system.
    This function translates a point based on its local coordinates (x, y, z) within its current coordinate system to a new position in a specified coordinate system. The transformation involves scaling the local coordinates by the axes vectors of the new coordinate system and sequentially translating the point along these axes vectors starting from the new origin.

    #### Parameters:
    - `PointLocal` (`Point`): The point in its local coordinate system to be transformed.
    - `CoordinateSystemNew` (`CoordinateSystem`): The new coordinate system to which the point is to be transformed.

    #### Returns:
    `Point`: The point transformed into the new coordinate system.

    #### Example usage:
    ```python
    
    ```
    """
    from abstract.vector import Vector
    pn = Point.translate(CoordinateSystemNew.Origin, Vector.scale(
        CoordinateSystemNew.X_axis, PointLocal.x))
    pn2 = Point.translate(pn, Vector.scale(
        CoordinateSystemNew.Y_axis, PointLocal.y))
    pn3 = Point.translate(pn2, Vector.scale(
        CoordinateSystemNew.Z_axis, PointLocal.z))
    return pn3


class Vector(Coords):
    """Represents a 3D vector with x, y, and z coordinates."""
    def __init__(self, *args, **kwargs) -> 'Vector':
        """Initializes a new Vector instance with the given x, y, and z coordinates.

        - `x` (float): X-coordinate of the vector.
        - `y` (float): Y-coordinate of the vector.
        - `z` (float): Z-coordinate of the vector.
        """
        super().__init__(*args, **kwargs)

    @staticmethod
    def to_line(vector_1: 'Vector', vector_2: 'Vector') -> 'Vector':
        """Creates a Line object from two vectors.

        #### Parameters:
        - `vector_1` (`Vector`): The start vector of the line.
        - `vector_2` (`Vector`): The end vector of the line.

        #### Returns:
        `Line`: A Line object connecting the two vectors.

        #### Example usage:
        ```python
        vector1 = Vector(10, 20, 30)
        vector2 = Vector(2, 4, 5)
        line = Vector.to_line(vector1, vector2)
        # Line(start=Point(X = 10.000, Y = 20.000, Z = 30.000), end=Point(X = 2.000, Y = 4.000, Z = 5.000))
        ```
        """
        from geometry.point import Point
        from geometry.curve import Line
        return Line(start=Point(x=vector_1.x, y=vector_1.y, z=vector_1.z), end=Point(x=vector_2.x, y=vector_2.y, z=vector_2.z))

    @staticmethod
    def by_line(line_1) -> 'Vector':
        """Computes a vector representing the direction of a given line.
        This method takes a Line object and returns a Vector representing the direction of the line.

        #### Parameters:
        - `line_1` (`Line`): The Line object from which to extract the direction.

        #### Returns:
        `Vector`: A Vector representing the direction of the line.

        #### Example usage:
        ```python
        line = Line(start=Point(0, 0, 0), end=Point(1, 1, 1))
        direction_vector = Vector.by_line(line)
        # Vector(X = 1, Y = 1, Z = 1)
        ```
        """
        return Vector(line_1.dx, line_1.dy, line_1.dz)

    @staticmethod
    def cross_product(vector_1: 'Vector', vector_2: 'Vector') -> 'Vector':
        """Computes the cross product of two vectors.
        The cross product of two vectors in three-dimensional space is a vector that is perpendicular to both original vectors. It is used to find a vector that is normal to a plane defined by the input vectors.

        #### Parameters:
        - `vector_1` (`Vector`): The first vector.
        - `vector_2` (`Vector`): The second vector.

        #### Returns:
        `Vector`: A new Vector object representing the cross product of the input vectors.

        #### Example usage:
        ```python
        vector1 = Vector(1, 2, 3)
        vector2 = Vector(4, 5, 6)
        cross_product = Vector.cross_product(vector1, vector2)
        # Vector(X = -3, Y = 6, Z = -3)
        ```
        """
        return Vector(
            vector_1.y*vector_2.z - vector_1.z*vector_2.y,
            vector_1.z*vector_2.x - vector_1.x*vector_2.z,
            vector_1.x*vector_2.y - vector_1.y*vector_2.x
        )


    @staticmethod
    def product(number: float, vector_1: 'Vector') -> 'Vector':
        """Scales a vector by a scalar value.
        This method multiplies each component of the vector by the given scalar value.

        #### Parameters:
        - `number` (float): The scalar value to scale the vector by.
        - `vector_1` (`Vector`): The vector to be scaled.

        #### Returns:
        `Vector`: A new Vector object representing the scaled vector.

        #### Example usage:
        ```python
        vector1 = Vector(1, 2, 3)
        scaled_vector = Vector.product(2, vector1)
        # Vector(X = 2, Y = 4, Z = 6)
        ```
        """
        return Vector(
            vector_1.x*number,
            vector_1.y*number,
            vector_1.z*number
        )

    @staticmethod
    def length(vector_1: 'Vector') -> float:
        """Computes the length (magnitude) of a vector.
        The length of a vector is the Euclidean norm or magnitude of the vector, which is calculated as the square root of the sum of the squares of its components.

        #### Parameters:
        - `vector_1` (`Vector`): The vector whose length is to be computed.

        #### Returns:
        `float`: The length of the input vector.

        #### Example usage:
        ```python
        vector1 = Vector(1, 2, 3)
        length = Vector.length(vector1)
        # 3.7416573867739413
        ```
        """
        return math.sqrt(vector_1.x*vector_1.x+vector_1.y*vector_1.y+vector_1.z*vector_1.z)

    @staticmethod
    def pitch(vector_1: 'Vector', angle: float) -> 'Vector':
        """Rotates a vector around the X-axis (pitch).
        This method rotates the vector around the X-axis (pitch) by the specified angle.

        #### Parameters:
        - `vector_1` (`Vector`): The vector to be rotated.
        - `angle` (float): The angle of rotation in radians.

        #### Returns:
        `Vector`: A new Vector object representing the rotated vector.

        #### Example usage:
        ```python
        vector1 = Vector(1, 2, 3)
        rotated_vector = Vector.pitch(vector1, math.pi/2)
        # Vector(X = 1.000, Y = -3.000, Z = 2.000)
        ```
        """
        return Vector(
            vector_1.x,
            vector_1.y*math.cos(angle) - vector_1.z*math.sin(angle),
            vector_1.y*math.sin(angle) + vector_1.z*math.cos(angle)
        )

    @staticmethod
    def value(vector_1: 'Vector') -> tuple:
        """Returns the rounded values of the vector's components.

        #### Parameters:
        - `vector_1` (`Vector`): The vector.

        #### Returns:
        `tuple`: A tuple containing the rounded values of the vector's components.

        #### Example usage:
        ```python
        vector1 = Vector(1.123456, 2.345678, 3.987654)
        rounded_values = Vector.value(vector1)
        # (1.1235, 2.3457, 3.9877)
        ```
        """
        roundValue = 4
        return (round(vector_1.x, roundValue), round(vector_1.y, roundValue), round(vector_1.z, roundValue))

    @staticmethod
    def reverse(vector_1: 'Vector') -> 'Vector':
        """Returns the reverse (negation) of the vector.

        #### Parameters:
        - `vector_1` (`Vector`): The vector.

        #### Returns:
        `Vector`: The reverse (negation) of the input vector.

        #### Example usage:
        ```python
        vector1 = Vector(1, 2, 3)
        reversed_vector = Vector.reverse(vector1)
        # Vector(X = -1, Y = -2, Z = -3)
        ```
        """
        return Vector(
            vector_1.x*-1,
            vector_1.y*-1,
            vector_1.z*-1
        )

    @staticmethod
    def perpendicular(vector_1: 'Vector') -> tuple:
        """Computes two vectors perpendicular to the input vector.

        #### Parameters:
        - `vector_1` (`Vector`): The input vector.

        #### Returns:
        `tuple`: A tuple containing two vectors perpendicular to the input vector.

        #### Example usage:
        ```python
        vector1 = Vector(1, 2, 3)
        perpendicular_vectors = Vector.perpendicular(vector1)
        # (Vector(X = 2, Y = -1, Z = 0), Vector(X = -3, Y = 0, Z = 1))
        ```
        """
        lokX = Vector(vector_1.y, -vector_1.x, 0)
        lokZ = Vector.cross_product(vector_1, lokX)
        if lokZ.z < 0:
            lokZ = Vector.reverse(lokZ)
        return lokX, lokZ



    @staticmethod
    def rotate_XY(vector: 'Vector', Beta: float) -> 'Vector':
        """Rotates the vector in the XY plane by the specified angle.

        #### Parameters:
        - `vector` (`Vector`): The vector to be rotated.
        - `Beta` (float): The angle of rotation in radians.

        #### Returns:
        `Vector`: A new Vector object representing the rotated vector.

        #### Example usage:
        ```python
        vector = Vector(1, 0, 0)
        rotated_vector = Vector.rotate_XY(vector, math.pi/2)
        # Vector(X = 0, Y = 1, Z = 0)
        ```
        """
        return Vector(
            math.cos(Beta)*vector.x - math.sin(Beta)*vector.y,
            math.sin(Beta)*vector.x + math.cos(Beta)*vector.y,
            vector.z
        )

    @staticmethod
    def to_matrix(vector: 'Vector') -> list:
        """Converts the vector to a list representation.

        #### Parameters:
        - `vector` (`Vector`): The vector to be converted.

        #### Returns:
        `list`: A list representation of the vector.

        #### Example usage:
        ```python
        vector = Vector(1, 2, 3)
        vector_list = Vector.to_matrix(vector)
        # [1, 2, 3]
        ```
        """
        return [vector.x, vector.y, vector.z]

    @staticmethod
    def from_matrix(vector_list: list) -> 'Vector':
        """Creates a Vector object from a list representation.

        #### Parameters:
        - `vector_list` (list): The list representing the vector.

        #### Returns:
        `Vector`: A Vector object created from the list representation.

        #### Example usage:
        ```python
        vector_list = [1, 2, 3]
        vector = Vector.from_matrix(vector_list)
        # Vector(X = 1, Y = 2, Z = 3)
        ```
        """
        return Vector(vector_list)


class Plane:
    # Plane is an infinite element in space defined by a point and a normal
    """The `Plane` class represents an infinite plane in 3D space, defined uniquely by an origin point and a normal vector, along with two other vectors lying on the plane, providing a complete basis for defining plane orientation and position."""
    def __init__(self):
        """"Initializes a new Plane instance.

        - `Origin` (Point): The origin point of the plane, which also lies on the plane.
        - `Normal` (Vector): A vector perpendicular to the plane, defining its orientation.
        - `v1` (Vector): A vector lying on the plane, typically representing the "x" direction on the plane.
        - `v2` (Vector): Another vector on the plane, perpendicular to `v1` and typically representing the "y" direction on the plane.
        """
        self.Origin = Point(0, 0, 0)
        self.Normal = Vector(x=0, y=0, z=1)
        self.vector_1 = Vector(x=1, y=0, z=0)
        self.vector_2 = Vector(x=0, y=1, z=0)

    def serialize(self) -> dict:
        """Serializes the plane's attributes into a dictionary.
        This method facilitates the conversion of the plane's properties into a format that can be easily stored or transmitted.

        #### Returns:
            dict: A dictionary containing the serialized attributes of the plane.
        
        #### Example usage:
        ```python

        ```
        """
        return {
            'Origin': self.Origin.serialize(),
            'Normal': self.Normal.serialize(),
            'vector_1': self.vector_1.serialize(),
            'vector_2': self.vector_2.serialize()
        }

    @staticmethod
    def deserialize(data: dict) -> 'Plane':
        """Creates a Plane object from a serialized data dictionary.
        This method allows for the reconstruction of a Plane instance from data previously serialized into a dictionary format, typically after storage or transmission.

        #### Parameters:
            data (dict): The dictionary containing the serialized data of a Plane object.

        #### Returns:
            Plane: A new Plane object initialized with the data from the dictionary.
        
        #### Example usage:
    	```python

        ```
        """
        plane = Plane()
        plane.Origin = Point.deserialize(data['Origin'])
        plane.Normal = Vector.deserialize(data['Normal'])
        plane.vector_1 = Vector.deserialize(data['vector_1'])
        plane.vector_2 = Vector.deserialize(data['vector_2'])

        return plane

    @classmethod
    def by_two_vectors_origin(cls, vector_1: Vector, vector_2: Vector, origin: Point) -> 'Plane':
        """Creates a Plane defined by two vectors and an origin point.
        This method establishes a plane using two vectors that lie on the plane and an origin point. The normal is calculated as the cross product of the two vectors, ensuring it is perpendicular to the plane.

        #### Parameters:
            vector_1 (Vector): The first vector on the plane.
            vector_2 (Vector): The second vector on the plane, should not be parallel to vector_1.
            origin (Point): The origin point of the plane, lying on the plane.

        #### Returns:
            Plane: A Plane instance defined by the given vectors and origin.
        
        #### Example usage:
        ```python

        ```
        """
        p1 = Plane()
        p1.Normal = Vector.normalize(Vector.cross_product(vector_1, vector_2))
        p1.Origin = origin
        p1.vector_1 = vector_1
        p1.vector_2 = vector_2
        return p1

    def __str__(self) -> str:
        """Generates a string representation of the Plane.

        #### Returns:
            str: A string describing the Plane with its origin, normal, and basis vectors.
         
        #### Example usage:
        ```python

        ```
        """

        return f"{__class__.__name__}(" + f"{self.Origin}, {self.Normal}, {self.vector_1}, {self.vector_2})"

    # TODO
    # byLineAndPoint
    # byOriginNormal
    # byThreePoints



class Text:
    """The `Text` class is designed to represent and manipulate text within a coordinate system, allowing for the creation of text objects with specific fonts, sizes, and positions. It is capable of generating and translating text into a series of geometric representations."""
    def __init__(self, text: str = None, font_family: 'str' = None, cs='CoordinateSystem', height=None) -> "Text":
        """Initializes a new Text instance
        
        - `id` (str): A unique identifier for the text object.
        - `type` (str): The class name, "Text".
        - `text` (str, optional): The text string to be represented.
        - `font_family` (str, optional): The font family of the text, defaulting to "Arial".
        - `xyz` (Vector): The origin point of the text in the coordinate system.
        - `csglobal` (CoordinateSystem): The global coordinate system applied to the text.
        - `x`, `y`, `z` (float): The position offsets for the text within its coordinate system.
        - `scale` (float, optional): The scale factor applied to the text size.
        - `height` (float, optional): The height of the text characters.
        - `bbHeight` (float, optional): The bounding box height of the text.
        - `width` (float, optional): The calculated width of the text string.
        - `character_offset` (int): The offset between characters.
        - `space` (int): The space between words.
        - `curves` (list): A list of curves representing the text geometry.
        - `points` (list): A list of points derived from the text geometry.
        - `path_list` (list): A list containing the path data for each character.
        """
        
        self.text = text
        self.font_family = font_family or "arial"
        self.xyz = cs.Origin
        self.csglobal = cs
        self.x, self.y, self.z = 0, 0, 0
        self.scale = None
        self.height = height or project.font_height
        self.bbHeight = None
        self.width = None
        self.character_offset = 150
        self.space = 850
        self.curves = []
        self.points = []
        self.path_list = self.load_path()
        self.load_o_example = self.load_o()

    def serialize(self) -> 'dict':
        """Serializes the text object's attributes into a dictionary.
        This method is useful for exporting the text object's properties, making it easier to save or transmit as JSON.

        #### Returns:
            dict: A dictionary containing the serialized attributes of the text object.
        
        #### Example usage:
        ```python

        ```
        """
        id_value = str(self.id) if not isinstance(
            self.id, (str, int, float)) else self.id
        return {
            'id': id_value,
            'type': self.type,
            'text': self.text,
            'font_family': self.font_family,
            'xyz': self.xyz,
            'csglobal': self.csglobal.serialize(),
            'x': self.x,
            'y': self.y,
            'z': self.z,
            'scale': self.scale,
            'height': self.height,
            'bbHeight': self.bbHeight,
            'width': self.width,
            'character_offset': self.character_offset,
            'space': self.space,
            'curves': [curve.serialize() for curve in self.curves],
            'points': self.points,
            'path_list': self.path_list,
        }

    def load_path(self) -> 'str':
        """Loads the glyph paths for the specified text from a JSON file.
        This method fetches the glyph paths for each character in the text attribute, using a predefined font JSON file.

        #### Returns:
            str: A string representation of the glyph paths for the text.
    
        #### Example usage:
        ```python

        ```
        """
        with open('library/text/json/Calibri.json', 'r', encoding='utf-8') as file:
            response = file.read()
        glyph_data = json.loads(response)        
        output = []
        for letter in self.text:
            if letter in glyph_data:
                output.append(glyph_data[letter]["glyph-path"])
            elif letter == " ":
                output.append("space")
        return output

    def load_o(self) -> 'str':
        """Loads the glyph paths for the specified text from a JSON file.
        This method fetches the glyph paths for each character in the text attribute, using a predefined font JSON file.

        #### Returns:
            str: A string representation of the glyph paths for the text.
        
        #### Example usage:
        ```python

        ```
        """
        with open('library/text/json/Calibri.json', 'r', encoding='utf-8') as file:
            response = file.read()
        glyph_data = json.loads(response)
        load_o = []
        letter = "o"
        if letter in glyph_data:
            load_o.append(glyph_data[letter]["glyph-path"])
        return load_o

    def write(self) -> 'List[List[PolyCurve]]':
        """Generates a list of PolyCurve objects representing the text.
        Transforms the text into geometric representations based on the specified font, scale, and position.

        #### Returns:
            List[List[PolyCurve]]: A list of lists containing PolyCurve objects representing the text geometry.
        
        #### Example usage:
        ```python

        ```
        """
        # start ref_symbol
        path = self.load_o_example
        ref_points = []
        ref_allPoints = []
        for segment in path:
            pathx = parse_path(segment)
            for segment in pathx:
                segment_type = segment.__class__.__name__
                if segment_type == 'Line':
                    ref_points.extend(
                        [(segment.start.real, segment.start.imag), (segment.end.real, segment.end.imag)])
                    ref_allPoints.extend(
                        [(segment.start.real, segment.start.imag), (segment.end.real, segment.end.imag)])
                elif segment_type == 'CubicBezier':
                    ref_points.extend(segment.sample(10))
                    ref_allPoints.extend(segment.sample(10))
                elif segment_type == 'QuadraticBezier':
                    for i in range(11):
                        t = i / 10.0
                        point = segment.point(t)
                        ref_points.append((point.real, point.imag))
                        ref_allPoints.append((point.real, point.imag))
                elif segment_type == 'Arc':
                    ref_points.extend(segment.sample(10))
                    ref_allPoints.extend(segment.sample(10))
        height = self.calculate_bounding_box(ref_allPoints)[2]
        self.scale = self.height / height
        # end ref_symbol

        output_list = []
        for letter_path in self.path_list:
            points = []
            allPoints = []
            if letter_path == "space":
                self.x += self.space + self.character_offset
                pass
            else:
                path = parse_path(letter_path)
                for segment in path:
                    segment_type = segment.__class__.__name__
                    if segment_type == 'Move':
                        if len(points) > 0:
                            points = []
                            allPoints.append("M")
                        subpath_started = True
                    elif subpath_started:
                        if segment_type == 'Line':
                            points.extend(
                                [(segment.start.real, segment.start.imag), (segment.end.real, segment.end.imag)])
                            allPoints.extend(
                                [(segment.start.real, segment.start.imag), (segment.end.real, segment.end.imag)])
                        elif segment_type == 'CubicBezier':
                            points.extend(segment.sample(10))
                            allPoints.extend(segment.sample(10))
                        elif segment_type == 'QuadraticBezier':
                            for i in range(11):
                                t = i / 10.0
                                point = segment.point(t)
                                points.append((point.real, point.imag))
                                allPoints.append((point.real, point.imag))
                        elif segment_type == 'Arc':
                            points.extend(segment.sample(10))
                            allPoints.extend(segment.sample(10))
                if points:
                    output_list.append(
                        self.convert_points_to_polyline(allPoints))
                    width = self.calculate_bounding_box(allPoints)[1]
                    self.x += width + self.character_offset

                height = self.calculate_bounding_box(allPoints)[2]
                self.bbHeight = height
        pList = []
        for ply in flatten(output_list):
            translated = self.translate(ply)
            pList.append(translated)

        for pl in pList:
            for pt in pl.points:
                self.points.append(pt)

        # print(f'Object text naar objects gestuurd.')
        return pList

    def translate(self, polyCurve: 'PolyCurve') -> 'PolyCurve':
        """Translates a PolyCurve according to the text object's global coordinate system and scale.

        #### Parameters:
            polyCurve (PolyCurve): The PolyCurve to be translated.

        #### Returns:
            PolyCurve: The translated PolyCurve.
        
        #### Example usage:
        ```python

        ```
        """
        trans = []
        for pt in polyCurve.points:
            pscale = Point.product(self.scale, pt)
            pNew = transform_point_2(pscale, self.csglobal)
            trans.append(pNew)
        return polyCurve.by_points(trans)

    def calculate_bounding_box(self, points: 'list[Point]') -> tuple:
        """Calculates the bounding box for a given set of points.

        #### Parameters:
            points (list): A list of points to calculate the bounding box for.

        #### Returns:
            tuple: A tuple containing the bounding box, its width, and its height.
       
        #### Example usage:
        ```python

        ```
        """

        points = [elem for elem in points if elem != 'M']
        ptList = [Point2D(pt[0], pt[1]) for pt in points]
        bounding_box_polyline = Rect().by_points(ptList)
        return bounding_box_polyline, bounding_box_polyline.width, bounding_box_polyline.length

    def convert_points_to_polyline(self, points: 'list[Point]') -> 'PolyCurve':
        """Converts a list of points into a PolyCurve.
        This method is used to generate a PolyCurve from a series of points, typically derived from text path data.

        #### Parameters:
            points (list): A list of points to be converted into a PolyCurve.

        #### Returns:
            PolyCurve: A PolyCurve object representing the points.
        
        #### Example usage:
        ```python

        ```
        """
        output_list = []
        sub_lists = [[]]
        tempPoints = [elem for elem in points if elem != 'M']
        x_values = [point[0] for point in tempPoints]
        y_values = [point[1] for point in tempPoints]

        xmin = min(x_values)
        ymin = min(y_values)

        for item in points:
            if item == 'M':
                sub_lists.append([])
            else:
                x = item[0] + self.x - xmin
                y = item[1] + self.y - ymin
                z = self.xyz.z
                eput = x, y, z
                sub_lists[-1].append(eput)
        output_list = [[Point(point[0], point[1], self.xyz.z)
                        for point in element] for element in sub_lists]

        polyline_list = [
            PolyCurve.by_points(
                [Point(coord.x, coord.y, self.xyz.z) for coord in pts])
            for pts in output_list
        ]
        return polyline_list



class Color(Coords):
    """Documentation: output returns [r, g, b]"""

    def __init__(self, *args, **kwargs):
        Coords.__init__(self, *args,**kwargs)
    
    red = r = Coords.x
    green = g = Coords.y
    blue = b = Coords.z
    alpha = a = Coords.w
    
    @property
    def int(self) -> int:
        """converts this color into an integer value

        Returns:
            int: the merged integer.
            this is assuming the color elements are whole integer values from 0 - 255
        """
        int_val = elem
        mult = 0x100
        for elem in self[1:]:
            int_val += elem * mult
            mult *= 0x100
        return int_val
    
    @property
    def hex(self):
        return '#%02x%02x%02x%02x' % (self.r,self.g,self.b,self.a)
        
    @staticmethod
    def axis_index(axis:str) -> int:
        """returns index of axis name.<br>
        raises a valueError when the name isn't valid.

        Args:
            axis (str): the name of the axis

        Returns:
            int: the index
        """
        return ['r', 'g', 'b', 'a'].index(axis)

    def Components(self, colorInput=None):
        """1"""
        if colorInput is None:
            return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}('green')"
        else:
            try:
                import json
                JSONfile = "library/color/colorComponents.json"
                with open(JSONfile, 'r') as file:
                    components_dict = json.load(file)
                    checkExist = components_dict.get(str(colorInput))
                    if checkExist is not None:
                        r, g, b, a = components_dict[colorInput]
                        return [r, g, b]
                    else:
                        return f"Invalid {sys._getframe(0).f_code.co_name}-color, check '{JSONfile}' for available {sys._getframe(0).f_code.co_name}-colors."
            except:
                return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"
            
    @staticmethod
    def Hex(hex:str) -> 'Color':
        """converts a heximal string to a color object.

        Args:
            hex (str): a heximal string, for example '#FF00FF88'

        Returns:
            Color: the color object
        """
        return Color(int(hex[1:3], 16),int(hex[3:5], 16), int(hex[5:7], 16),int(hex[7:9], 16)) if len(hex) > 7 else Color(int(hex[1:3], 16),int(hex[3:5], 16), int(hex[5:7], 16))

    def CMYK(self, colorInput=None):
        """NAN"""
        if colorInput is None:
            return f"Error: Example usage Color().CMYK([0.5, 0.25, 0, 0.2])"
        else:
            try:
                c, m, y, k = colorInput
                r = int((1-c) * (1-k) * 255)
                g = int((1-m) * (1-k) * 255)
                b = int((1-y) * (1-k) * 255)
                return [r, g, b]
            except:
                # add check help attribute
                return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"

    def Alpha(self, colorInput=None):
        """NAN"""
        if colorInput is None:
            return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}([255, 0, 0, 128])"
        else:
            try:
                r, g, b, a = colorInput
                return [r, g, b]
            except:
                return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"

    def Brightness(self, colorInput=None):
        """Expected value is int(0) - int(1)"""
        if colorInput is None:
            return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}([255, 0, 0, 128])"
        else:
            try:
                if colorInput >= 0 and colorInput <= 1:
                    r = g = b = int(255 * colorInput)
                    return [r, g, b]
                else:
                    return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"
            except:
                return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"
            
    @staticmethod
    def RGB(self, colorInput=None):
        """NAN"""
        if colorInput is None:
            return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}([255, 0, 0])"
        else:
            try:
                r, g, b = colorInput
                return [r, g, b]
            except:
                return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"

    def HSV(self, colorInput=None):
        """NAN"""
        if colorInput is None:
            return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}()"
        else:
            try:
                h, s, v = colorInput
                h /= 60.0
                c = v * s
                x = c * (1 - abs(h % 2 - 1))
                m = v - c
                if 0 <= h < 1:
                    r, g, b = c, x, 0
                elif 1 <= h < 2:
                    r, g, b = x, c, 0
                elif 2 <= h < 3:
                    r, g, b = 0, c, x
                elif 3 <= h < 4:
                    r, g, b = 0, x, c
                elif 4 <= h < 5:
                    r, g, b = x, 0, c
                else:
                    r, g, b = c, 0, x
                return [int((r + m) * 255), int((g + m) * 255), int((b + m) * 255)]
            except:
                return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"

    def HSL(self, colorInput=None):
        """NAN"""
        if colorInput is None:
            return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}()"
        else:
            try:
                h, s, l = colorInput
                c = (1 - abs(2 * l - 1)) * s
                x = c * (1 - abs(h / 60 % 2 - 1))
                m = l - c / 2
                if h < 60:
                    r, g, b = c, x, 0
                elif h < 120:
                    r, g, b = x, c, 0
                elif h < 180:
                    r, g, b = 0, c, x
                elif h < 240:
                    r, g, b = 0, x, c
                elif h < 300:
                    r, g, b = x, 0, c
                else:
                    r, g, b = c, 0, x
                r, g, b = int((r + m) * 255), int((g + m)
                                                  * 255), int((b + m) * 255)
                return [r, g, b]
            except:
                return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"

    def RAL(self, colorInput=None):
        """NAN"""
        if colorInput is None:
            return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}(1000)"
        else:
            try:
                # validate if value is correct/found
                import json
                JSONfile = "library/color/colorRAL.json"
                with open(JSONfile, 'r') as file:
                    ral_dict = json.load(file)
                    checkExist = ral_dict.get(str(colorInput))
                    if checkExist is not None:
                        r, g, b = ral_dict[str(colorInput)]["rgb"].split("-")
                        return [int(r), int(g), int(b), 100]
                    else:
                        return f"Invalid {sys._getframe(0).f_code.co_name}-color, check '{JSONfile}' for available {sys._getframe(0).f_code.co_name}-colors."
            except:
                return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"

    def Pantone(self, colorInput=None):
        """NAN"""
        if colorInput is None:
            return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}()"
        else:
            try:
                import json
                JSONfile = "library/color/colorPantone.json"
                with open(JSONfile, 'r') as file:
                    pantone_dict = json.load(file)
                    checkExist = pantone_dict.get(str(colorInput))
                    if checkExist is not None:
                        PantoneHex = pantone_dict[str(colorInput)]['hex']
                        return Color().Hex(PantoneHex)
                    else:
                        return f"Invalid {sys._getframe(0).f_code.co_name}-color, check '{JSONfile}' for available {sys._getframe(0).f_code.co_name}-colors."
            except:
                return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"

    def LRV(self, colorInput=None):
        """NAN"""
        if colorInput is None:
            return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}()"
        else:
            try:
                b = (colorInput - 0.2126 * 255 - 0.7152 * 255) / 0.0722
                b = int(max(0, min(255, b)))
                return [255, 255, b]
            except:
                return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"


    def __str__(self, colorInput=None):
        colorattributes = ["Components", "Hex", "rgba_to_hex", "hex_to_rgba", "CMYK",
                           "Alpha", "Brightness", "RGB", "HSV", "HSL", "RAL", "Pantone", "LRV"]
        if colorInput is None:
            header = "Available attributes: \n"
            footer = "\nColor().red | Color().green | Color().blue"
            return header + '\n'.join([f"Color().{func}()" for func in colorattributes]) + footer
        return f"Color().{colorInput}"

    def Info(self, colorInput=None):
        pass

Color.red = Color(255, 0, 0)
Color.green = Color(0, 255, 0)
Color.blue = Color(0, 0, 255)


class Interval:
    """The `Interval` class is designed to represent a mathematical interval, providing a start and end value along with functionalities to handle intervals more comprehensively in various applications."""
    def __init__(self, start: float, end: float):
        """Initializes a new Interval instance.
        
        - `start` (float): The starting value of the interval.
        - `end` (float): The ending value of the interval.
        - `interval` (list, optional): A list that may represent subdivided intervals or specific points within the start and end bounds, depending on the context or method of subdivision.

        """
        self.start = start
        self.end = end
        self.interval = None

    def serialize(self) -> dict:
        """Serializes the interval's attributes into a dictionary.

        This method facilitates converting the interval's properties into a format that can be easily stored or transmitted.

        #### Returns:
            dict: A dictionary containing the serialized attributes of the interval.
        
        #### Example usage:
    	```python

        ```
        """

        return {
            'start': self.start,
            'end': self.end,
            'interval': self.interval
        }

    @staticmethod
    def deserialize(data: dict) -> 'Interval':
        """Reconstructs an Interval object from serialized data contained in a dictionary.

        #### Parameters:
            data (dict): The dictionary containing serialized data of an Interval object.

        #### Returns:
            Interval: A new Interval object initialized with the data from the dictionary.
        
        #### Example usage:
    	```python

        ```
        """

        start = data.get('start')
        end = data.get('end')
        interval = Interval(start, end)
        interval.interval = data.get('interval')
        return interval

    @classmethod
    def by_start_end_count(self, start: float, end: float, count: int) -> 'Interval':
        """Generates a list of equidistant points within the interval.

        This method divides the interval between the start and end values into (count - 1) segments, returning an Interval object containing these points.

        #### Parameters:
            start (float): The starting value of the interval.
            end (float): The ending value of the interval.
            count (int): The total number of points to generate, including the start and end values.

        #### Returns:
            Interval: An Interval instance with its `interval` attribute populated with the generated points.
        
        #### Example usage:
    	```python

        ```
        """
        intval = []
        numb = start
        delta = end-start
        for i in range(count):
            intval.append(numb)
            numb = numb + (delta / (count - 1))
        self.interval = intval
        return self

    def __str__(self) -> str:
        """Generates a string representation of the Interval.

        #### Returns:
            str: A string representation of the Interval, primarily indicating its class name.
        
        #### Example usage:
    	```python

        ```
        """
        return f"{__class__.__name__}"

class Shape:
	"""this class defines functions and properties for geometric shapes."""
	@property
	def statical_moment(self) -> float:
		return self.area * self.centroid.y

class Rect(Serializable, Shape):
    """Represents a two-dimensional bounding box."""
    def __init__(self, *args, **kwargs):
        """@
        #### Example usage:
        ```python
        rect = Rect(3, 4) # x 3, width 4
        rect2 = Rect(z=10) # x 0, y 0, z 10, width 0, length 0, height 0
        rect3 = Rect(Vector(y=8), Vector(x = 4)) # x 0, y 8, width 4, length 0
        ```
        """
        
        
        #first half = for position
        half:int = len(args) // 2
        self.p0 = Point(*args[0:half])
        #second half for size
        self.size = Vector(*args[half:])
        
        for kwarg in kwargs.items():
            try:
                offset = self.p0.set_axis(kwarg[0], kwarg[1])
                if offset != None:
                    self.size.change_axis_count(offset)
            except ValueError:
                axis_index = Rect.size_axis_index(kwarg[0])
                offset = self.size.set_axis(axis_index, kwarg[1])
                if offset != None:
                    self.p0.change_axis_count(offset)
            
        Serializable.__init__(self)
        
    def change_axis_count(self,axis_count: int):
        self.p0.change_axis_count(axis_count)
        self.size.change_axis_count(axis_count)
    
    @staticmethod
    def size_axis_index(axis)->int:
        return ["width", "length", "height"].index(axis)
    
    @property
    def width(self):
        return self.size.x
    @width.setter
    def width(self, value):
        self.size.x = value
        
    @property
    def length(self):
        return self.size.y
    @length.setter
    def length(self, value):
        self.size.y = value

    @property
    def height(self):
        return self.size.z
    @height.setter
    def height(self, value):
        self.size.z = value
    
    @property
    def center(self):
        return self.p0 + self.size * 0.5
    @center.setter
    def center(self, value):
        self.p0 += self.value - (self.size * 0.5)
    centroid = center

    @property
    def x(self):
        return self.p0.x
    @x.setter
    def x(self, value):
        self.p0.x = value
    @property
    def y(self):
        return self.p0.y
    @y.setter
    def y(self, value):
        self.p0.y = value
    @property
    def z(self):
        return self.p0.z
    @z.setter
    def z(self, value):
        self.p0.z = value
        
    def area(self):
        return self.size.volume()
    @property
    def p1(self):
        return self.p0 + self.size
    
    def __str__(self):
        return __class__.__name__ + '(p0=' + str(self.p0)+',size=' + str(self.size) + ')'
    


    @staticmethod
    def by_points(points: list[Point]) -> 'Rect':
        """Constructs a bounding box based on a list of points.

        Calculates the minimum and maximum values from the points to define the corners of the bounding box.

        #### Parameters:
        - `points` (list[Point]): A list of Point objects to calculate the bounding box from.

        #### Returns:
        `Rect`: The bounding box instance with updated corners based on the provided points.

        #### Example usage:
        ```python
        points = [Point(0, 0, 0), Point(2, 2, 0), Point(2, 0, 0), Point(0, 2, 0)]
        bbox = Rect().by_points(points)
        # Rect with corners at (0, 0, 0), (2, 2, 0), (2, 0, 0), and (0, 2, 0)
        ```
        """
        
        axis_count = len(points[0])
        if axis_count == 0: raise ValueError("please provide points")
        
        #copy
        p0 = Point(points[0])
        p1 = Point(points[0])
        
        #it's faster to not skip the first point than to check if it's the first point or revert to an index-based loop
        for p in points:
            for axis in range(axis_count):
                p0[axis] = min(p0[axis], p[axis])
                p1[axis] = max(p1[axis], p[axis])
        return Rect(p0, p1 - p0)
    
    def expanded(self, border_size: float) -> 'Rect':
        return Rect(self.p0 - border_size, self.size + border_size * 2)
    
    @staticmethod
    def centered_at_origin(size: Vector) -> 'Rect':
        """Constructs a rect with specified dimensions, centered at the origin.

        #### Parameters:
        - `size` (Vector): The size of the bounding box.

        #### Returns:
        `Rect`: The bounding box instance with dimensions centered at the origin.

        #### Example usage:
        ```python
        bbox = Rect().centered_at_origin(length=100, width=50)
        # Rect centered at origin with specified length and width
        ```
        """
        
        return Rect(size * -0.5, size)
    
    @staticmethod
    def by_size(size:Vector)->'Rect':
        """Constructs a rect with specified dimensions, with its pos0 at the origin.

        #### Parameters:
        - `size` (Vector): The size of the rectangle

        #### Returns:
        `Rect`: The rect instance with dimensions centered at the origin.

        #### Example usage:
        ```python
        rect = Rect().by_size(length=100, width=50)
        # Rect(x=0, y=0, width = 100, length = 100)
        ```
        """
        return Rect(Vector([0] * len(size)), size)
    
    def collides(self, other:'Rect')->bool:
        """checks if two rectangles collide with eachother. <br>
        when they touch eachother exactly (f.e. a Rect with position [0] and size [1] and a rect with position [1] and size [1]), the function will return false.

        Args:
            other (Rect): the rectangle which may collide with this rectangle

        Returns:
            bool: true if the two rectangles overlap
        """
        for axis in range(len(self.p0)):
            if self.p0[axis] + self.size[axis] <= other.p0[axis] or other.p0[axis] + other.size[axis] <= self.p0[axis]:
                return False
        return True
    
    def contains(self, other:'Rect')->bool:
        for axis in range(len(self.p0)):
            if other.p0[axis] < self.p0[axis] or other.p0[axis] + other.size[axis] > self.p0[axis] + self.size[axis]:
                return False
        return True
    
    def substractFrom(self, other:'Rect')->list['Rect']:
        """cut the 'other' rectangle in pieces by substracting this rectangle from it

        Args:
            other (Rect): the rectangle to substract this rectangle from

        Returns:
            list[Rect]: a list of up to 4 rectangles for 2d (if the rect is in the center). CAUTION: THEY OVERLAP!
        """
        pieces:list[Rect] = []
        to_clone = other
        #check each axis
        for axis in range(len(self.p0)):
            self_p1 = self.p0[axis] + self.size[axis]
            other_p1 = other.p0[axis] + other.size[axis]
            if self_p1 < other_p1:
                diff = other_p1 - self_p1
                
                piece:Rect = copy.deepcopy(to_clone)
                
                piece.p0[axis] = self_p1
                
                piece.size[axis] = diff
                pieces.append(piece)
                #also crop other.
                #to_clone.size[axis] -= diff
            self_p0 = self.p0[axis]
            other_p0 = other.p0[axis]
            if self_p0 > other_p0:
                diff = self_p0 - other_p0
                piece:Rect = copy.deepcopy(to_clone)
                piece.size[axis] = diff
                pieces.append(piece)
                #to_clone.p0[axis] = self_p0
                #to_clone.size[axis] -= diff
        return pieces
    
    @staticmethod
    def outer(children: list['Rect']) -> 'Rect':
        """creates a rectangle containing child rectangles.

        Args:
            children (list[&#39;Rect&#39;]): the children to contain in the rectangle

        Returns:
            Rect: the bounds
        """
        p0 = children[0].p0
        p1 = children[0].p1
        for i in range(1,len(children)):
            child = children[i]
            for axis_index in range(len(p0)):
                p0[axis_index] = min(child.p0[axis_index], p0[axis_index])
                p1[axis_index] = max(child.p0[axis_index] + child.size[axis_index], p1[axis_index])
        return Rect(p0, p1 - p0)
                
    
    def get_corner(self, corner_index: int) -> Point:
        """

        Args:
            corner_index (int): corners are ordered like 0 -> 000, 1 -> 001, 2 -> 010, 011, 100 etc.
            where 0 = the minimum and 1 = the maximum

        Returns:
            Point: a corner
        """
        corner : Point = Point()
        for axis in range(len(self)):
            corner.append(self.p0[axis] + self.size[axis] if corner_index & 1 << axis else self.p0[axis])
        return corner
        

    def corners(self) -> 'list[Point]':
        """Calculates the corners of the bounding.

        #### Returns:
        `list[Point]`: A list of Point objects representing the corners of the bounding box.

        #### Example usage:
        ```python
        bbox3d = Rect(Point(1, 1, 1), Vector(2, 2, 2))
        corners = bbox3d.corners()
        Returns a list of eight points representing the corners of the bounding box
        ```
        """
        corners:list[Point] = []
        axis_count = len(self.p0)
        for corner_index in range(2 << axis_count):
            corners.append(self.get_corner(corner_index))
        return corners
class PointList(Vector[Vector]):
    """Represents a collection of points in space as a point cloud."""
    
    def __init__(self, points: list) -> 'PointList':
        """Initializes a PointList object with a list of points.

        #### Parameters:
        - `points` (list): An optional list of points to initialize the point cloud. Each point can be an instance of a Point class or a tuple/list of coordinates.

        Initializes the PointList's attributes and sets up the list of points based on the input provided. The ID is generated to uniquely identify the point cloud.
        """
        super().__init__(points)
        
    
    #just execute the operator for all list members
    def operate_2(self, op:operator, other):
        return self.__class__([self[index].operate_2(op, other) for index in range(len(self))])
    
    def ioperate_2(self, op:operator, other):
        for index in range(len(self)):
            self[index].ioperate_2(op, other)
        return self

    def operate_1(self, op:operator):
        return self.__class__([self[index].operate_1(op) for index in range(len(self))])
    
    @property
    def bounds(self) -> 'Rect':
        return Rect.by_points(self)

#alternative naming
PointCloud = PointList

class Line(Serializable):
    def __init__(self, start: Point, end: Point) -> 'Line':
        """Initializes a Line object with the specified start and end points.

        - `start` (Point): The starting point of the line segment.
        - `end` (Point): The ending point of the line segment.
        """
        #copy
        self.start = Point(start)
        self.end = Point(end)
        
    @property
    def mid(self) -> 'Point':
        """Computes the midpoint of the Line object.

        #### Returns:
        `Point`: The midpoint of the Line object.

        #### Example usage:
        ```python

        ```          
        """
        return (self.start + self.end) / 2
    @property
    def angle(self) -> float:
        return (self.end - self.start).angle
    @staticmethod
    def by_startpoint_direction_length(start: 'Point', direction: 'Vector', length: 'float') -> 'Line':
        """Creates a line segment starting from a given point in the direction of a given vector with a specified length.

        #### Parameters:
        - `start` (Point): The starting point of the line segment.
        - `direction` (Vector): The direction vector of the line segment.
        - `length` (float): The length of the line segment.

        #### Returns:
        `Line`: A new Line object representing the line segment.

        #### Example usage:
        ```python

        ```          
        """
        norm = math.sqrt(direction.x ** 2 + direction.y **
                         2 + direction.z ** 2)
        normalized_direction = Vector(
            direction.x / norm, direction.y / norm, direction.z / norm)

        end_x = start.x + normalized_direction.x * length
        end_y = start.y + normalized_direction.y * length
        end_z = start.z + normalized_direction.z * length
        end_point = Point(end_x, end_y, end_z)

        return Line(start, end_point)

    def translate(self, direction: 'Vector') -> 'Line':
        """Translates the Line object by a given direction vector.

        #### Parameters:
        - `direction` (Vector): The direction vector by which the line segment will be translated.

        #### Returns:
        `Line`: The translated Line object.

        #### Example usage:
        ```python

        ```          
        """
        self.start += direction
        self.end +=direction
        return self

    @staticmethod
    def transform(line: 'Line', cs_new: 'CoordinateSystem') -> 'Line':
        """Transforms the Line object to a new coordinate system.

        #### Parameters:
        - `line` (Line): The Line object to be transformed.
        - `cs_new` (CoordinateSystem): The new coordinate system to which the Line object will be transformed.

        #### Returns:
        `Line`: The transformed Line object.

        #### Example usage:
        ```python

        ```          
        """
        ln = Line(start=line.start, end=line.end)
        ln.start = transform_point_2(ln.start, cs_new)
        ln.end = transform_point_2(ln.end, cs_new)
        return ln

    def offset(line: 'Line', vector: 'Vector') -> 'Line':
        """Offsets the Line object by a given vector.

        #### Parameters:
        - `line` (Line): The Line object to be offset.
        - `vector` (Vector): The vector by which the Line object will be offset.

        #### Returns:
        `Line`: The offset Line object.

        #### Example usage:
        ```python

        ```          
        """
        start = Point(line.start.x + vector.x, line.start.y +
                      vector.y, line.start.z + vector.z)
        end = Point(line.end.x + vector.x, line.end.y +
                    vector.y, line.end.z + vector.z)
        return Line(start=start, end=end)

    # @classmethod
    def point_at_parameter(self, interval: 'float' = None) -> 'Point':
        """Computes the point on the Line object at a specified parameter value.

        #### Parameters:
        - `interval` (float): The parameter value determining the point on the line. Default is None, which corresponds to the midpoint.

        #### Returns:
        `Point`: The point on the Line object corresponding to the specified parameter value.

        #### Example usage:
        ```python

        ```          
        """
        if interval == None:
            interval = 0.0
        x1, y1, z1 = self.start.x, self.start.y, self.start.z
        x2, y2, z2 = self.end.x, self.end.y, self.end.z
        if float(interval) == 0.0:
            return self.start
        else:
            devBy = 1/interval
            return Point((x1 + x2) / devBy, (y1 + y2) / devBy, (z1 + z2) / devBy)

    def intersects(self, other: 'Line') -> bool:
        """checks if two lines intersect with eachother.

        Args:
            other (Line): the line which may intersect with this rectangle

        Returns:
            bool: true if the lines cross eachother.
        """
        #ax + b = cx + d
        #ax = cx + d - b
        #ax - cx = d - b
        #(a - c)x = d - b
        #x = (d - b) / (a - c)
        
        #calculate a and c
        
        diff_self = self.end - self.start
        diff_other = other.end - other.start
        #a
        slope_self = math.inf if diff_self.x == 0 else diff_self.y / diff_self.x
        
        #c
        slope_other = math.inf if diff_other.x == 0 else diff_other.y / diff_other.x
        #handle edge cases
        #colinear
        if(slope_self == slope_other) :
            return False

        #b
        self_y_at_0 = self.start.y - self.start.x * slope_self
        
        #check if one slope is infinite (both infinite is handled by colinear)
        if other.start.x == other.end.x:
            self_y_at_line = self_y_at_0 + slope_self * other.start.x
            return other.start.y < self_y_at_line < other.end.y

        #d
        other_y_at_0 = other.start.y - other.start.x * slope_other

        if self.start.x == self.end.x:
            other_y_at_line = other_y_at_0 + slope_other * self.start.x
            return self.start.y < other_y_at_line < self.end.y
        
        intersection_x = (other_y_at_0 - self_y_at_0) / (slope_self - slope_other)
        
        return self.start.x < intersection_x < self.end.x

    def split(self, points: 'Union[Point, list[Point]]') -> 'list[Line]':
        """Splits the Line object at the specified point(s).

        #### Parameters:
        - `points` (Point or List[Point]): The point(s) at which the Line object will be split.

        #### Returns:
        `List[Line]`: A list of Line objects resulting from the split operation.

        #### Example usage:
        ```python

        ```          
        """
        lines = []
        if isinstance(points, list):
            points.extend([self.start, self.end])
            sorted_points = sorted(
                points, key=lambda p: p.distance(p, self.end))
            lines = create_lines(sorted_points)
            return lines
        elif isinstance(points, Point):
            point = points
            lines.append(Line(start=self.start, end=point))
            lines.append(Line(start=point, end=self.end))
            return lines
        
    @property
    def length(self) -> 'float':
        """Computes the length of the Line object.

        #### Returns:
        `float`: The length of the Line object.

        #### Example usage:
        ```python

        ```          
        """
        return (self.end - self.start).magnitude

    def __str__(self) -> 'str':
        """Returns a string representation of the Line object.

        #### Returns:
        `str`: A string representation of the Line object.

        #### Example usage:
        ```python

        ```          
        """
        return f"{__class__.__name__}(" + f"{self.start}, {self.end})"


def create_lines(points: 'list[Point]') -> 'list[Line]':
    """Creates a list of Line objects from a list of points.
    This function generates line segments connecting consecutive points in the list.

    #### Parameters:
    - `points` (List[Point]): A list of points.

    #### Returns:
    `List[Line]`: A list of Line objects representing the line segments connecting the points.

    #### Example usage:
    ```python

    ```      
    """
    lines = []
    for i in range(len(points)-1):
        line = Line(points[i], points[i+1])
        lines.append(line)
    return lines


class PolyCurve(Serializable, list[Line], Shape):
    """Stores lines, which could possibly be arcs"""
    def __init__(self, *args):
        """Initializes a PolyCurve object, which is unclosed by default.
        

        """
        
        
        #self.points:list[Point] = to_array(*args)

        #self.approximateLength = None
        #self.graphicsStyleId = None
        #self.isCyclic = None
        #self.isElementGeometry = None
        #self.isReadOnly = None
        #self.length = self.length()
        #self.period = None
        #self.reference = None
        #self.visibility = None
        super().__init__(to_array(*args))
    
    @property
    def closed(self) -> 'bool':
        return self[0].start == self[-1].end
    @closed.setter
    def closed(self, value : bool):
        if value != self.closed:
            if value:
                #just fill the gap using a straight line
                self.append(Line(self[-1].end, self[0].start))
            else:
                del self[-1]    
    
    @property
    def area(self):
        """Calculates the area of the 2d PolyCurve.

        Returns:
            float: The area of the 2d poly curve.
        
        we are assuming the PolyCurve is wound counter-clockwise and is closed.
        """
        if not self.closed:
            raise ValueError("the polycurve needs to be closed in order to calculate its area")
        area:float = 0
        for line in self:
            if isinstance(line, Arc):
                origin = line.origin
                area += (line.start.x - line.end.x) * origin.y
                #now that we added the 'rectangle', let's add the sine wave
                
                #the arc is part of a circle. the circle can be represented as two opposite cosine waves, with the circle center being at 0, 0.
                #to calculate the area, we'll be using the integral of the cosine wave, which is the sine wave.
                radius = (line.origin - line.start).magnitude
                
                #area is negative if y < 0
                #area is measured from the -x side here, so at -radius, area == 0 and at +radius, area == circle_area
                #https://www.desmos.com/calculator/ykynwhoue6
                get_area = lambda pos : math.copysign((math.sin(((pos.x - origin.x) / radius) * (math.pi / 2)) + 1) * radius, pos.y - origin.y)
                start_area = get_area(line.start)
                end_area = get_area(line.end)
                
                integral_area = start_area - end_area
                if integral_area < 0:
                    circle_area = (radius * radius) * math.pi
                    integral_area += circle_area
                area += integral_area
            else:
                #check direction of line
                #start - end, for counterclockwiseness
                #when start.x < end.x, this is a bottom line. we'll substract this from the area.
                dx = line.start.x - line.end.x
                averagey = (line.start.y + line.end.y) / 2
                area += dx * averagey
        return area
    
    @property
    def length(self) -> 'float':
        """Calculates the total length of the PolyCurve.

        #### Returns:
        `float`: The total length of the PolyCurve.

        #### Example usage:
        ```python

        ```        
        """
        lst = []
        for line in self.curves:
            lst.append(line.length)

        return sum(i.length for i in self.curves)

    def scale(self, scale_factor: 'float') -> 'PolyCurve':
        """Scales the PolyCurve object by the given factor.

        #### Parameters:
        - `scale_factor`: The scaling factor.

        #### Returns:
        `PolyCurve`: Scaled PolyCurve object.

        #### Example usage:
        ```python

        ```        
        """
        crvs = []
        for i in self.curves:
            if i.__class__.__name__ == "Arc":
                arcie = Arc(Point.product(scale_factor, i.start),
                            Point.product(scale_factor, i.end))
                arcie.mid = Point.product(scale_factor, i.mid)
                crvs.append(arcie)
            elif i.__class__.__name__ == "Line":
                crvs.append(Line(Point.product(scale_factor, i.start),
                            Point.product(scale_factor, i.end)))
            else:
                print("Curvetype not found")
        crv = PolyCurve.by_joined_curves(crvs)
        return crv
    
    #TODO finish function
    @property
    def centroid(self) -> 'Point':
        """Calculates the centroid of the PolyCurve. in 2D

        #### Returns:
        `Point`: The centroid point of the PolyCurve.

        #### Example usage:
        ```python

        ```        
        """
        poly = Polygon.by_joined_curves(self)
        total_area = poly.area
        weighted_centroid = poly.centroid * total_area
        
        #now check if any lines are arcs. in that case, we need to adjust the centroid a bit
        
        for i in range(len(self)):
            current_line = self[i]
            if isinstance(current_line, Arc):
                #https://pickedshares.com/en/center-of-area-of-%E2%80%8B%E2%80%8Bgeometric-figures/#circlesegment
                #calculate the centroid
                arc_centroid = current_line.centroid
                arc_area = current_line.area
                
                total_area += arc_area
                #now that we have the centroid, we also need to calculate the area, and multiply the centroid by the area to give it a 'weight'
                weighted_centroid += arc_centroid * arc_area
        
        return weighted_centroid / total_area
    
    #def area(self) -> 'float':  # shoelace formula
    #    """Calculates the area enclosed by the PolyCurve using the shoelace formula.
#
    #    #### Returns:
    #    `float`: The area enclosed by the PolyCurve.
#
    #    #### Example usage:
    #    ```python
#
    #    ```        
    #    """
    #    if self.closed:
    #        if len(self.points) < 3:
    #            return "Polygon has less than 3 points!"
#
    #        num_points = len(self.points)
    #        S1, S2 = 0, 0
#
    #        for i in range(num_points):
    #            x, y = self.points[i].x, self.points[i].y
    #            if i == num_points - 1:
    #                x_next, y_next = self.points[0].x, self.points[0].y
    #            else:
    #                x_next, y_next = self.points[i + 1].x, self.points[i + 1].y
#
    #            S1 += x * y_next
    #            S2 += y * x_next
#
    #        area = 0.5 * abs(S1 - S2)
    #        return area
    #    else:
    #        print("Polycurve is not closed, no area!")
    #        return None
        


    @classmethod
    def by_joined_curves(self, curvelst: 'list[Line]') -> 'PolyCurve':
        """Creates a PolyCurve from a list of joined Line curves.

        #### Parameters:
        - `curvelst` (list[Line]): The list of Line curves to join.

        #### Returns:
        `PolyCurve`: The created PolyCurve object.

        #### Example usage:
        ```python

        ```        
        """
        for curve in curvelst:
            if curve.length == 0:
                curvelst.remove(curve)
                # print("Error: Curve length cannot be zero.")
                # sys.exit()

        plycrv = PolyCurve()
        for index, curve in enumerate(curvelst):
            if index == 0:
                plycrv.points.append(curve.start)
                plycrv.points.append(curve.end)
            else:
                plycrv.points.append(curve.end)

        return plycrv

    @classmethod
    def by_points(self, points: 'list[Point]') -> Self:
        """Creates a PolyCurve from a list of points.

        #### Parameters:
        - `points` (list[Point]): The list of points defining the PolyCurve.

        #### Returns:
        `PolyCurve`: The created PolyCurve object.

        #### Example usage:
        ```python

        ```        
        """
        seen = set()
        unique_points = []

        for point in points:
            if point in seen:
                points.remove(point)
                print("Error: Polycurve cannot have multiple identical points.")
                sys.exit()

            seen.add(point)
            unique_points.append(point)

        plycrv = PolyCurve()
        for index, point in enumerate(points):
            plycrv.points.append(point)
            if(index == len(points) - 1):
                firstpoint = points[0]
                plycrv.curves.append(Line(start=point, end=firstpoint))
                
            else:
                
                nextpoint = points[index+1]
                plycrv.curves.append(Line(start=point, end=nextpoint))

        if project.closed:
            if plycrv.points[0].value == plycrv.points[-1].value:
                plycrv.isClosed = True
            else:
                plycrv.isClosed = True
                plycrv.points.append(points[0])

        elif project.closed == False:
            if plycrv.points[0].value == plycrv.points[-1].value:
                plycrv.isClosed = True
            else:
                plycrv.isClosed = False
                plycrv.points.append(points[0])

        return plycrv

    @classmethod
    def unclosed_by_points(cls, points: 'list[Point]') -> 'PolyCurve':
        """Creates an unclosed PolyCurve from a list of points.

        #### Parameters:
        - `points` (list[Point]): The list of points defining the PolyCurve.

        #### Returns:
        `PolyCurve`: The created unclosed PolyCurve object.

        #### Example usage:
        ```python

        ```        
        """
        plycrv = PolyCurve()
        for index, point in enumerate(points):
            plycrv.points.append(point)
            try:
                nextpoint = points[index + 1]
                plycrv.curves.append(Line(start=point, end=nextpoint))
            except:
                pass
        return plycrv
    


    @staticmethod
    # Create segmented polycurve. Arcs, elips will be translated to straight lines
    def segment(self, count: 'int') -> 'PolyCurve':
        """Segments the PolyCurve into straight lines.

        #### Parameters:
        - `count` (int): The number of segments.

        #### Returns:
        `PolyCurve`: The segmented PolyCurve object.

        #### Example usage:
        ```python

        ```        
        """
        crvs = []  # add isClosed
        for i in self.curves:
            if i.__class__.__name__ == "Arc":
                crvs.append(Arc.segmented_arc(i, count))
            elif i.__class__.__name__ == "Line":
                crvs.append(i)
        crv = flatten(crvs)
        pc = PolyCurve.by_joined_curves(crv)
        return pc

    @staticmethod
    def by_polycurve_2D(PolyCurve2D) -> 'PolyCurve':
        """Creates a 3D PolyCurve from a 2D PolyCurve.

        #### Parameters:
        - `PolyCurve2D`: The 2D PolyCurve object.

        #### Returns:
        `PolyCurve`: The created 3D PolyCurve object.

        #### Example usage:
        ```python

        ```        
        """
        plycrv = PolyCurve()
        curves = []
        for i in PolyCurve2D.curves:
            if i.__class__.__name__ == "Arc2D":
                curves.append(Arc(Point(i.start.x, i.start.y, 0), Point(
                    i.mid.x, i.mid.y, 0), Point(i.end.x, i.end.y, 0)))
            elif i.__class__.__name__ == "Line2D":
                curves.append(Line(Point(i.start.x, i.start.y, 0),
                              Point(i.end.x, i.end.y, 0)))
            else:
                print("Curvetype not found")
        pnts = []
        for i in curves:
            pnts.append(i.start)
        pnts.append(curves[0].start)
        plycrv.points = pnts
        plycrv.curves = curves
        return plycrv

    # make sure that the lines start/stop already on the edge of the polycurve
    def split(self, line: 'Line', returnlines=None) -> 'list[PolyCurve]':
        """Splits the PolyCurve by a line and returns the split parts.

        #### Parameters:
        - `line` (Line): The line to split the PolyCurve.
        - `returnlines` (bool, optional): Whether to return the split PolyCurves as objects or add them to the project. Defaults to None.

        #### Returns:
        `list[PolyCurve]`: If `returnlines` is True, returns a list of split PolyCurves. Otherwise, None.

        #### Example usage:
        ```python

        ```        
        """

        allLines = self.curves.copy()

        insect = get_intersect_polycurve_lines(
            self, line, split=True, stretch=False)
        for pt in insect["IntersectGridPoints"]:
            for index, line in enumerate(allLines):
                if is_point_on_line_segment(pt, line) == True:
                    cuttedLines = line.split([pt])
                    allLines = replace_at_index(allLines, index, cuttedLines)

        if len(insect["IntersectGridPoints"]) == 2:
            part1 = []
            part2 = []

            for j in allLines:
                # part1
                if j.start == insect["IntersectGridPoints"][1]:
                    part1LineEnd = j.end
                    part1.append(j.start)
                if j.end == insect["IntersectGridPoints"][0]:
                    part1LineStart = j.start
                    part1.append(j.end)
                # part2
                if j.start == insect["IntersectGridPoints"][0]:
                    part2LineEnd = j.end
                    part2.append(j.start)
                if j.end == insect["IntersectGridPoints"][1]:
                    part2LineStart = j.start
                    part2.append(j.end)

            s2 = self.points.index(part1LineStart)
            s1 = self.points.index(part1LineEnd)
            completelist = list(range(len(self.points)))
            partlist1 = flatten(completelist[s2:s1+1])
            partlist2 = flatten([completelist[s1+1:]] + [completelist[:s2]])

            SplittedPolyCurves = []
            # part1
            if part1LineStart != None and part1LineEnd != None:
                for i, index in enumerate(partlist1):
                    pts = self.points[index]
                    part1.insert(i+1, pts)
                if returnlines:
                    SplittedPolyCurves.append(PolyCurve.by_points(part1))
                else:
                    project.objects.append(PolyCurve.by_points(part1))

            # part2 -> BUGG?
            if part2LineStart != None and part2LineEnd != None:
                for index in partlist2:
                    pts = self.points[index]
                    part2.insert(index, pts)
                if returnlines:
                    SplittedPolyCurves.append(PolyCurve.by_points(part2))
                else:
                    project.objects.append(PolyCurve.by_points(part2))

            if returnlines:  # return lines while using multi_split
                return SplittedPolyCurves

        else:
            print(
                f"Must need 2 points to split PolyCurve into PolyCurves, got now {len(insect['IntersectGridPoints'])} points.")
     
    def multi_split(self, lines: 'Line') -> 'list[PolyCurve]':  # SLOW, MUST INCREASE SPEAD
        """Splits the PolyCurve by multiple lines.
        This method splits the PolyCurve by multiple lines and adds the resulting PolyCurves to the project.

        #### Parameters:
        - `lines` (List[Line]): The list of lines to split the PolyCurve.

        #### Returns:
        `List[PolyCurve]`: The list of split PolyCurves.

        #### Example usage:
        ```python

        ```        
        """
        lines = flatten(lines)
        new_polygons = []
        for index, line in enumerate(lines):
            if index == 0:
                n_p = self.split(line, returnlines=True)
                if n_p != None:
                    for nxp in n_p:
                        if nxp != None:
                            new_polygons.append(n_p)
            else:
                for new_poly in flatten(new_polygons):
                    n_p = new_poly.split(line, returnlines=True)
                    if n_p != None:
                        for nxp in n_p:
                            if nxp != None:
                                new_polygons.append(n_p)
        project.objects.append(flatten(new_polygons))
        return flatten(new_polygons)

    def translate(self, offset: 'Vector') -> 'PolyCurve':
        """Translates the PolyCurve by a 3D vector.

        #### Parameters:
        - `vector_3d` (Vector): The 3D vector by which to translate the PolyCurve.

        #### Returns:
        `PolyCurve`: The translated PolyCurve.

        #### Example usage:
        ```python

        ```        
        """
        for i in range(len(self.points)):
            self.points[i] += offset
        return self

    @staticmethod
    def copy_translate(pc: 'PolyCurve', vector_3d: 'Vector') -> 'PolyCurve':
        """Creates a copy of a PolyCurve and translates it by a 3D vector.

        #### Parameters:
        - `pc` (PolyCurve): The PolyCurve to copy and translate.
        - `vector_3d` (Vector): The 3D vector by which to translate the PolyCurve.

        #### Returns:
        `PolyCurve`: The translated copy of the PolyCurve.

        #### Example usage:
        ```python

        ```        
        """
        crvs = []
        vector_1 = vector_3d
        for i in pc.curves:
            # if i.__class__.__name__ == "Arc":
            #    crvs.append(Arc(Point.translate(i.start, vector_1), Point.translate(i.middle, vector_1), Point.translate(i.end, vector_1)))
            if i.__class__.__name__ == "Line":
                crvs.append(Line(Point.translate(i.start, vector_1),
                            Point.translate(i.end, vector_1)))
            else:
                print("Curvetype not found")

        PCnew = PolyCurve.by_joined_curves(crvs)
        return PCnew

    def rotate(self, angle: 'float', dz: 'float') -> 'PolyCurve':
        """Rotates the PolyCurve by a given angle around the Z-axis and displaces it in the Z-direction.

        #### Parameters:
        - `angle` (float): The angle of rotation in degrees.
        - `dz` (float): The displacement in the Z-direction.

        #### Returns:
        `PolyCurve`: The rotated and displaced PolyCurve.

        #### Example usage:
        ```python

        ```        
        """
        # angle in degrees
        # dz = displacement in z-direction
        crvs = []
        for i in self.curves:
            if i.__class__.__name__ == "Arc":
                crvs.append(Arc(Point.rotate_XY(i.start, angle, dz), Point.rotate_XY(
                    i.middle, angle, dz), Point.rotate_XY(i.end, angle, dz)))
            elif i.__class__.__name__ == "Line":
                crvs.append(Line(Point.rotate_XY(i.start, angle, dz),
                            Point.rotate_XY(i.end, angle, dz)))
            else:
                print("Curvetype not found")
        crv = PolyCurve.by_joined_curves(crvs)
        return crv

    @staticmethod
    def transform_from_origin(polycurve: 'PolyCurve', startpoint: 'Point', directionvector: 'Vector') -> 'PolyCurve':
        """Transforms a PolyCurve from a given origin point and direction vector.

        #### Parameters:
        - `polycurve` (PolyCurve): The PolyCurve to transform.
        - `startpoint` (Point): The origin point for the transformation.
        - `directionvector` (Vector): The direction vector for the transformation.

        #### Returns:
        `PolyCurve`: The transformed PolyCurve.

        #### Example usage:
        ```python

        ```        
        """

        if polycurve.type == "PolyCurve2D":
            crvs = []
            pnts = []            
            for i in polycurve.curves:
                if i.__class__.__name__ == "Arc" or i.__class__.__name__ == "Arc2D":
                    start_transformed = transform_point(Point.point_2D_to_3D(i.start) if i.__class__.__name__ == "Arc2D" else i.start, CSGlobal, startpoint, directionvector)
                    mid_transformed = transform_point(Point.point_2D_to_3D(i.mid) if i.__class__.__name__ == "Arc2D" else i.mid, CSGlobal, startpoint, directionvector)
                    end_transformed = transform_point(Point.point_2D_to_3D(i.end) if i.__class__.__name__ == "Arc2D" else i.end, CSGlobal, startpoint, directionvector)
                    
                    crvs.append(Arc(start_transformed, mid_transformed, end_transformed))
                    pnts.extend([start_transformed, mid_transformed, end_transformed])

                elif i.__class__.__name__ == "Line" or i.__class__.__name__ == "Line2D":
                    start_transformed = transform_point(Point.point_2D_to_3D(i.start) if i.__class__.__name__ == "Line2D" else i.start, CSGlobal, startpoint, directionvector)
                    end_transformed = transform_point(Point.point_2D_to_3D(i.end) if i.__class__.__name__ == "Line2D" else i.end, CSGlobal, startpoint, directionvector)

                    crvs.append(Line(start_transformed, end_transformed))
                    pnts.extend([start_transformed, end_transformed])

                else:
                    print(i.__class__.__name__ + " Curvetype not found")

                # if i.__class__.__name__ == "Arc":
                #     crvs.append(Arc(transform_point(i.start, CSGlobal, startpoint, directionvector),
                #                     transform_point(
                #                         i.mid, CSGlobal, startpoint, directionvector),
                #                     transform_point(
                #                         i.end, CSGlobal, startpoint, directionvector)
                #                     ))
                # elif i.__class__.__name__ == "Line":
                #     crvs.append(Line(start=transform_point(i.start, CSGlobal, startpoint, directionvector),
                #                      end=transform_point(
                #                          i.end, CSGlobal, startpoint, directionvector)
                #                      ))
                # elif i.__class__.__name__ == "Arc2D":
                #     # print(Point.point_2D_to_3D(i.start),CSGlobal, startpoint, directionvector)
                #     crvs.append(Arc(transform_point(Point.point_2D_to_3D(i.start), CSGlobal, startpoint, directionvector),
                #                     transform_point(Point.point_2D_to_3D(
                #                         i.mid), CSGlobal, startpoint, directionvector),
                #                     transform_point(Point.point_2D_to_3D(
                #                         i.end), CSGlobal, startpoint, directionvector)
                #                     ))
                # elif i.__class__.__name__ == "Line2D":
                #     crvs.append(Line(start=transform_point(Point.point_2D_to_3D(i.start), CSGlobal, startpoint, directionvector),
                #                      end=transform_point(Point.point_2D_to_3D(
                #                          i.end), CSGlobal, startpoint, directionvector)
                #                      ))
                # else:
                #     print(i.__class__.__name__ + "Curvetype not found")
                
            new_polycurve = PolyCurve()
            new_polycurve.curves = crvs
            new_polycurve.points = pnts
            return new_polycurve

        elif polycurve.type == "PolyCurve":
            for i in polycurve.curves:
                if i.__class__.__name__ == "Arc":
                    crvs.append(Arc(transform_point(i.start, CSGlobal, startpoint, directionvector),
                                    transform_point(
                                        i.mid, CSGlobal, startpoint, directionvector),
                                    transform_point(
                                        i.end, CSGlobal, startpoint, directionvector)
                                    ))
                elif i.__class__.__name__ == "Line":
                    crvs.append(Line(start=transform_point(i.start, CSGlobal, startpoint, directionvector),
                                     end=transform_point(
                                         i.end, CSGlobal, startpoint, directionvector)
                                     ))
                elif i.__class__.__name__ == "Arc2D":
                    # print(Point.point_2D_to_3D(i.start),CSGlobal, startpoint, directionvector)
                    crvs.append(Arc(transform_point(Point.point_2D_to_3D(i.start), CSGlobal, startpoint, directionvector),
                                    transform_point(Point.point_2D_to_3D(
                                        i.mid), CSGlobal, startpoint, directionvector),
                                    transform_point(Point.point_2D_to_3D(
                                        i.end), CSGlobal, startpoint, directionvector)
                                    ))
                elif i.__class__.__name__ == "Line2D":
                    crvs.append(Line(start=transform_point(Point.point_2D_to_3D(i.start), CSGlobal, startpoint, directionvector),
                                     end=transform_point(Point.point_2D_to_3D(
                                         i.end), CSGlobal, startpoint, directionvector)
                                     ))
                else:
                    print(i.__class__.__name__ + "Curvetype not found")

        pc = PolyCurve()
        pc.curves = crvs
        return pc

class Polygon(PointList):
    """Represents a polygon composed of points."""
    def __init__(self, *args) -> 'Polygon':
        
        super().__init__(to_array(*args))


    @property
    def closed(self) -> bool: return self[0] == self[-1]
    
    @closed.setter
    def closed(self, value) -> Self:
        """Closes the PolyCurve by connecting the last point to the first point, or opens it by removing the last point if it's a duplicate of the first point
        #### Example usage:
        ```python
            c:PolyCurve = PolyCurve(Point(1,3),Point(4,3),Point(2,6))
            c.closed = true #Point(1,3) just got added to the back of the list
        ```
        """
        if value != self.closed:
            if value:
                #copy. else, when operators are executed, it will execute the operator twice on the same reference
                self.append(Vector(self[0]))
            else:
                del self[-1]
        return self
    

    @property
    def curves(self) -> list[Line]:
        """this function won't close the polycurve!

        Returns:
            list[Line]: the curves connecting this polycurve
        """
        return [Line(self[point_index], self[point_index + 1]) for point_index in range(len(self) - 1)]

    @property
    def is_rectangle(self) -> bool:
        """the polycurve should be wound counter-clockwise and the first line should be in the x direction

        Returns:
            bool: if this curve is a rectangle, i.e. it has 4 corner points
        """
        if len(self) == 4 or self.closed and len(self) == 5:
            if self[0].y == self[1].y and self[1].x == self[2].x and self[2].y == self[3].y and self[3].x == self[0].x:
                return True
        else: return False

    def contains(self, p: 'Point') -> bool:
        """checks if the point is inside the polygon

        Args:
            p (Point): _description_

        Returns:
            bool: _description_
        """
        #yoinked this from stack overflow, looks clean
        #https://stackoverflow.com/questions/36399381/whats-the-fastest-way-of-checking-if-a-point-is-inside-a-polygon-in-python
        
        # Ray tracing
        n = len(self)
        inside = False
    
        p1 = self[0]
        for i in range(n + 1 if self.closed else n):
            p2 = self[i % n]
            if p.y > min(p1.y,p2.y):
                if p.y <= max(p1.y,p2.y):
                    if p.x <= max(p1.x,p2.x):
                        if p1.y != p2.y:
                            xints = (p.y-p1.y)*(p2.x-p1.x)/(p2.y-p1.y)+p1.x
                        if p1.x == p2.x or p.x <= xints:
                            inside = not inside
            p1 = p2
    
        return inside

    def intersects(self, other: 'PolyCurve') -> bool:
        """checks if two polycurves intersect with eachother. caution! this is brute force.

        Args:
            other (PolyCurve): the PolyCurve which may intersect with this rectangle

        Returns:
            bool: true if any of the lines of the two polygons cross eachother.
        """
        #before doing such an expensive method, let's check if our bounds cross first.
        if self.bounds.collides(other.bounds):
            other_curves = other.curves
            for c in self.curves:
                for other_c in other_curves:
                    if(c.intersects(other_c)):return True
        return False
    
    def collides(self, other: 'Polygon') -> bool:
        """checks if two polygons collide with eachother.

        Args:
            other (Polygon): the polygon which may collide with this rectangle

        Returns:
            bool: true if two polygons overlap
        """
        #hopefully, most of the time we contain a point of the other.
        return self.contains(other[0]) or other.contains(self[0]) or self.intersects(other)

    @classmethod
    def by_points(self, points: 'list[Point]') -> 'Polygon':
        """Creates a Polygon from a list of points.

        #### Parameters:
        - `points` (list[Point]): The list of points defining the Polygon.

        #### Returns:
        `Polygon`: The created Polygon object.

        #### Example usage:
        ```python

        ```        
        """
        if len(points) < 3:
            print("Error: Polygon must have at least 3 unique points.")
            return None

        _points = []

        for point in points: #Convert all to Point
            if point.type == "Point2D":
                _points.append(Point(point.x, point.y, 0))
            else:
                _points.append(point)

        if Point.to_matrix(_points[0]) == Point.to_matrix(_points[-1]):
            _points.pop()

        seen = set()
        unique_points = [p for p in _points if not (p in seen or seen.add(p))]

        polygon = Polygon()
        polygon.points = unique_points

        num_points = len(unique_points)
        for i in range(num_points):
            next_index = (i + 1) % num_points
            polygon.curves.append(Line(start=unique_points[i], end=unique_points[next_index]))

        return polygon

    @staticmethod
    def rectangular(rect: Rect) -> 'Polygon':
        """Creates a rectangle in a given plane.

        #### Parameters:
        - `rect` (Rect): The rectangle to use as reference. one axis of its size should be 0 or a ValueError will occur!
        - `width` (float): The width of the rectangle.
        - `height` (float): The height of the rectangle.

        #### Returns:
        `Polygon`: The rectangle Polygon.

        #### Example usage:
        ```python
        ```    
        """
        try:
            not_used_axis_index = rect.size.index(0)
        except:
            #2d rectangle
            not_used_axis_index = 2

        axis0 = 1 if not_used_axis_index == 0 else 0
        axis1 = 1 if not_used_axis_index == 2 else 2

        rect_p1 = rect.p1
        curve_p0 = rect.p0
        #clone
        curve_p1 = Point(rect.p0)
        curve_p1[axis0] = rect_p1[axis0]

        curve_p2 = rect_p1
        curve_p3 = Point(rect.p0)
        curve_p3[axis1] = rect_p1[axis1]
        return Polygon(curve_p0, curve_p1, curve_p2, curve_p3)

    @staticmethod
    def by_joined_curves(lines: 'list[Line]') -> 'Polygon':
        """returns an unclosed polygon from the provided lines, with each point being the starting point of each line.
        creates a shallow copy of the lines provided!

        Args:
            lines (list[Line]): the starting point of every line provided will be used. segments are expected to be continuous. (lines[0].end == lines[1].start)

        Returns:
            Polygon: an unclosed polygon.
        """
        if not lines:
            print("Error: At least one curve is required to form a Polygon.")
            sys.exit()

        for i in range(len(lines) - 1):
            if lines[i].end != lines[i+1].start:
                raise ValueError("Error: Curves must be contiguous to form a Polygon.")

        #if lines[0].start != lines[-1].end:
        #    lines.append(Line(lines[-1].end, lines[0].start))

        return Polygon([line.start for line in lines] + [lines[-1].end])
    
    @property
    def area(self) -> 'float':  # shoelace formula
        """Calculates the area enclosed by the Polygon using the shoelace formula.

        #### Returns:
        `float`: The area enclosed by the Polygon.

        #### Example usage:
        ```python

        ```        
        """
        if len(self) < 3:
            return "Polygon has less than 3 points!"

        num_points = len(self)
        S1, S2 = 0, 0

        for i in range(num_points):
            S1 += self[i - 1].x * self[i].y
            S2 += self[i - 1].y * self[i].x

        area = 0.5 * abs(S1 - S2)
        return area
    
    @property
    def centroid(self) -> 'Point':
        """Calculates the centroid of the Polygon in 2D. we assume that the polygon doesn't intersect itself.

        #### Returns:
        `Point`: The centroid point of the Polygon.

        #### Example usage:
        ```python

        ```        
        """
        if self.closed:
            num_points = len(self)
            if num_points < 3:
                return "Polygon has less than 3 points!"
            
            area = self.area
            
            #https://stackoverflow.com/questions/5271583/center-of-gravity-of-a-polygon
            

            Cx, Cy = 0.0, 0.0
            for i in range(num_points):
                x0, y0 = self[i-1].x, self[i-1].y
                x1, y1 = self[i].x, self[i].y
                factor = (x0 * y1 - x1 * y0)
                Cx += (x0 + x1) * factor
                Cy += (y0 + y1) * factor

            Cx /= (6.0 * area)
            Cy /= (6.0 * area)

            return Point(Cx, Cy)
        else:
            raise ValueError("this polycurve is not closed")

    def length(self) -> 'float':
        """Calculates the total length of the Polygon.

        #### Returns:
        `float`: The total length of the Polygon.

        #### Example usage:
        ```python

        ```
        """
        lst = []
        for line in self.curves:
            lst.append(line.length)

        return sum(i.length for i in self.curves)




    def __str__(self) -> 'str':
        """Returns a string representation of the PolyCurve.

        #### Returns:
        `str`: The string representation of the PolyCurve.

        #### Example usage:
        ```python

        ```        
        """
        return f"{__class__.__name__} (points: {list.__str__(self)})"


class Arc:
    def __init__(self, startPoint: 'Point', midPoint: 'Point', endPoint: 'Point') -> 'Arc':
        """Initializes an Arc object with start, mid, and end points.
        This constructor calculates and assigns the arc's origin, plane, radius, start angle, end angle, angle in radians, area, length, units, and coordinate system based on the input points.
        
        the mid point should really be in the center; we don't support warped arcs.

        - `startPoint` (Point): The starting point of the arc.
        - `midPoint` (Point): The mid point of the arc which defines its curvature.
        - `endPoint` (Point): The ending point of the arc.
        """
        #for the midpoint to be in the middle, the distance between the midpoint and the start and the end should be the same, no matter the angle.
        if not math.isclose(Point.distance_squared(startPoint, midPoint), Point.distance_squared(midPoint, endPoint), rel_tol= 1.0 / 0x100):
            raise ValueError('midpoint is not in the center')
        
        
        self.start = startPoint
        self.mid = midPoint
        self.end = endPoint
        #self.origin = self.origin_arc()
        #vector_1 = Vector(x=1, y=0, z=0)
        #vector_2 = Vector(x=0, y=1, z=0)
        #self.plane = Plane.by_two_vectors_origin(
        #    vector_1,
        #    vector_2,
        #    self.origin
        #)
        #self.radius = self.radius_arc()
        #self.startAngle = 0
        #self.endAngle = 0
        #self.angle_radian = self.angle_radian()
        #self.area = 0
        #self.length = self.length()
        #self.units = project.units
        #self.coordinatesystem = self.coordinatesystem_arc()

    def coordinatesystem_arc(self) -> 'CoordinateSystem':
        """Calculates and returns the coordinate system of the arc.
        The coordinate system is defined by the origin of the arc and the normalized vectors along the local X, Y, and Z axes.

        #### Returns:
        `CoordinateSystem`: The coordinate system of the arc.

        #### Example usage:
        ```python
        coordinatesystem = arc.coordinatesystem_arc()
        # coordinatesystem will be an instance of CoordinateSystem representing the arc's local coordinate system
        ```
        """
        vx = Vector.by_two_points(self.origin, self.start)  # Local X-axe
        vector_2 = Vector.by_two_points(self.end, self.origin)
        vz = Vector.cross_product(vx, vector_2)  # Local Z-axe
        vy = Vector.cross_product(vx, vz)  # Local Y-axe
        self.coordinatesystem = CoordinateSystem(self.origin, Vector.normalize(vx), Vector.normalize(vy),
                                                 Vector.normalize(vz))
        return self.coordinatesystem
    
    @property
    def radius(self) -> 'float':
        """Calculates and returns the radius of the arc.
        The radius is computed based on the distances between the start, mid, and end points of the arc.

        #### Returns:
        `float`: The radius of the arc.

        #### Example usage:
        ```python
        radius = arc.radius_arc()
        # radius will be the calculated radius of the arc
        ```
        """
        a = Point.distance(self.start, self.mid)
        b = Point.distance(self.mid, self.end)
        c = Point.distance(self.end, self.start)
        s = (a + b + c) / 2
        A = math.sqrt(max(s * (s - a) * (s - b) * (s - c), 0))
        
        if abs(A) < 1e-6:
            return float('inf')
        else:
            R = (a * b * c) / (4 * A)
            return R
        
    #https://calcresource.com/geom-circularsegment.html
    @property
    def area(self) -> 'float':
        return ((self.angle - math.sin(self.angle)) / 2) * (self.radius ** 2)
    
    @property
    def origin(self) -> 'Point':
        """Calculates and returns the origin of the arc.
        The origin is calculated based on the geometric properties of the arc defined by its start, mid, and end points.

        #### Returns:
        `Point`: The calculated origin point of the arc.

        #### Example usage:
        ```python
        origin = arc.origin_arc()
        # origin will be the calculated origin point of the arc
        ```
        """
        start_to_end = self.end - self.start
        half_start_end = start_to_end * 0.5
        b = half_start_end.magnitude
        radius = self.radius
        x = math.sqrt(radius * radius - b * b)
        #mid point as if this was a straight line
        mid = self.start + half_start_end
        #substract the curved mid point from the straight line mid point
        to_center = mid - self.mid
        #change length to x
        to_center.magnitude = x
        center = mid + to_center
        return center

    @property
    def centroid(self) -> 'Point':
        origin = self.origin
        radius = self.radius
        angle = self.angle
        #the distance of the centroid of the arc to its origin
        centroid_distance = (2 / 3) * ((radius * (math.sin(angle) ** 3)) / (angle - math.sin(angle) * math.cos(angle)))
        return origin + centroid_distance * ((self.mid - origin) / radius)
        
    @property
    def angle(self) -> 'float':
        """Calculates and returns the total angle of the arc in radians.
        The angle is determined based on the vectors defined by the start, mid, and end points with respect to the arc's origin.

        #### Returns:
        `float`: The total angle of the arc in radians.

        #### Example usage:
        ```python
        angle = arc.angle_radian()
        # angle will be the total angle of the arc in radians
        ```
        """
        origin = self.origin
        vector_1 = self.end - origin
        vector_2 = self.start - origin
        vector_3 = self.mid - origin
        vector_4 = vector_1 + vector_2
        try:
            v4b = Vector.new_length(vector_4, self.radius)
            if Vector.value(vector_3) == Vector.value(v4b):
                angle = Vector.angle_between(vector_1, vector_2)
            else:
                angle = 2*math.pi-Vector.angle_between(vector_1, vector_2)
            return angle
        except:
            angle = 2*math.pi-Vector.angle_between(vector_1, vector_2)
            return angle
        
    @property
    def length(self) -> 'float':
        """Calculates and returns the length of the arc.
        The length is calculated using the geometric properties of the arc defined by its start, mid, and end points.

        #### Returns:
        `float`: The length of the arc.

        #### Example usage:
        ```python
        length = arc.length()
        # length will be the calculated length of the arc
        ```
        """
        try:
            x1, y1, z1 = self.start.x, self.start.y, self.start.z
            x2, y2, z2 = self.mid.x, self.mid.y, self.mid.z
            x3, y3, z3 = self.end.x, self.end.y, self.end.z

            r1 = ((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2) ** 0.5 / 2
            a = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)
            b = math.sqrt((x3 - x2) ** 2 + (y3 - y2) ** 2 + (z3 - z2) ** 2)
            c = math.sqrt((x3 - x1) ** 2 + (y3 - y1) ** 2 + (z3 - z1) ** 2)
            cos_angle = (a ** 2 + b ** 2 - c ** 2) / (2 * a * b)
            m1 = math.acos(cos_angle)
            arc_length = r1 * m1

            return arc_length
        except:
            return 0
    
    @staticmethod
    def points_at_parameter(arc: 'Arc', count: 'int') -> 'list':
        """Generates a list of points along the arc at specified intervals.
        This method divides the arc into segments based on the `count` parameter and calculates points at these intervals along the arc.

        #### Parameters:
        - `arc` (Arc): The arc object.
        - `count` (int): The number of points to generate along the arc.

        #### Returns:
        `list`: A list of points (`Point` objects) along the arc.

        #### Example usage:
        ```python
        arc = Arc(startPoint, midPoint, endPoint)
        points = Arc.points_at_parameter(arc, 5)
        # points will be a list of 5 points along the arc
        ```
        """
        # Create points at parameter on an arc based on an interval
        d_alpha = arc.angle_radian / (count - 1)
        alpha = 0
        pnts = []
        for i in range(count):
            pnts.append(Point(arc.radius * math.cos(alpha),
                        arc.radius * math.sin(alpha), 0))
            alpha = alpha + d_alpha
        cs_new = arc.coordinatesystem
        pnts2 = []  # transformed points
        for i in pnts:
            pnts2.append(transform_point_2(i, cs_new))
        return pnts2

    @staticmethod
    def segmented_arc(arc: 'Arc', count: 'int') -> 'list':
        """Divides the arc into segments and returns a list of line segments.
        This method uses the `points_at_parameter` method to generate points along the arc at specified intervals and then creates line segments between these consecutive points.

        #### Parameters:
        - `arc` (Arc): The arc object.
        - `count` (int): The number of segments (and thus the number of points - 1) to create.

        #### Returns:
        `list`: A list of line segments (`Line` objects) representing the divided arc.

        #### Example usage:
        ```python
        arc = Arc(startPoint, midPoint, endPoint)
        segments = Arc.segmented_arc(arc, 3)
        # segments will be a list of 2 lines dividing the arc into 3 segments
        ```
        """
        pnts = Arc.points_at_parameter(arc, count)
        i = 0
        lines = []
        for j in range(len(pnts) - 1):
            lines.append(Line(pnts[i], pnts[i + 1]))
            i = i + 1
        return lines

    def __str__(self) -> 'str':
        """Generates a string representation of the Arc object.

        #### Returns:
        `str`: A string that represents the Arc object.

        #### Example usage:
        ```python
        arc = Arc(startPoint, midPoint, endPoint)
        print(arc)
        # Output: Arc()
        ```
        """
        return f"{__class__.__name__}()"


def transform_arc(arc_old, cs_new: 'CoordinateSystem') -> 'Arc':
    """Transforms an Arc object to a new coordinate system.

    This function takes an existing Arc object and a new CoordinateSystem object. It transforms the start, mid, and end points of the Arc to the new coordinate system, creating a new Arc object in the process.

    #### Parameters:
    - `arc_old` (Arc): The original Arc object to be transformed.
    - `cs_new` (CoordinateSystem): The new coordinate system to transform the Arc into.

    #### Returns:
    `Arc`: A new Arc object with its points transformed to the new coordinate system.

    #### Example usage:
    ```python
    arc_old = Arc(startPoint, midPoint, endPoint)
    cs_new = CoordinateSystem(...)  # Defined elsewhere
    arc_new = transform_arc(arc_old, cs_new)
    # arc_new is the transformed Arc object
    ```
    """
    start = transform_point_2(arc_old.start, cs_new)
    mid = transform_point_2(arc_old.mid, cs_new)
    end = transform_point_2(arc_old.end, cs_new)
    arc_new = Arc(startPoint=start, midPoint=mid, endPoint=end)

    return arc_new


class Circle:
    """Represents a circle with a specific radius, plane, and length.
    """
    def __init__(self, radius: 'float', plane: 'Plane', length: 'float') -> 'Circle':
        """The Circle class defines a circle by its radius, the plane it lies in, and its calculated length (circumference).

        - `radius` (float): The radius of the circle.
        - `plane` (Plane): The plane in which the circle lies.
        - `length` (float): The length (circumference) of the circle. Automatically calculated during initialization.
        """
        self.radius = radius
        self.plane = plane
        self.length = length
        
        pass  # Curve

    def __id__(self):
        """Returns the ID of the Circle.

        #### Returns:
        `str`: The ID of the Circle in the format "id:{self.id}".
        """

    def __str__(self) -> 'str':
        """Generates a string representation of the Circle object.

        #### Returns:
        `str`: A string that represents the Circle object.

        #### Example usage:
        ```python
        circle = Circle(radius, plane, length)
        print(circle)
        # Output: Circle(...)
        ```
        """


class Ellipse:
    """Represents an ellipse defined by its two radii and the plane it lies in."""
    def __init__(self, firstRadius: 'float', secondRadius: 'float', plane: 'Plane') -> 'Ellipse':
        """The Ellipse class describes an ellipse through its major and minor radii and the plane it occupies.
            
        - `firstRadius` (float): The first (major) radius of the ellipse.
        - `secondRadius` (float): The second (minor) radius of the ellipse.
        - `plane` (Plane): The plane in which the ellipse lies.
        """
        self.firstRadius = firstRadius
        self.secondRadius = secondRadius
        self.plane = plane
        
        pass  # Curve

    def __id__(self):
        """Returns the ID of the Ellipse.

        #### Returns:
        `str`: The ID of the Ellipse in the format "id:{self.id}".
        """
        return f"id:{self.id}"

    def __str__(self) -> 'str':
        """Generates a string representation of the Ellipse object.

        #### Returns:
        `str`: A string that represents the Ellipse object.

        #### Example usage:
        ```python
        ellipse = Ellipse(firstRadius, secondRadius, plane)
        print(ellipse)
        # Output: Ellipse(...)
        ```
        """
        return f"{__class__.__name__}({self})"


class Matrix(Serializable, list[list]):
    """
    elements are ordered like [row][column] or [y][x]
    """
    def __init__(self, matrix:list[list]=[[1, 0], [0, 1]]) -> 'Matrix':
        list.__init__(self, matrix)
    

    @property
    def cols(self) -> 'int':
        """returns the width (x size) of this matrix in columns."""
        return len(self[0])

    @property
    def rows(self) -> 'int':
        """returns the height (y size) of this matrix in columns."""
        return len(self)

    @staticmethod
    def scale(dimensions: int, scalar: float)-> 'Matrix':
        
        match dimensions:
            case 1:
                arr = [[scalar]]
            case 2:
                arr = [[scalar,0],
                        [0,scalar]]
            case 3:
                arr = [[scalar, 0, 0],
                        [0, scalar, 0],
                        [0, 0, scalar]]
            case 4:
                arr= [[scalar, 0, 0, 0],
                        [0, scalar, 0, 0],
                        [0, 0, scalar, 0],
                        [0, 0, 0, scalar]]
        return Matrix(arr)
    
    @staticmethod
    def empty(rows:int, cols = None):
        """creates a matrix of size n x m (rows x columns or y * x or h * w)"""
        if cols == None:
            cols = rows
        return Matrix([[0 for col in range(cols)] for row in range(rows)])

    @staticmethod
    def identity(dimensions:int):
        return Matrix.scale(dimensions, 1)

    @staticmethod
    def translate(toAdd: Vector):
        dimensions:int = len(toAdd) + 1
        return Matrix([[1 if x == y else toAdd[y] if x == len(toAdd) else 0 for x in range(dimensions)] for y in range(len(toAdd))])
    
    def __mul__(self, other:Self | Coords | Line | Rect | PointList):
        """CAUTION! MATRICES NEED TO MULTIPLY FROM RIGHT TO LEFT!
        for example: translate * rotate (rotate first, translate after)
        and: matrix * point (point first, multiplied by matrix after)"""
        if isinstance(other, Matrix):
            #multiply matrices with eachother
            #https://www.geeksforgeeks.org/multiplication-two-matrices-single-line-using-numpy-python/

            #visualisation of resulting sizes:
            #https://en.wikipedia.org/wiki/Matrix_multiplication

            #the number of columns (width) in the first matrix needs to be equal to the number of rows (height) in the second matrix
            #(look at for i in range(other.height))

            #we are multiplying row vectors of self with col vectors of other
            if self.cols == other.rows:
                resultRows = self.rows
                resultCols = other.cols
                result:Matrix = Matrix.empty(resultRows, resultCols)
                # explicit for loops
                for row in range(self.rows):
                    for col in range(other.cols):
                        for multiplyIndex in range(other.rows):
                            #this is the simple code, which would work if the number of self.cols was equal to other.rows
                            result[row][col] += self[row][multiplyIndex] * other[multiplyIndex][col]
            else:
                resultCols = max(self.cols, other.cols)
                resultRows = max(self.rows, other.rows)

                result:Matrix = Matrix.empty(resultRows, resultCols)

                #the size of the vector that we're multiplying.
                multiplyVectorSize = max(self.cols, other.rows)

                # explicit for loops
                for row in range(resultRows):
                    for col in range(resultCols):
                        for multiplyIndex in range(multiplyVectorSize):
                            #if an element doesn't exist in the matrix, we use an identity element.
                            selfValue = self[row][multiplyIndex] if row < self.rows and multiplyIndex < self.cols else 1 if multiplyIndex == row else 0
                            otherValue = other[multiplyIndex][col] if col < other.cols and multiplyIndex < other.rows else 1 if multiplyIndex == col else 0
                            result[row][col] += selfValue * otherValue

        elif isinstance(other, PointList):
            return other.__class__([self * p for p in other])
        #point comes in from top and comes out to the right:
        # |
        # v
        #a b
        #c d ->
        elif isinstance(other, Coords):
            result: Coords = Coords([0] * self.rows)
            #loop over column vectors and multiply them with the vector. sum the results (multiplied col 1 + multiplied col 2) to get the final product!
            for col in range(self.cols):
                if col < len(other):
                    for row in range(self.rows):
                        result[row] += self[row][col] * other[col]
                else:
                    #otherValue = 1, just add the vector
                    for row in range(self.rows):
                        result[row] += self[row][col]
            return result
        elif isinstance(other, Line):
            return Line(self * other.start, self * other.end)
        elif isinstance(other, Rect):
            mp0 = self * other.p0
            mp1 = self * other.p1
            return Rect.by_points([mp0, mp1])
        return result
    
    transform = multiply = __mul__

    def add(self, other: 'Matrix'):
        if self.shape() != other.shape():
            raise ValueError("Matrices must have the same dimensions")
        return Matrix([[self[i][j] + other.matrix[i][j] for j in range(len(self[0]))] for i in range(len(self))])

    def all(self, axis=None):
        if axis is None:
            return all(all(row) for row in self)
        elif axis == 0:
            return [all(self[row][col] for row in range(len(self))) for col in range(len(self[0]))]
        elif axis == 1:
            return [all(col) for col in self]
        else:
            raise ValueError("Axis must be None, 0, or 1")

    def any(self, axis=None):
        if axis is None:
            return any(any(row) for row in self)
        elif axis == 0:
            return [any(self[row][col] for row in range(len(self))) for col in range(len(self[0]))]
        elif axis == 1:
            return [any(col) for col in self]
        else:
            raise ValueError("Axis must be None, 0, or 1")

    def argmax(self, axis=None):
        if axis is None:
            flat_list = [item for sublist in self for item in sublist]
            return flat_list.index(max(flat_list))
        elif axis == 0:
            return [max(range(len(self)), key=lambda row: self[row][col]) for col in range(len(self[0]))]
        elif axis == 1:
            return [max(range(len(row)), key=lambda col: row[col]) for row in self]
        else:
            raise ValueError("Axis must be None, 0, or 1")

    def argmin(self, axis=None):
        if axis is None:
            flat_list = [item for sublist in self for item in sublist]
            return flat_list.index(min(flat_list))
        elif axis == 0:
            return [min(range(len(self)), key=lambda row: self[row][col]) for col in range(len(self[0]))]
        elif axis == 1:
            return [min(range(len(row)), key=lambda col: row[col]) for row in self]
        else:
            raise ValueError("Axis must be None, 0, or 1")

    def argpartition(self, kth, axis=0):
        def partition(arr, kth):
            pivot = arr[kth]
            less = [i for i in range(len(arr)) if arr[i] < pivot]
            equal = [i for i in range(len(arr)) if arr[i] == pivot]
            greater = [i for i in range(len(arr)) if arr[i] > pivot]
            return less + equal + greater

        if axis == 0:
            return [partition([self[row][col] for row in range(len(self))], kth) for col in range(len(self[0]))]
        elif axis == 1:
            return [partition(row, kth) for row in self]

    def argsort(self, axis=0):
        if axis == 0:
            return [[row for row, val in sorted(enumerate(col), key=lambda x: x[1])] for col in zip(*self)]
        elif axis == 1:
            return [list(range(len(self[0]))) for _ in self]

    def astype(self, dtype):
        cast_matrix = [[dtype(item) for item in row] for row in self]
        return Matrix(cast_matrix)

    def byteswap(self, inplace=False):
        if inplace:
            for i in range(len(self)):
                for j in range(len(self[i])):
                    self[i][j] = ~self[i][j]
            return self
        else:
            new_matrix = [[~item for item in row] for row in self]
            return Matrix(new_matrix)

    def choose(self, choices, mode='raise'):
        if mode != 'raise':
            raise NotImplementedError("Only 'raise' mode is implemented")

        chosen = [[choices[item] for item in row] for row in self]
        return Matrix(chosen)

    def compress(self, condition, axis=None):
        if axis == 0:
            compressed = [row for row, cond in zip(
                self, condition) if cond]
            return Matrix(compressed)
        else:
            raise NotImplementedError("Axis other than 0 is not implemented")

    def clip(self, min=None, max=None):
        clipped_matrix = []
        for row in self:
            clipped_row = [max if max is not None and val >
                           max else min if min is not None and val < min else val for val in row]
            clipped_matrix.append(clipped_row)
        return Matrix(clipped_matrix)

    def conj(self):
        conjugated_matrix = [[complex(item).conjugate()
                              for item in row] for row in self]
        return Matrix(conjugated_matrix)

    def conjugate(self):
        return self.conj()

    def copy(self):
        copied_matrix = copy.deepcopy(self)
        return Matrix(copied_matrix)

    def cumprod(self, axis=None):
        if axis is None:
            flat_list = self.flatten()
            cumprod_list = []
            cumprod = 1
            for item in flat_list:
                cumprod *= item
                cumprod_list.append(cumprod)
            return Matrix([cumprod_list])
        else:
            raise NotImplementedError(
                "Axis handling not implemented in this example")

    def cumsum(self, axis=None):
        if axis is None:
            flat_list = self.flatten()
            cumsum_list = []
            cumsum = 0
            for item in flat_list:
                cumsum += item
                cumsum_list.append(cumsum)
            return Matrix([cumsum_list])
        else:
            raise NotImplementedError(
                "Axis handling not implemented in this example")

    def diagonal(self, offset=0):
        return [self[i][i + offset] for i in range(len(self)) if 0 <= i + offset < len(self[i])]

    def dump(self, file):
        with open(file, 'wb') as f:
            pickle.dump(self, f)

    def dumps(self):
        return pickle.dumps(self)

    def fill(self, value):
        for i in range(len(self)):
            for j in range(len(self[i])):
                self[i][j] = value

    @staticmethod
    def from_points(from_point: Point, to_point: Point):
        Vz = Vector.by_two_points(from_point, to_point)
        Vz = Vector.normalize(Vz)
        Vzglob = Vector(0, 0, 1)
        Vx = Vector.cross_product(Vz, Vzglob)
        if Vector.length(Vx) == 0:
            Vx = Vector(1, 0, 0) if Vz.x != 1 else Vector(0, 1, 0)
        Vx = Vector.normalize(Vx)
        Vy = Vector.cross_product(Vx, Vz)

        return Matrix([
            [Vx.x, Vy.x, Vz.x, from_point.x],
            [Vx.y, Vy.y, Vz.y, from_point.y],
            [Vx.z, Vy.z, Vz.z, from_point.z],
            [0, 0, 0, 1]
        ])

    def flatten(self):
        return [item for sublist in self for item in sublist]

    def getA(self):
        return self

    def getA1(self):
        return [item for sublist in self for item in sublist]

    def getH(self):
        conjugate_transposed = [[complex(self[j][i]).conjugate() for j in range(
            len(self))] for i in range(len(self[0]))]
        return Matrix(conjugate_transposed)

    def getI(self):
        raise NotImplementedError(
            "Matrix inversion is a complex operation not covered in this simple implementation.")

    def getT(self):
        return self.transpose()

    def getfield(self, dtype, offset=0):
        raise NotImplementedError(
            "This method is conceptual and depends on structured data support within the Matrix.")

    def item(self, *args):
        if len(args) == 1:
            index = args[0]
            rows, cols = len(self), len(self[0])
            return self[index // cols][index % cols]
        elif len(args) == 2:
            return self[args[0]][args[1]]
        else:
            raise ValueError("Invalid number of indices.")

    def itemset(self, *args):
        if len(args) == 2:
            index, value = args
            rows, cols = len(self), len(self[0])
            self[index // cols][index % cols] = value
        elif len(args) == 3:
            row, col, value = args
            self[row][col] = value
        else:
            raise ValueError("Invalid number of arguments.")

    def max(self, axis=None):
        if axis is None:
            return max(item for sublist in self for item in sublist)
        elif axis == 0:
            return [max(self[row][col] for row in range(len(self))) for col in range(len(self[0]))]
        elif axis == 1:
            return [max(row) for row in self]
        else:
            raise ValueError("Invalid axis.")

    def mean(self, axis=None):
        if axis is None:
            flat_list = self.flatten()
            return sum(flat_list) / len(flat_list)
        elif axis == 0:
            return [sum(self[row][col] for row in range(len(self))) / len(self) for col in range(len(self[0]))]
        elif axis == 1:
            return [sum(row) / len(row) for row in self]
        else:
            raise ValueError("Axis must be None, 0, or 1")

    def min(self, axis=None):
        if axis is None:
            return min(item for sublist in self for item in sublist)
        elif axis == 0:
            return [min(self[row][col] for row in range(len(self))) for col in range(len(self[0]))]
        elif axis == 1:
            return [min(row) for row in self]
        else:
            raise ValueError("Invalid axis.")

    @staticmethod
    def zeros(rows, cols):
        return Matrix([[0 for _ in range(cols)] for _ in range(rows)])

    @staticmethod
    def participation(self):
        pass

    def prod(self, axis=None):
        if axis is None:
            return reduce(lambda x, y: x * y, [item for sublist in self for item in sublist], 1)
        elif axis == 0:
            return [reduce(lambda x, y: x * y, [self[row][col] for row in range(len(self))], 1) for col in range(len(self[0]))]
        elif axis == 1:
            return [reduce(lambda x, y: x * y, row, 1) for row in self]
        else:
            raise ValueError("Invalid axis.")

    def ptp(self, axis=None):
        if axis is None:
            flat_list = [item for sublist in self for item in sublist]
            return max(flat_list) - min(flat_list)
        elif axis == 0:
            return [max([self[row][col] for row in range(len(self))]) - min([self[row][col] for row in range(len(self))]) for col in range(len(self[0]))]
        elif axis == 1:
            return [max(row) - min(row) for row in self]
        else:
            raise ValueError("Invalid axis.")

    def put(self, indices, values):
        if len(indices) != len(values):
            raise ValueError("Length of indices and values must match.")
        flat_list = self.ravel()
        for index, value in zip(indices, values):
            flat_list[index] = value

    @staticmethod
    def random(rows, cols):
        import random
        return Matrix([[random.random() for _ in range(cols)] for _ in range(rows)])

    def ravel(self):
        return [item for sublist in self for item in sublist]

    def repeat(self, repeats, axis=None):
        if axis is None:
            flat_list = self.ravel()
            repeated = [item for item in flat_list for _ in range(repeats)]
            return Matrix([repeated])
        elif axis == 0:
            repeated_matrix = [
                row for row in self for _ in range(repeats)]
        elif axis == 1:
            repeated_matrix = [
                [item for item in row for _ in range(repeats)] for row in self]
        else:
            raise ValueError("Invalid axis.")
        return Matrix(repeated_matrix)

    def reshape(self, rows, cols):
        flat_list = self.flatten()
        if len(flat_list) != rows * cols:
            raise ValueError(
                "The total size of the new array must be unchanged.")
        reshaped = [flat_list[i * cols:(i + 1) * cols] for i in range(rows)]
        return Matrix(reshaped)

    def resize(self, new_shape):
        new_rows, new_cols = new_shape
        current_rows, current_cols = len(self), len(
            self[0]) if self else 0
        if new_rows < current_rows:
            self = self[:new_rows]
        else:
            for _ in range(new_rows - current_rows):
                self.append([0] * current_cols)
        for row in self:
            if new_cols < current_cols:
                row[:] = row[:new_cols]
            else:
                row.extend([0] * (new_cols - current_cols))

    def round(self, decimals=0):
        rounded_matrix = [[round(item, decimals)
                           for item in row] for row in self]
        return Matrix(rounded_matrix)

    def searchsorted(self, v, side='left'):
        flat_list = self.flatten()
        i = 0
        if side == 'left':
            while i < len(flat_list) and flat_list[i] < v:
                i += 1
        elif side == 'right':
            while i < len(flat_list) and flat_list[i] <= v:
                i += 1
        else:
            raise ValueError("side must be 'left' or 'right'")
        return i

    def setfield(self, val, dtype, offset=0):
        raise NotImplementedError(
            "Structured data operations are not supported in this Matrix class.")

    def setflags(self, write=None, align=None, uic=None):
        print("This Matrix class does not support setting flags directly.")

    def shape(self):
        return len(self), len(self[0])

    def sort(self, axis=-1):
        if axis == -1 or axis == 1:
            for row in self:
                row.sort()
        elif axis == 0:
            transposed = [[self[j][i] for j in range(
                len(self))] for i in range(len(self[0]))]
            for row in transposed:
                row.sort()
            self = [[transposed[j][i] for j in range(
                len(transposed))] for i in range(len(transposed[0]))]
        else:
            raise ValueError("Axis out of range.")

    def squeeze(self):
        squeezed_matrix = [row for row in self if any(row)]
        return Matrix(squeezed_matrix)

    def std(self, axis=None, ddof=0):
        var = self.var(axis=axis, ddof=ddof)
        if isinstance(var, list):
            return [x ** 0.5 for x in var]
        else:
            return var ** 0.5

    def subtract(self, other):
        if self.shape() != other.shape():
            raise ValueError("Matrices must have the same dimensions")
        return Matrix([[self[i][j] - other.matrix[i][j] for j in range(len(self[0]))] for i in range(len(self))])

    def sum(self, axis=None):
        if axis is None:
            return sum(sum(row) for row in self)
        elif axis == 0:
            return [sum(self[row][col] for row in range(len(self))) for col in range(len(self[0]))]
        elif axis == 1:
            return [sum(row) for row in self]
        else:
            raise ValueError("Axis must be None, 0, or 1")

    def swapaxes(self, axis1, axis2):
        if axis1 == 0 and axis2 == 1 or axis1 == 1 and axis2 == 0:
            return Matrix([[self[j][i] for j in range(len(self))] for i in range(len(self[0]))])
        else:
            raise ValueError("Axis values out of range for a 2D matrix.")

    def take(self, indices, axis=None):
        if axis is None:
            flat_list = [item for sublist in self for item in sublist]
            return Matrix([flat_list[i] for i in indices])
        elif axis == 0:
            return Matrix([self[i] for i in indices])
        else:
            raise ValueError(
                "Axis not supported or out of range for a 2D matrix.")

    def tobytes(self):
        byte_array = bytearray()
        for row in self:
            for item in row:
                byte_array.extend(struct.pack('i', item))
        return bytes(byte_array)

    def tofile(self, fid, sep="", format="%s"):
        if isinstance(fid, str):
            with open(fid, 'wb' if sep == "" else 'w') as f:
                self._write_to_file(f, sep, format)
        else:
            self._write_to_file(fid, sep, format)

    def _write_to_file(self, file, sep, format):
        if sep == "":
            file.write(self.tobytes())
        else:
            for row in self:
                line = sep.join(format % item for item in row) + "\n"
                file.write(line)
                
    def __str__(self):
        # '\n'.join([str(row) for row in self])
        #vs code doesn't work with new lines
        return 'Matrix(' + list.__str__(self) + ')'

    def trace(self, offset=0):
        rows, cols = len(self), len(self[0])
        return sum(self[i][i + offset] for i in range(min(rows, cols - offset)) if 0 <= i + offset < cols)

    def transpose(self):
        transposed = [[self[j][i] for j in range(
            len(self))] for i in range(len(self[0]))]
        return Matrix(transposed)

    def var(self, axis=None, ddof=0):
        if axis is None:
            flat_list = self.flatten()
            mean = sum(flat_list) / len(flat_list)
            return sum((x - mean) ** 2 for x in flat_list) / (len(flat_list) - ddof)
        elif axis == 0 or axis == 1:
            means = self.mean(axis=axis)
            if axis == 0:
                return [sum((self[row][col] - means[col]) ** 2 for row in range(len(self))) / (len(self) - ddof) for col in range(len(self[0]))]
            else:
                return [sum((row[col] - means[idx]) ** 2 for col in range(len(row))) / (len(row) - ddof) for idx, row in enumerate(self)]
        else:
            raise ValueError("Axis must be None, 0, or 1")

    def _validate(self):
        rows = len(self)
        cols = len(self[0]) if rows > 0 else 0
        return rows, cols

CoordinateSystem = Matrix
class BuildingPy(Serializable):
    def __init__(self, name=None, number=None):
        self.name: str = name
        self.number: str = number
        #settings
        self.debug: bool = True
        self.objects = []
        self.units = "mm"
        self.decimals = 3 #not fully implemented yet

        self.origin = Point(0,0,0)
        self.default_font = "calibri"
        self.scale = 1000
        self.font_height = 500
        self.repr_round = 3
        #prefix objects (name)
        #Geometry settings

        #export selection info
        self.domain = None
        self.applicationId = "OPEN-AEC BuildingPy"

        #different settings for company's?

        #rename this to autoclose?
        self.closed: bool = True #auto close polygons? By default true, else overwrite
        self.round: bool = False #If True then arcs will be segmented. Can be used in Speckle.

        #functie polycurve of iets van een class/def
        self.autoclose: bool = True #new self.closed

        #nodes
        self.node_merge = True #False not yet created
        self.node_diameter = 250
        self.node_threshold = 50
        
        #text
        self.createdTxt = "has been created"

        #structural elements
        self.structural_fallback_element = "HEA100"

        #Speckle settings
        self.speckleserver = "speckle.xyz"
        self.specklestream = None

        #FreeCAD settings
        
    def save(self, file_name = 'project/data.json'):
        Serializable.save(file_name)
        
        type_count = defaultdict(int)
        for serialized_item in self.objects:
            #item = json.loads(serialized_item)
            type_count[serialized_item.__class__.__name__] += 1

        total_items = len(self.objects)

        print(f"\nTotal saved items to '{file_name}': {total_items}")
        print("Type counts:")
        for item_type, count in type_count.items():
            print(f"{item_type}: {count}")
    def open(self, file_name = 'project/data.json'):
        Serializable.open(file_name)

    def toSpeckle(self, streamid, commitstring=None):
        from exchange.speckle import translateObjectsToSpeckleObjects, TransportToSpeckle
        self.specklestream = streamid
        speckleobj = translateObjectsToSpeckleObjects(self.objects)
        TransportToSpeckle(self.speckleserver, streamid, speckleobj, commitstring)

    def toFreeCAD(self):
        from exchange.Freecad_Bupy import translateObjectsToFreeCAD
        translateObjectsToFreeCAD(self.objects)

    def toIFC(self, name):
        from exchange.IFC import translateObjectsToIFC, CreateIFC
        ifc_project = CreateIFC()
        ifc_project.add_project(name)
        ifc_project.add_site("My Site")
        ifc_project.add_building("Building A")
        ifc_project.add_storey("Ground Floor")
        ifc_project.add_storey("G2Floor")     
        translateObjectsToIFC(self.objects, ifc_project)
        ifc_project.export(f"{name}.ifc")
# [!not included in BP singlefile - end]


project = BuildingPy("Project", "0")



class Node:
    """The `Node` class represents a geometric or structural node within a system, defined by a point in space, along with optional attributes like a direction vector, identifying number, and other characteristics."""
    def __init__(self, point=None, vector=None, number=None, distance=0.0, diameter=None, comments=None):
        """"Initializes a new Node instance.
        
        - `id` (str): A unique identifier for the node.
        - `type` (str): The class name, "Node".
        - `point` (Point, optional): The location of the node in 3D space.
        - `vector` (Vector, optional): A vector indicating the orientation or direction associated with the node.
        - `number` (any, optional): An identifying number or label for the node.
        - `distance` (float): A scalar attribute, potentially representing distance from a reference point or another node.
        - `diameter` (any, optional): A diameter associated with the node, useful in structural applications.
        - `comments` (str, optional): Additional comments or notes about the node.
        """
        
        self.point = point if isinstance(point, Point) else None
        self.vector = vector if isinstance(vector, Vector) else None
        self.number = number
        self.distance = distance
        self.diameter = diameter
        self.comments = comments

    def serialize(self) -> dict:
        """Serializes the node's attributes into a dictionary.

        This method allows for the node's properties to be easily stored or transmitted in a dictionary format.

        #### Returns:
        `dict`: A dictionary containing the serialized attributes of the node.
        """
        id_value = str(self.id) if not isinstance(
            self.id, (str, int, float)) else self.id
        return {
            'id': id_value,
            'type': self.type,
            'point': self.point.serialize() if self.point else None,
            'vector': self.vector.serialize() if self.vector else None,
            'number': self.number,
            'distance': self.distance,
            'diameter': self.diameter,
            'comments': self.comments
        }

    @staticmethod
    def deserialize(data: dict) -> 'Node':
        """Recreates a Node object from a dictionary of serialized data.

        #### Parameters:
        - data (dict): The dictionary containing the node's serialized data.

        #### Returns:
        `Node`: A new Node object initialized with the data from the dictionary.
        """
        node = Node()
        node.id = data.get('id')
        node.type = data.get('type')
        node.point = Point.deserialize(
            data['point']) if data.get('point') else None
        node.vector = Vector.deserialize(
            data['vector']) if data.get('vector') else None
        node.number = data.get('number')
        node.distance = data.get('distance')
        node.diameter = data.get('diameter')
        node.comments = data.get('comments')

        return node

    # merge
    def merge(self):
        """Merges this node with others in a project according to defined rules.

        The actual implementation of this method should consider merging nodes based on proximity or other criteria within the project context.
        """
        if project.node_merge == True:
            pass
        else:
            pass

    # snap
    def snap(self):
        """Adjusts the node's position based on snapping criteria.

        This could involve aligning the node to a grid, other nodes, or specific geometric entities.
        """
        pass

    def __str__(self) -> str:
        """Generates a string representation of the Node.

        #### Returns:
        `str`: A string that represents the Node, including its type and potentially other identifying information.
        """

        return f"{self.type}"



class Intersect:
    def __init__(self):
        pass

    def get_line_intersect(line1: Line, line2: Line) -> Point:
        p1, p2 = line1.start, line1.end
        p1X, p1Y, P1Z = p1.x, p1.y, p1.z
        p2X, p2Y, P2Z = p2.x, p2.y, p2.z

        p3, p4 = line2.start, line2.end
        p3X, p3Y, P3Z = p3.x, p3.y, p3.z
        p4X, p4Y, P4Z = p4.x, p4.y, p4.z

        print(p1X, p1Y, P1Z)


MIN_DEPTH = 5
ERROR = 1e-12


def segment_length(curve, start, end, start_point, end_point, error, min_depth, depth):
    """Recursively approximates the length by straight lines"""
    mid = (start + end) / 2
    mid_point = curve.point(mid)
    length = abs(end_point - start_point)
    first_half = abs(mid_point - start_point)
    second_half = abs(end_point - mid_point)

    length2 = first_half + second_half
    if (length2 - length > error) or (depth < min_depth):
        # Calculate the length of each segment:
        depth += 1
        return segment_length(
            curve, start, mid, start_point, mid_point, error, min_depth, depth
        ) + segment_length(
            curve, mid, end, mid_point, end_point, error, min_depth, depth
        )
    # This is accurate enough.
    return length2


class PathSegment(ABC):
    @abstractmethod
    def point(self, pos):
        """Returns the coordinate point (as a complex number) of a point on the path,
        as expressed as a floating point number between 0 (start) and 1 (end).
        """

    @abstractmethod
    def tangent(self, pos):
        """Returns a vector (as a complex number) representing the tangent of a point
        on the path as expressed as a floating point number between 0 (start) and 1 (end).
        """

    @abstractmethod
    def length(self, error=ERROR, min_depth=MIN_DEPTH):
        """Returns the length of a path.

        The CubicBezier and Arc lengths are non-exact and iterative and you can select to
        either do the calculations until a maximum error has been achieved, or a minimum
        number of iterations.
        """


class NonLinear(PathSegment):
    """A line that is not straight

    The base of Arc, QuadraticBezier and CubicBezier
    """


class Linear(PathSegment):
    """A straight line

    The base for Line() and Close().
    """

    def __init__(self, start, end, relative=False):
        self.start = start
        self.end = end
        self.relative = relative

    def __ne__(self, other):
        if not isinstance(other, Line):
            return NotImplemented
        return not self == other

    def point(self, pos):
        distance = self.end - self.start
        return self.start + distance * pos

    def tangent(self, pos):
        return self.end - self.start

    def length(self, error=None, min_depth=None):
        distance = self.end - self.start
        return sqrt(distance.real**2 + distance.imag**2)


class Line(Linear):
    def __init__(self, start, end, relative=False, vertical=False, horizontal=False):
        self.start = start
        self.end = end
        self.relative = relative
        self.vertical = vertical
        self.horizontal = horizontal

    def __repr__(self):
        return f"Line(start={self.start}, end={self.end})"

    def __eq__(self, other):
        if not isinstance(other, Line):
            return NotImplemented
        return self.start == other.start and self.end == other.end

    def _d(self, previous):
        x = self.end.real
        y = self.end.imag
        if self.relative:
            x -= previous.end.real
            y -= previous.end.imag

        if self.horizontal and self.is_horizontal_from(previous):
            cmd = "h" if self.relative else "H"
            return f"{cmd} {x:G},{y:G}"

        if self.vertical and self.is_vertical_from(previous):
            cmd = "v" if self.relative else "V"
            return f"{cmd} {y:G}"

        cmd = "l" if self.relative else "L"
        return f"{cmd} {x:G},{y:G}"

    def is_vertical_from(self, previous):
        return self.start == previous.end and self.start.real == self.end.real

    def is_horizontal_from(self, previous):
        return self.start == previous.end and self.start.imag == self.end.imag


class CubicBezier(NonLinear):
    def __init__(self, start, control1, control2, end, relative=False, smooth=False):
        self.start = start
        self.control1 = control1
        self.control2 = control2
        self.end = end
        self.relative = relative
        self.smooth = smooth

    def __repr__(self):
        return (
            f"CubicBezier(start={self.start}, control1={self.control1}, "
            f"control2={self.control2}, end={self.end}, smooth={self.smooth})"
        )

    def __eq__(self, other):
        if not isinstance(other, CubicBezier):
            return NotImplemented
        return (
            self.start == other.start
            and self.end == other.end
            and self.control1 == other.control1
            and self.control2 == other.control2
        )

    def __ne__(self, other):
        if not isinstance(other, CubicBezier):
            return NotImplemented
        return not self == other

    def _d(self, previous):
        c1 = self.control1
        c2 = self.control2
        end = self.end

        if self.relative and previous:
            c1 -= previous.end
            c2 -= previous.end
            end -= previous.end

        if self.smooth and self.is_smooth_from(previous):
            cmd = "s" if self.relative else "S"
            return f"{cmd} {c2.real:G},{c2.imag:G} {end.real:G},{end.imag:G}"

        cmd = "c" if self.relative else "C"
        return f"{cmd} {c1.real:G},{c1.imag:G} {c2.real:G},{c2.imag:G} {end.real:G},{end.imag:G}"

    def is_smooth_from(self, previous):
        """Checks if this segment would be a smooth segment following the previous"""
        if isinstance(previous, CubicBezier):
            return self.start == previous.end and (self.control1 - self.start) == (
                previous.end - previous.control2
            )
        else:
            return self.control1 == self.start

    def set_smooth_from(self, previous):
        assert isinstance(previous, CubicBezier)
        self.start = previous.end
        self.control1 = previous.end - previous.control2 + self.start
        self.smooth = True

    def point(self, pos):
        """Calculate the x,y position at a certain position of the path"""
        return (
            ((1 - pos) ** 3 * self.start)
            + (3 * (1 - pos) ** 2 * pos * self.control1)
            + (3 * (1 - pos) * pos**2 * self.control2)
            + (pos**3 * self.end)
        )

    def tangent(self, pos):
        return (
            -3 * (1 - pos) ** 2 * self.start
            + 3 * (1 - pos) ** 2 * self.control1
            - 6 * pos * (1 - pos) * self.control1
            - 3 * pos**2 * self.control2
            + 6 * pos * (1 - pos) * self.control2
            + 3 * pos**2 * self.end
        )

    def length(self, error=ERROR, min_depth=MIN_DEPTH):
        """Calculate the length of the path up to a certain position"""
        start_point = self.point(0)
        end_point = self.point(1)
        return segment_length(self, 0, 1, start_point, end_point, error, min_depth, 0)


class QuadraticBezier(NonLinear):
    def __init__(self, start, control, end, relative=False, smooth=False):
        self.start = start
        self.end = end
        self.control = control
        self.relative = relative
        self.smooth = smooth

    def __repr__(self):
        return (
            f"QuadraticBezier(start={self.start}, control={self.control}, "
            f"end={self.end}, smooth={self.smooth})"
        )

    def __eq__(self, other):
        if not isinstance(other, QuadraticBezier):
            return NotImplemented
        return (
            self.start == other.start
            and self.end == other.end
            and self.control == other.control
        )

    def __ne__(self, other):
        if not isinstance(other, QuadraticBezier):
            return NotImplemented
        return not self == other

    def _d(self, previous):
        control = self.control
        end = self.end
        if self.relative and previous:
            control -= previous.end
            end -= previous.end

        if self.smooth and self.is_smooth_from(previous):
            cmd = "t" if self.relative else "T"
            return f"{cmd} {end.real:G},{end.imag:G}"

        cmd = "q" if self.relative else "Q"
        return f"{cmd} {control.real:G},{control.imag:G} {end.real:G},{end.imag:G}"

    def is_smooth_from(self, previous):
        """Checks if this segment would be a smooth segment following the previous"""
        if isinstance(previous, QuadraticBezier):
            return self.start == previous.end and (self.control - self.start) == (
                previous.end - previous.control
            )
        else:
            return self.control == self.start

    def set_smooth_from(self, previous):
        assert isinstance(previous, QuadraticBezier)
        self.start = previous.end
        self.control = previous.end - previous.control + self.start
        self.smooth = True

    def point(self, pos):
        return (
            (1 - pos) ** 2 * self.start
            + 2 * (1 - pos) * pos * self.control
            + pos**2 * self.end
        )

    def tangent(self, pos):
        return (
            self.start * (2 * pos - 2)
            + (2 * self.end - 4 * self.control) * pos
            + 2 * self.control
        )

    def length(self, error=None, min_depth=None):
        a = self.start - 2 * self.control + self.end
        b = 2 * (self.control - self.start)

        try:
            # For an explanation of this case, see
            # http://www.malczak.info/blog/quadratic-bezier-curve-length/
            A = 4 * (a.real**2 + a.imag**2)
            B = 4 * (a.real * b.real + a.imag * b.imag)
            C = b.real**2 + b.imag**2

            Sabc = 2 * sqrt(A + B + C)
            A2 = sqrt(A)
            A32 = 2 * A * A2
            C2 = 2 * sqrt(C)
            BA = B / A2

            s = (
                A32 * Sabc
                + A2 * B * (Sabc - C2)
                + (4 * C * A - B**2) * log((2 * A2 + BA + Sabc) / (BA + C2))
            ) / (4 * A32)
        except (ZeroDivisionError, ValueError):
            if abs(a) < 1e-10:
                s = abs(b)
            else:
                k = abs(b) / abs(a)
                if k >= 2:
                    s = abs(b) - abs(a)
                else:
                    s = abs(a) * (k**2 / 2 - k + 1)
        return s


class Arc(NonLinear):
    def __init__(self, start, radius, rotation, arc, sweep, end, relative=False):
        """radius is complex, rotation is in degrees,
        large and sweep are 1 or 0 (True/False also work)"""

        self.start = start
        self.radius = radius
        self.rotation = rotation
        self.arc = bool(arc)
        self.sweep = bool(sweep)
        self.end = end
        self.relative = relative

        self._parameterize()

    def __repr__(self):
        return (
            f"Arc(start={self.start}, radius={self.radius}, rotation={self.rotation}, "
            f"arc={self.arc}, sweep={self.sweep}, end={self.end})"
        )

    def __eq__(self, other):
        if not isinstance(other, Arc):
            return NotImplemented
        return (
            self.start == other.start
            and self.end == other.end
            and self.radius == other.radius
            and self.rotation == other.rotation
            and self.arc == other.arc
            and self.sweep == other.sweep
        )

    def __ne__(self, other):
        if not isinstance(other, Arc):
            return NotImplemented
        return not self == other

    def _d(self, previous):
        end = self.end
        cmd = "a" if self.relative else "A"
        if self.relative:
            end -= previous.end

        return (
            f"{cmd} {self.radius.real:G},{self.radius.imag:G} {self.rotation:G} "
            f"{int(self.arc):d},{int(self.sweep):d} {end.real:G},{end.imag:G}"
        )

    def _parameterize(self):
        # Conversion from endpoint to center parameterization
        # http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
        if self.start == self.end:
            # This is equivalent of omitting the segment, so do nothing
            return

        if self.radius.real == 0 or self.radius.imag == 0:
            # This should be treated as a straight line
            return

        cosr = cos(radians(self.rotation))
        sinr = sin(radians(self.rotation))
        dx = (self.start.real - self.end.real) / 2
        dy = (self.start.imag - self.end.imag) / 2
        x1prim = cosr * dx + sinr * dy
        x1prim_sq = x1prim * x1prim
        y1prim = -sinr * dx + cosr * dy
        y1prim_sq = y1prim * y1prim

        rx = self.radius.real
        rx_sq = rx * rx
        ry = self.radius.imag
        ry_sq = ry * ry

        # Correct out of range radii
        radius_scale = (x1prim_sq / rx_sq) + (y1prim_sq / ry_sq)
        if radius_scale > 1:
            radius_scale = sqrt(radius_scale)
            rx *= radius_scale
            ry *= radius_scale
            rx_sq = rx * rx
            ry_sq = ry * ry
            self.radius_scale = radius_scale
        else:
            # SVG spec only scales UP
            self.radius_scale = 1

        t1 = rx_sq * y1prim_sq
        t2 = ry_sq * x1prim_sq
        c = sqrt(abs((rx_sq * ry_sq - t1 - t2) / (t1 + t2)))

        if self.arc == self.sweep:
            c = -c
        cxprim = c * rx * y1prim / ry
        cyprim = -c * ry * x1prim / rx

        self.center = complex(
            (cosr * cxprim - sinr * cyprim) + ((self.start.real + self.end.real) / 2),
            (sinr * cxprim + cosr * cyprim) + ((self.start.imag + self.end.imag) / 2),
        )

        ux = (x1prim - cxprim) / rx
        uy = (y1prim - cyprim) / ry
        vx = (-x1prim - cxprim) / rx
        vy = (-y1prim - cyprim) / ry
        n = sqrt(ux * ux + uy * uy)
        p = ux
        theta = degrees(acos(p / n))
        if uy < 0:
            theta = -theta
        self.theta = theta % 360

        n = sqrt((ux * ux + uy * uy) * (vx * vx + vy * vy))
        p = ux * vx + uy * vy
        d = p / n
        # In certain cases the above calculation can through inaccuracies
        # become just slightly out of range, f ex -1.0000000000000002.
        if d > 1.0:
            d = 1.0
        elif d < -1.0:
            d = -1.0
        delta = degrees(acos(d))
        if (ux * vy - uy * vx) < 0:
            delta = -delta
        self.delta = delta % 360
        if not self.sweep:
            self.delta -= 360

    def point(self, pos):
        if self.start == self.end:
            # This is equivalent of omitting the segment
            return self.start

        if self.radius.real == 0 or self.radius.imag == 0:
            # This should be treated as a straight line
            distance = self.end - self.start
            return self.start + distance * pos

        angle = radians(self.theta + (self.delta * pos))
        cosr = cos(radians(self.rotation))
        sinr = sin(radians(self.rotation))
        radius = self.radius * self.radius_scale

        x = (
            cosr * cos(angle) * radius.real
            - sinr * sin(angle) * radius.imag
            + self.center.real
        )
        y = (
            sinr * cos(angle) * radius.real
            + cosr * sin(angle) * radius.imag
            + self.center.imag
        )
        return complex(x, y)

    def tangent(self, pos):
        angle = radians(self.theta + (self.delta * pos))
        cosr = cos(radians(self.rotation))
        sinr = sin(radians(self.rotation))
        radius = self.radius * self.radius_scale

        x = cosr * cos(angle) * radius.real - sinr * sin(angle) * radius.imag
        y = sinr * cos(angle) * radius.real + cosr * sin(angle) * radius.imag
        return complex(x, y) * complex(0, 1)

    def length(self, error=ERROR, min_depth=MIN_DEPTH):
        """The length of an elliptical arc segment requires numerical
        integration, and in that case it's simpler to just do a geometric
        approximation, as for cubic bezier curves.
        """
        if self.start == self.end:
            # This is equivalent of omitting the segment
            return 0

        if self.radius.real == 0 or self.radius.imag == 0:
            # This should be treated as a straight line
            distance = self.end - self.start
            return sqrt(distance.real**2 + distance.imag**2)

        if self.radius.real == self.radius.imag:
            # It's a circle, which simplifies this a LOT.
            radius = self.radius.real * self.radius_scale
            return abs(radius * self.delta * pi / 180)

        start_point = self.point(0)
        end_point = self.point(1)
        return segment_length(self, 0, 1, start_point, end_point, error, min_depth, 0)


class Move:
    """Represents move commands. Does nothing, but is there to handle
    paths that consist of only move commands, which is valid, but pointless.
    """

    def __init__(self, to, relative=False):
        self.start = self.end = to
        self.relative = relative

    def __repr__(self):
        return "Move(to=%s)" % self.start

    def __eq__(self, other):
        if not isinstance(other, Move):
            return NotImplemented
        return self.start == other.start

    def __ne__(self, other):
        if not isinstance(other, Move):
            return NotImplemented
        return not self == other

    def _d(self, previous):
        cmd = "M"
        x = self.end.real
        y = self.end.imag
        if self.relative:
            cmd = "m"
            if previous:
                x -= previous.end.real
                y -= previous.end.imag
        return f"{cmd} {x:G},{y:G}"

    def point(self, pos):
        return self.start

    def tangent(self, pos):
        return 0

    def length(self, error=ERROR, min_depth=MIN_DEPTH):
        return 0


class Close(Linear):
    """Represents the closepath command"""

    def __eq__(self, other):
        if not isinstance(other, Close):
            return NotImplemented
        return self.start == other.start and self.end == other.end

    def __repr__(self):
        return f"Close(start={self.start}, end={self.end})"

    def _d(self, previous):
        return "z" if self.relative else "Z"


class Path(MutableSequence):
    """A Path is a sequence of path segments"""

    def __init__(self, *segments):
        self._segments = list(segments)
        self._length = None
        self._lengths = None
        # Fractional distance from starting point through the end of each segment.
        self._fractions = []

    def __getitem__(self, index):
        return self._segments[index]

    def __setitem__(self, index, value):
        self._segments[index] = value
        self._length = None

    def __delitem__(self, index):
        del self._segments[index]
        self._length = None

    def insert(self, index, value):
        self._segments.insert(index, value)
        self._length = None

    def reverse(self):
        # Reversing the order of a path would require reversing each element
        # as well. That's not implemented.
        raise NotImplementedError

    def __len__(self):
        return len(self._segments)

    def __repr__(self):
        return "Path(%s)" % (", ".join(repr(x) for x in self._segments))

    def __eq__(self, other):

        if not isinstance(other, Path):
            return NotImplemented
        if len(self) != len(other):
            return False
        for s, o in zip(self._segments, other._segments):
            if not s == o:
                return False
        return True

    def __ne__(self, other):
        if not isinstance(other, Path):
            return NotImplemented
        return not self == other

    def _calc_lengths(self, error=ERROR, min_depth=MIN_DEPTH):
        if self._length is not None:
            return

        lengths = [
            each.length(error=error, min_depth=min_depth) for each in self._segments
        ]
        self._length = sum(lengths)
        if self._length == 0:
            self._lengths = lengths
        else:
            self._lengths = [each / self._length for each in lengths]
        # Calculate the fractional distance for each segment to use in point()
        fraction = 0
        for each in self._lengths:
            fraction += each
            self._fractions.append(fraction)

    def _find_segment(self, pos, error=ERROR):
        # Shortcuts
        if pos == 0.0:
            return self._segments[0], pos
        if pos == 1.0:
            return self._segments[-1], pos

        self._calc_lengths(error=error)

        # Fix for paths of length 0 (i.e. points)
        if self._length == 0:
            return self._segments[0], 0.0

        # Find which segment the point we search for is located on:
        i = bisect(self._fractions, pos)
        if i == 0:
            segment_pos = pos / self._fractions[0]
        else:
            segment_pos = (pos - self._fractions[i - 1]) / (
                self._fractions[i] - self._fractions[i - 1]
            )
        return self._segments[i], segment_pos

    def point(self, pos, error=ERROR):
        segment, pos = self._find_segment(pos, error)
        return segment.point(pos)

    def tangent(self, pos, error=ERROR):
        segment, pos = self._find_segment(pos, error)
        return segment.tangent(pos)

    def length(self, error=ERROR, min_depth=MIN_DEPTH):
        self._calc_lengths(error, min_depth)
        return self._length

    def d(self):
        parts = []
        previous_segment = None

        for segment in self:
            parts.append(segment._d(previous_segment))
            previous_segment = segment

        return " ".join(parts)


COMMANDS = set("MmZzLlHhVvCcSsQqTtAa")
UPPERCASE = set("MZLHVCSQTA")

COMMAND_RE = re.compile(r"([MmZzLlHhVvCcSsQqTtAa])")
FLOAT_RE = re.compile(rb"^[-+]?\d*\.?\d*(?:[eE][-+]?\d+)?")


class InvalidPathError(ValueError):
    pass


# The argument sequences from the grammar, made sane.
# u: Non-negative number
# s: Signed number or coordinate
# c: coordinate-pair, which is two coordinates/numbers, separated by whitespace
# f: A one character flag, doesn't need whitespace, 1 or 0
ARGUMENT_SEQUENCE = {
    "M": "c",
    "Z": "",
    "L": "c",
    "H": "s",
    "V": "s",
    "C": "ccc",
    "S": "cc",
    "Q": "cc",
    "T": "c",
    "A": "uusffc",
}


def strip_array(arg_array):
    """Strips whitespace and commas"""
    # EBNF wsp:(#x20 | #x9 | #xD | #xA) + comma: 0x2C
    while arg_array and arg_array[0] in (0x20, 0x9, 0xD, 0xA, 0x2C):
        arg_array[0:1] = b""


def pop_number(arg_array):
    res = FLOAT_RE.search(arg_array)
    if not res or not res.group():
        raise InvalidPathError(f"Expected a number, got '{arg_array}'.")
    number = float(res.group())
    start = res.start()
    end = res.end()
    arg_array[start:end] = b""
    strip_array(arg_array)

    return number


def pop_unsigned_number(arg_array):
    number = pop_number(arg_array)
    if number < 0:
        raise InvalidPathError(f"Expected a non-negative number, got '{number}'.")
    return number


def pop_coordinate_pair(arg_array):
    x = pop_number(arg_array)
    y = pop_number(arg_array)
    return complex(x, y)


def pop_flag(arg_array):
    flag = arg_array[0]
    arg_array[0:1] = b""
    strip_array(arg_array)
    if flag == 48:  # ASCII 0
        return False
    if flag == 49:  # ASCII 1
        return True


FIELD_POPPERS = {
    "u": pop_unsigned_number,
    "s": pop_number,
    "c": pop_coordinate_pair,
    "f": pop_flag,
}


def _commandify_path(pathdef):
    """Splits path into commands and arguments"""
    token = None
    for x in COMMAND_RE.split(pathdef):
        x = x.strip()
        if x in COMMANDS:
            if token is not None:
                yield token
            if x in ("z", "Z"):
                # The end command takes no arguments, so add a blank one
                token = (x, "")
            else:
                token = (x,)
        elif x:
            if token is None:
                raise InvalidPathError(f"Path does not start with a command: {pathdef}")
            token += (x,)
    yield token


def _tokenize_path(pathdef):
    for command, args in _commandify_path(pathdef):
        # Shortcut this for the close command, that doesn't have arguments:
        if command in ("z", "Z"):
            yield (command,)
            continue

        # For the rest of the commands, we parse the arguments and
        # yield one command per full set of arguments
        arg_sequence = ARGUMENT_SEQUENCE[command.upper()]
        arguments = bytearray(args, "ascii")
        implicit = False
        while arguments:
            command_arguments = []
            for i, arg in enumerate(arg_sequence):
                try:
                    command_arguments.append(FIELD_POPPERS[arg](arguments))
                except InvalidPathError as e:
                    if i == 0 and implicit:
                        return  # Invalid character in path, treat like a comment
                    raise InvalidPathError(
                        f"Invalid path element {command} {args}"
                    ) from e

            yield (command,) + tuple(command_arguments)
            implicit = True

            # Implicit Moveto commands should be treated as Lineto commands.
            if command == "m":
                command = "l"
            elif command == "M":
                command = "L"


def parse_path(pathdef):
    segments = path.Path()
    start_pos = None
    last_command = None
    current_pos = 0

    for token in _tokenize_path(pathdef):
        command = token[0]
        relative = command.islower()
        command = command.upper()
        if command == "M":
            pos = token[1]
            if relative:
                current_pos += pos
            else:
                current_pos = pos
            segments.append(path.Move(current_pos, relative=relative))
            start_pos = current_pos

        elif command == "Z":
            # For Close commands the "relative" argument just preserves case,
            # it has no different in behavior.
            segments.append(path.Close(current_pos, start_pos, relative=relative))
            current_pos = start_pos

        elif command == "L":
            pos = token[1]
            if relative:
                pos += current_pos
            segments.append(path.Line(current_pos, pos, relative=relative))
            current_pos = pos

        elif command == "H":
            hpos = token[1]
            if relative:
                hpos += current_pos.real
            pos = complex(hpos, current_pos.imag)
            segments.append(
                path.Line(current_pos, pos, relative=relative, horizontal=True)
            )
            current_pos = pos

        elif command == "V":
            vpos = token[1]
            if relative:
                vpos += current_pos.imag
            pos = complex(current_pos.real, vpos)
            segments.append(
                path.Line(current_pos, pos, relative=relative, vertical=True)
            )
            current_pos = pos

        elif command == "C":
            control1 = token[1]
            control2 = token[2]
            end = token[3]

            if relative:
                control1 += current_pos
                control2 += current_pos
                end += current_pos

            segments.append(
                path.CubicBezier(
                    current_pos, control1, control2, end, relative=relative
                )
            )
            current_pos = end

        elif command == "S":
            # Smooth curve. First control point is the "reflection" of
            # the second control point in the previous path.
            control2 = token[1]
            end = token[2]

            if relative:
                control2 += current_pos
                end += current_pos

            if last_command in "CS":
                # The first control point is assumed to be the reflection of
                # the second control point on the previous command relative
                # to the current point.
                control1 = current_pos + current_pos - segments[-1].control2
            else:
                # If there is no previous command or if the previous command
                # was not an C, c, S or s, assume the first control point is
                # coincident with the current point.
                control1 = current_pos

            segments.append(
                path.CubicBezier(
                    current_pos, control1, control2, end, relative=relative, smooth=True
                )
            )
            current_pos = end

        elif command == "Q":
            control = token[1]
            end = token[2]

            if relative:
                control += current_pos
                end += current_pos

            segments.append(
                path.QuadraticBezier(current_pos, control, end, relative=relative)
            )
            current_pos = end

        elif command == "T":
            # Smooth curve. Control point is the "reflection" of
            # the second control point in the previous path.
            end = token[1]

            if relative:
                end += current_pos

            if last_command in "QT":
                # The control point is assumed to be the reflection of
                # the control point on the previous command relative
                # to the current point.
                control = current_pos + current_pos - segments[-1].control
            else:
                # If there is no previous command or if the previous command
                # was not an Q, q, T or t, assume the first control point is
                # coincident with the current point.
                control = current_pos

            segments.append(
                path.QuadraticBezier(
                    current_pos, control, end, smooth=True, relative=relative
                )
            )
            current_pos = end

        elif command == "A":
            # For some reason I implemented the Arc with a complex radius.
            # That doesn't really make much sense, but... *shrugs*
            radius = complex(token[1], token[2])
            rotation = token[3]
            arc = token[4]
            sweep = token[5]
            end = token[6]

            if relative:
                end += current_pos

            segments.append(
                path.Arc(
                    current_pos, radius, rotation, arc, sweep, end, relative=relative
                )
            )
            current_pos = end

        # Finish up the loop in preparation for next command
        last_command = command

    return segments


sqrt2 = math.sqrt(2)


# Hierachie:
# point 2D
# line 2D
# PolyCurve2D 2D
# profile is een parametrische vorm heeft als resultaat een 2D curve
# section is een profiel met eigenschappen HEA200, 200,200,10,10,5 en eventuele rekenkundige eigenschappen.
# beam is een object wat in 3D zit met materiaal enz.

class Profile(Serializable):

    def __init__(self, name: str, description: str, IFC_profile_def: str, height: float, width: float,
                 tw: float = None, tf: float = None):
        """Creates a profile profile.

        Args:
            name (str): _description_
            description (str): _description_
            IFC_profile_def (str): _description_
            height (_type_): _description_
            width (_type_): _description_
        """

        self.IFC_profile_def = IFC_profile_def
        
        self.name = name
        self.description = description
        self.curve = []
        self.height = height
        self.width = width
        self.tw = tw
        self.tf = tf
        self.type = None

    def __str__(self):
        return f"{self.type} ({self.name})"

class CChannelParallelFlange(Profile):
    def __init__(self, name, height, width, tw, tf, r, ex):
        super().__init__(name, "C-channel with parallel flange", "IfcUShapeProfileDef", height, width, tw, tf)

        # parameters
        self.type = __class__.__name__

        self.r1 = r  # web fillet
        self.ex = ex  # centroid horizontal

        # describe points
        p1 = Point(-ex, -height / 2)  # left bottom
        p2 = Point(width - ex, -height / 2)  # right bottom
        p3 = Point(width - ex, -height / 2 + tf)
        p4 = Point(-ex + tw + r, -height / 2 + tf)  # start arc
        p5 = Point(-ex + tw + r, -height / 2 + tf + r)  # second point arc
        p6 = Point(-ex + tw, -height / 2 + tf + r)  # end arc
        p7 = Point(-ex + tw, height / 2 - tf - r)  # start arc
        p8 = Point(-ex + tw + r, height / 2 - tf - r)  # second point arc
        p9 = Point(-ex + tw + r, height / 2 - tf)  # end arc
        p10 = Point(width - ex, height / 2 - tf)
        p11 = Point(width - ex, height / 2)  # right top
        p12 = Point(-ex, height / 2)  # left top

        # describe curves
        l1 = Line(p1, p2)
        l2 = Line(p2, p3)
        l3 = Line(p3, p4)
        l4 = Arc2D(p4, p5, p6)
        l5 = Line(p6, p7)
        l6 = Arc2D(p7, p8, p9)
        l7 = Line(p9, p10)
        l8 = Line(p10, p11)
        l9 = Line(p11, p12)
        l10 = Line(p12, p1)

        self.curve = PolyCurve.by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10])

class CChannelSlopedFlange(Profile):
    def __init__(self, name, height, width, tw, tf, r1, r2, tl, sa, ex):
        super().__init__(name, "C-channel with sloped flange", "IfcUShapeProfileDef", height, width, tw, tf)

        self.r1 = r1  # web fillet
        r11 = r1 / sqrt2
        self.r2 = r2  # flange fillet
        r21 = r2 / sqrt2
        self.tl = tl  # flange thickness location from right
        self.sa = math.radians(sa)  # the angle of sloped flange in degrees
        self.ex = ex  # centroid horizontal

        # describe points
        p1 = Point2D(-ex, -height / 2)  # left bottom
        p2 = Point2D(width - ex, -height / 2)  # right bottom
        p3 = Point2D(width - ex, -height / 2 + tf - math.tan(self.sa)
                     * tl - r2)  # start arc
        p4 = Point2D(width - ex - r2 + r21, -height / 2 + tf -
                     math.tan(self.sa) * tl - r2 + r21)  # second point arc
        p5 = Point2D(width - ex - r2 + math.sin(self.sa) * r2, -height /
                     2 + tf - math.tan(self.sa) * (tl - r2))  # end arc
        p6 = Point2D(-ex + tw + r1 - math.sin(self.sa) * r1, -height / 2 +
                     tf + math.tan(self.sa) * (width - tl - tw - r1))  # start arc
        p7 = Point2D(-ex + tw + r1 - r11, -height / 2 + tf + math.tan(self.sa)
                     * (width - tl - tw - r1) + r1 - r11)  # second point arc
        p8 = Point2D(-ex + tw, -height / 2 + tf + math.tan(self.sa)
                     * (width - tl - tw) + r1)  # end arc
        p9 = Point2D(p8.x, -p8.y)  # start arc
        p10 = Point2D(p7.x, -p7.y)  # second point arc
        p11 = Point2D(p6.x, -p6.y)  # end arc
        p12 = Point2D(p5.x, -p5.y)  # start arc
        p13 = Point2D(p4.x, -p4.y)  # second point arc
        p14 = Point2D(p3.x, -p3.y)  # end arc
        p15 = Point2D(p2.x, -p2.y)  # right top
        p16 = Point2D(p1.x, -p1.y)  # left top

        # describe curves
        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Arc2D(p3, p4, p5)
        l4 = Line2D(p5, p6)
        l5 = Arc2D(p6, p7, p8)
        l6 = Line2D(p8, p9)
        l7 = Arc2D(p9, p10, p11)
        l8 = Line2D(p11, p12)
        l9 = Arc2D(p12, p13, p14)
        l10 = Line2D(p14, p15)
        l11 = Line2D(p15, p16)
        l12 = Line2D(p16, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12])

class IShapeParallelFlange(Profile):
    def __init__(self, name, height, width, tw, tf, r):
        super().__init__(name, "I Shape profile with parallel flange", "IfcUShapeProfileDef", height, width, tw,
                         tf)


        self.r = r  # web fillet
        self.r1 = r1 = r / sqrt2

        # describe points
        p1 = Point2D(width / 2, -height / 2)  # right bottom
        p2 = Point2D(width / 2, -height / 2 + tf)
        p3 = Point2D(tw / 2 + r, -height / 2 + tf)  # start arc
        # second point arc
        p4 = Point2D(tw / 2 + r - r1, (-height / 2 + tf + r - r1))
        p5 = Point2D(tw / 2, -height / 2 + tf + r)  # end arc
        p6 = Point2D(tw / 2, height / 2 - tf - r)  # start arc
        p7 = Point2D(tw / 2 + r - r1, height / 2 - tf - r + r1)  # second point arc
        p8 = Point2D(tw / 2 + r, height / 2 - tf)  # end arc
        p9 = Point2D(width / 2, height / 2 - tf)
        p10 = Point2D((width / 2), (height / 2))  # right top
        p11 = Point2D(-p10.x, p10.y)  # left top
        p12 = Point2D(-p9.x, p9.y)
        p13 = Point2D(-p8.x, p8.y)  # start arc
        p14 = Point2D(-p7.x, p7.y)  # second point arc
        p15 = Point2D(-p6.x, p6.y)  # end arc
        p16 = Point2D(-p5.x, p5.y)  # start arc
        p17 = Point2D(-p4.x, p4.y)  # second point arc
        p18 = Point2D(-p3.x, p3.y)  # end arc
        p19 = Point2D(-p2.x, p2.y)
        p20 = Point2D(-p1.x, p1.y)

        # describe curves
        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Arc2D(p3, p4, p5)
        l4 = Line2D(p5, p6)
        l5 = Arc2D(p6, p7, p8)
        l6 = Line2D(p8, p9)
        l7 = Line2D(p9, p10)
        l8 = Line2D(p10, p11)
        l9 = Line2D(p11, p12)
        l10 = Line2D(p12, p13)
        l11 = Arc2D(p13, p14, p15)
        l12 = Line2D(p15, p16)
        l13 = Arc2D(p16, p17, p18)
        l14 = Line2D(p18, p19)
        l15 = Line2D(p19, p20)
        l16 = Line2D(p20, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16])

class Rectangle(Profile):
    def __init__(self, name, width, height):
        super().__init__(name, "Rectangle", "IfcRectangleProfileDef", height, width)


        # describe points
        p1 = Point2D(width / 2, -height / 2)  # right bottom
        p2 = Point2D(width / 2, height / 2)  # right top
        p3 = Point2D(-width / 2, height / 2)  # left top
        p4 = Point2D(-width / 2, -height / 2)  # left bottom

        # describe curves
        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Line2D(p3, p4)
        l4 = Line2D(p4, p1)

        self.curve = PolyCurve2D().by_joined_curves([l1, l2, l3, l4])

class Round(Profile):
    def __init__(self, name, r):
        super().__init__(name, "Round", "IfcCircleProfileDef", r*2, r*2)

        self.r = r

        dr = r / sqrt2  # grootste deel

        # describe points
        p1 = Point2D(r, 0)  # right middle
        p2 = Point2D(dr, dr)
        p3 = Point2D(0, r)  # middle top
        p4 = Point2D(-dr, dr)
        p5 = Point2D(-r, 0)  # left middle
        p6 = Point2D(-dr, -dr)
        p7 = Point2D(0, -r)  # middle bottom
        p8 = Point2D(dr, -dr)

        # describe curves
        l1 = Arc2D(p1, p2, p3)
        l2 = Arc2D(p3, p4, p5)
        l3 = Arc2D(p5, p6, p7)
        l4 = Arc2D(p7, p8, p1)

        self.curve = PolyCurve2D().by_joined_curves([l1, l2, l3, l4])

class Roundtube(Profile):
    def __init__(self, name, d, t):
        super().__init__(name, "Round Tube Profile", "IfcCircleHollowProfileDef", d, d)

        # parameters
        self.type = __class__.__name__
        self.r = d / 2
        self.d = d
        self.t = t  # wall thickness
        dr = self.r / sqrt2  # grootste deel
        r = self.r
        ri = r - t
        dri = ri / sqrt2

        # describe points
        p1 = Point2D(r, 0)  # right middle
        p2 = Point2D(dr, dr)
        p3 = Point2D(0, r)  # middle top
        p4 = Point2D(-dr, dr)
        p5 = Point2D(-r, 0)  # left middle
        p6 = Point2D(-dr, -dr)
        p7 = Point2D(0, -r)  # middle bottom
        p8 = Point2D(dr, -dr)

        p9 = Point2D(ri, 0)  # right middle inner
        p10 = Point2D(dri, dri)
        p11 = Point2D(0, ri)  # middle top inner
        p12 = Point2D(-dri, dri)
        p13 = Point2D(-ri, 0)  # left middle inner
        p14 = Point2D(-dri, -dri)
        p15 = Point2D(0, -ri)  # middle bottom inner
        p16 = Point2D(dri, -dri)

        # describe curves
        l1 = Arc2D(p1, p2, p3)
        l2 = Arc2D(p3, p4, p5)
        l3 = Arc2D(p5, p6, p7)
        l4 = Arc2D(p7, p8, p1)

        l5 = Line2D(p1, p9)

        l6 = Arc2D(p9, p10, p11)
        l7 = Arc2D(p11, p12, p13)
        l8 = Arc2D(p13, p14, p15)
        l9 = Arc2D(p15, p16, p9)
        l10 = Line2D(p9, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10])

class LAngle(Profile):
    def __init__(self, name, height, width, tw, tf, r1, r2, ex, ey):
        super().__init__(name, "LAngle", "IfcLShapeProfileDef", height, width, tw, tf)

        # parameters
        self.type = __class__.__name__

        self.r1 = r1  # inner fillet
        r11 = r1 / sqrt2
        self.r2 = r2  # outer fillet
        r21 = r2 / sqrt2
        self.ex = ex  # from left
        self.ey = ey  # from bottom

        # describe points
        p1 = Point2D(-ex, -ey)  # left bottom
        p2 = Point2D(width - ex, -ey)  # right bottom
        p3 = Point2D(width - ex, -ey + tf - r2)  # start arc
        p4 = Point2D(width - ex - r2 + r21, -ey + tf -
                     r2 + r21)  # second point arc
        p5 = Point2D(width - ex - r2, -ey + tf)  # end arc
        p6 = Point2D(-ex + tf + r1, -ey + tf)  # start arc
        p7 = Point2D(-ex + tf + r1 - r11, -ey + tf +
                     r1 - r11)  # second point arc
        p8 = Point2D(-ex + tf, -ey + tf + r1)  # end arc
        p9 = Point2D(-ex + tf, height - ey - r2)  # start arc
        p10 = Point2D(-ex + tf - r2 + r21, height - ey -
                      r2 + r21)  # second point arc
        p11 = Point2D(-ex + tf - r2, height - ey)  # end arc
        p12 = Point2D(-ex, height - ey)  # left top

        # describe curves
        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Arc2D(p3, p4, p5)
        l4 = Line2D(p5, p6)
        l5 = Arc2D(p6, p7, p8)
        l6 = Line2D(p8, p9)
        l7 = Arc2D(p9, p10, p11)
        l8 = Line2D(p11, p12)
        l9 = Line2D(p12, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9])

class TProfileRounded(Profile):
    # ToDo: inner outer fillets in polycurve
    def __init__(self, name, height, width, tw, tf, r, r1, r2, ex, ey):
        super().__init__(name, "TProfile", "IfcTShapeProfileDef", height, width, tw, tf)


        self.r = r  # inner fillet
        self.r01 = r / sqrt2
        self.r1 = r1  # outer fillet flange
        r11 = r1 / sqrt2
        self.r2 = r2  # outer fillet top web
        r21 = r2 / sqrt2
        self.ex = ex  # from left
        self.ey = ey  # from bottom

        # describe points
        p1 = Point2D(-ex, -ey)  # left bottom
        p2 = Point2D(width - ex, -ey)  # right bottom
        p3 = Point2D(width - ex, -ey + tf - r1)  # start arc
        p4 = Point2D(width - ex - r1 + r11, -ey + tf -
                     r1 + r11)  # second point arc
        p5 = Point2D(width - ex - r1, -ey + tf)  # end arc
        p6 = Point2D(0.5 * tw + r, -ey + tf)  # start arc
        p7 = Point2D(0.5 * tw + r - self.r01, -ey + tf +
                     r - self.r01)  # second point arc
        p8 = Point2D(0.5 * tw, -ey + tf + r)  # end arc
        p9 = Point2D(0.5 * tw, -ey + height - r2)  # start arc
        p10 = Point2D(0.5 * tw - r21, -ey + height -
                      r2 + r21)  # second point arc
        p11 = Point2D(0.5 * tw - r2, -ey + height)  # end arc

        p12 = Point2D(-p11.x, p11.y)
        p13 = Point2D(-p10.x, p10.y)
        p14 = Point2D(-p9.x, p9.y)
        p15 = Point2D(-p8.x, p8.y)
        p16 = Point2D(-p7.x, p7.y)
        p17 = Point2D(-p6.x, p6.y)
        p18 = Point2D(-p5.x, p5.y)
        p19 = Point2D(-p4.x, p4.y)
        p20 = Point2D(-p3.x, p3.y)

        # describe curves
        l1 = Line2D(p1, p2)

        l2 = Line2D(p2, p3)
        l3 = Arc2D(p3, p4, p5)
        l4 = Line2D(p5, p6)
        l5 = Arc2D(p6, p7, p8)
        l6 = Line2D(p8, p9)
        l7 = Arc2D(p9, p10, p11)
        l8 = Line2D(p11, p12)

        l9 = Arc2D(p12, p13, p14)
        l10 = Line2D(p14, p15)
        l11 = Arc2D(p15, p16, p17)
        l12 = Line2D(p17, p18)
        l13 = Arc2D(p18, p19, p20)
        l14 = Line2D(p20, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14])

class RectangleHollowSection(Profile):
    def __init__(self, name, height, width, t, r1, r2):
        super().__init__(name, "Rectangle Hollow Section", "IfcRectangleHollowProfileDef", height, width, tw=t, tf=t)

        # parameters
        self.type = __class__.__name__

        self.t = t  # thickness
        self.r1 = r1  # outer radius
        self.r2 = r2  # inner radius
        dr = r1 - r1 / sqrt2
        dri = r2 - r2 / sqrt2
        bi = width - t
        hi = height - t

        # describe points
        p1 = Point2D(-width / 2 + r1, - height / 2)  # left bottom end arc
        p2 = Point2D(width / 2 - r1, - height / 2)  # right bottom start arc
        p3 = Point2D(width / 2 - dr, - height / 2 + dr)  # right bottom mid arc
        p4 = Point2D(width / 2, - height / 2 + r1)  # right bottom end arc
        p5 = Point2D(p4.x, -p4.y)  # right start arc
        p6 = Point2D(p3.x, -p3.y)  # right mid arc
        p7 = Point2D(p2.x, -p2.y)  # right end arc
        p8 = Point2D(-p7.x, p7.y)  # left start arc
        p9 = Point2D(-p6.x, p6.y)  # left mid arc
        p10 = Point2D(-p5.x, p5.y)  # left end arc
        p11 = Point2D(p10.x, -p10.y)  # right bottom start arc
        p12 = Point2D(p9.x, -p9.y)  # right bottom mid arc

        # inner part
        p13 = Point2D(-bi / 2 + r2, - hi / 2)  # left bottom end arc
        p14 = Point2D(bi / 2 - r2, - hi / 2)  # right bottom start arc
        p15 = Point2D(bi / 2 - dri, - hi / 2 + dri)  # right bottom mid arc
        p16 = Point2D(bi / 2, - hi / 2 + r2)  # right bottom end arc
        p17 = Point2D(p16.x, -p16.y)  # right start arc
        p18 = Point2D(p15.x, -p15.y)  # right mid arc
        p19 = Point2D(p14.x, -p14.y)  # right end arc
        p20 = Point2D(-p19.x, p19.y)  # left start arc
        p21 = Point2D(-p18.x, p18.y)  # left mid arc
        p22 = Point2D(-p17.x, p17.y)  # left end arc
        p23 = Point2D(p22.x, -p22.y)  # right bottom start arc
        p24 = Point2D(p21.x, -p21.y)  # right bottom mid arc

        # describe outer curves
        l1 = Line2D(p1, p2)
        l2 = Arc2D(p2, p3, p4)
        l3 = Line2D(p4, p5)
        l4 = Arc2D(p5, p6, p7)
        l5 = Line2D(p7, p8)
        l6 = Arc2D(p8, p9, p10)
        l7 = Line2D(p10, p11)
        l8 = Arc2D(p11, p12, p1)

        l9 = Line2D(p1, p13)
        # describe inner curves
        l10 = Line2D(p13, p14)
        l11 = Arc2D(p14, p15, p16)
        l12 = Line2D(p16, p17)
        l13 = Arc2D(p17, p18, p19)
        l14 = Line2D(p19, p20)
        l15 = Arc2D(p20, p21, p22)
        l16 = Line2D(p22, p23)
        l17 = Arc2D(p23, p24, p13)

        l18 = Line2D(p13, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18])

class CProfile(Profile):
    def __init__(self, name, width, height, t, r1, ex):
        super().__init__(name, "Cold Formed C Profile", "Unknown", height, width, tw=t, tf=t)

        # parameters
        self.type = __class__.__name__

        self.t = t  # flange thickness
        self.r1 = r1  # outer radius
        self.r2 = r1 - t  # inner radius
        r2 = r1 - t

        self.ex = ex
        self.ey = height / 2
        dr = r1 - r1 / sqrt2
        dri = r2 - r2 / sqrt2
        hi = height - t

        # describe points
        p1 = Point2D(width - ex, -height / 2)  # right bottom
        p2 = Point2D(r1 - ex, -height / 2)
        p3 = Point2D(dr - ex, -height / 2 + dr)
        p4 = Point2D(0 - ex, -height / 2 + r1)
        p5 = Point2D(p4.x, -p4.y)
        p6 = Point2D(p3.x, -p3.y)
        p7 = Point2D(p2.x, -p2.y)
        p8 = Point2D(p1.x, -p1.y)  # right top
        p9 = Point2D(width - ex, hi / 2)  # right top inner
        p10 = Point2D(t + r2 - ex, hi / 2)
        p11 = Point2D(t + dri - ex, hi / 2 - dri)
        p12 = Point2D(t - ex, hi / 2 - r2)
        p13 = Point2D(p12.x, -p12.y)
        p14 = Point2D(p11.x, -p11.y)
        p15 = Point2D(p10.x, -p10.y)
        p16 = Point2D(p9.x, -p9.y)  # right bottom inner
        # describe outer curves
        l1 = Line2D(p1, p2)  # bottom
        l2 = Arc2D(p2, p3, p4)  # right outer fillet
        l3 = Line2D(p4, p5)  # left outer web
        l4 = Arc2D(p5, p6, p7)  # left top outer fillet
        l5 = Line2D(p7, p8)  # outer top
        l6 = Line2D(p8, p9)
        l7 = Line2D(p9, p10)
        l8 = Arc2D(p10, p11, p12)  # left top inner fillet
        l9 = Line2D(p12, p13)
        l10 = Arc2D(p13, p14, p15)  # left botom inner fillet
        l11 = Line2D(p15, p16)
        l12 = Line2D(p16, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12])

class CProfileWithLips(Profile):
    def __init__(self, name, width, height, h1, t, r1, ex):
        super().__init__(name, "Cold Formed C Profile with Lips", "Unknown", height, width, tw=t, tf=t)

        # parameters
        self.type = __class__.__name__

        self.h1 = h1  # lip length
        self.t = t  # flange thickness
        self.r1 = r1  # outer radius
        self.r2 = r1 - t  # inner radius
        r2 = r1 - t

        self.ex = ex
        self.ey = height / 2
        dr = r1 - r1 / sqrt2
        dri = r2 - r2 / sqrt2
        hi = height - t

        # describe points
        p1 = Point2D(width - ex - r1, -height / 2)  # right bottom  before fillet
        p2 = Point2D(r1 - ex, -height / 2)
        p3 = Point2D(dr - ex, -height / 2 + dr)
        p4 = Point2D(0 - ex, -height / 2 + r1)
        p5 = Point2D(p4.x, -p4.y)
        p6 = Point2D(p3.x, -p3.y)
        p7 = Point2D(p2.x, -p2.y)
        p8 = Point2D(p1.x, -p1.y)  # right top before fillet
        p9 = Point2D(width - ex - dr, height / 2 - dr)  # middle point arc
        p10 = Point2D(width - ex, height / 2 - r1)  # end fillet
        p11 = Point2D(width - ex, height / 2 - h1)
        p12 = Point2D(width - ex - t, height / 2 - h1)  # bottom lip
        p13 = Point2D(width - ex - t, height / 2 - t - r2)  # start inner fillet right top
        p14 = Point2D(width - ex - t - dri, height / 2 - t - dri)
        p15 = Point2D(width - ex - t - r2, height / 2 - t)  # end inner fillet right top
        p16 = Point2D(0 - ex + t + r2, height / 2 - t)
        p17 = Point2D(0 - ex + t + dri, height / 2 - t - dri)
        p18 = Point2D(0 - ex + t, height / 2 - t - r2)

        p19 = Point2D(p18.x, -p18.y)
        p20 = Point2D(p17.x, -p17.y)
        p21 = Point2D(p16.x, -p16.y)
        p22 = Point2D(p15.x, -p15.y)
        p23 = Point2D(p14.x, -p14.y)
        p24 = Point2D(p13.x, -p13.y)
        p25 = Point2D(p12.x, -p12.y)
        p26 = Point2D(p11.x, -p11.y)
        p27 = Point2D(p10.x, -p10.y)
        p28 = Point2D(p9.x, -p9.y)

        # describe outer curves
        l1 = Line2D(p1, p2)
        l2 = Arc2D(p2, p3, p4)
        l3 = Line2D(p4, p5)
        l4 = Arc2D(p5, p6, p7)  # outer fillet right top
        l5 = Line2D(p7, p8)
        l6 = Arc2D(p8, p9, p10)
        l7 = Line2D(p10, p11)
        l8 = Line2D(p11, p12)
        l9 = Line2D(p12, p13)
        l10 = Arc2D(p13, p14, p15)
        l11 = Line2D(p15, p16)
        l12 = Arc2D(p16, p17, p18)
        l13 = Line2D(p18, p19)  # inner web
        l14 = Arc2D(p19, p20, p21)
        l15 = Line2D(p21, p22)
        l16 = Arc2D(p22, p23, p24)
        l17 = Line2D(p24, p25)
        l18 = Line2D(p25, p26)
        l19 = Line2D(p26, p27)
        l20 = Arc2D(p27, p28, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20])

class LProfileColdFormed(Profile):
    def __init__(self, name, width, height, t, r1, ex, ey):
        super().__init__(name, "Cold Formed L Profile", "Unknown", height, width, tw=t, tf=t)

        # parameters
        self.type = __class__.__name__

        self.t = t  # flange thickness
        self.r1 = r1  # inner radius
        self.r2 = r1 - t  # outer radius
        self.ex = ex
        self.ey = ey
        r11 = r1 / math.sqrt(2)
        r2 = r1 + t
        r21 = r2 / math.sqrt(2)

        # describe points
        p1 = Point2D(-ex, -ey + r2)  # start arc left bottom
        p2 = Point2D(-ex + r2 - r21, -ey + r2 - r21)  # second point arc
        p3 = Point2D(-ex + r2, -ey)  # end arc
        p4 = Point2D(width - ex, -ey)  # right bottom
        p5 = Point2D(width - ex, -ey + t)
        p6 = Point2D(-ex + t + r1, -ey + t)  # start arc
        p7 = Point2D(-ex + t + r1 - r11, -ey + t +
                     r1 - r11)  # second point arc
        p8 = Point2D(-ex + t, -ey + t + r1)  # end arc
        p9 = Point2D(-ex + t, ey)
        p10 = Point2D(-ex, ey)  # left top

        l1 = Arc2D(p1, p2, p3)
        l2 = Line2D(p3, p4)
        l3 = Line2D(p4, p5)
        l4 = Line2D(p5, p6)
        l5 = Arc2D(p6, p7, p8)
        l6 = Line2D(p8, p9)
        l7 = Line2D(p9, p10)
        l8 = Line2D(p10, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8])

class SigmaProfileWithLipsColdFormed(Profile):
    def __init__(self, name, width, height, t, r1, h1, h2, h3, b2, ex):
        super().__init__(name, "Cold Formed Sigma Profile with Lips", "Unknown", height, width, tw=t, tf=t)

        # parameters
        self.type = __class__.__name__

        self.h1 = h1  # LipLength
        self.h2 = h2  # MiddleBendLength
        self.h3 = h3  # TopBendLength
        self.h4 = h4 = (height - h2 - h3 * 2) / 2
        self.h5 = h5 = math.tan(0.5 * math.atan(b2 / h4)) * t
        self.b2 = b2  # MiddleBendWidth
        self.t = t  # flange thickness
        self.r1 = r1  # inner radius
        self.r2 = r2 = r1 + t  # outer radius
        self.ex = ex
        self.ey = ey = height / 2
        r11 = r11 = r1 / math.sqrt(2)
        r21 = r21 = r2 / math.sqrt(2)

        p1 = Point2D(-ex + b2, -h2 / 2)
        p2 = Point2D(-ex, -ey + h3)
        p3 = Point2D(-ex, -ey + r2)  # start arc left bottom
        p4 = Point2D(-ex + r2 - r21, -ey + r2 - r21)  # second point arc
        p5 = Point2D(-ex + r2, -ey)  # end arc
        p6 = Point2D(width - ex - r2, -ey)  # start arc
        p7 = Point2D(width - ex - r2 + r21, -ey + r2 - r21)  # second point arc
        p8 = Point2D(width - ex, -ey + r2)  # end arc
        p9 = Point2D(width - ex, -ey + h1)  # end lip
        p10 = Point2D(width - ex - t, -ey + h1)
        p11 = Point2D(width - ex - t, -ey + t + r1)  # start arc
        p12 = Point2D(width - ex - t - r1 + r11, -ey +
                      t + r1 - r11)  # second point arc
        p13 = Point2D(width - ex - t - r1, -ey + t)  # end arc
        p14 = Point2D(-ex + t + r1, -ey + t)  # start arc
        p15 = Point2D(-ex + t + r1 - r11, -ey + t +
                      r1 - r11)  # second point arc
        p16 = Point2D(-ex + t, -ey + t + r1)  # end arc
        p17 = Point2D(-ex + t, -ey + h3 - h5)
        p18 = Point2D(-ex + b2 + t, -h2 / 2 - h5)
        p19 = Point2D(p18.x, -p18.y)
        p20 = Point2D(p17.x, -p17.y)
        p21 = Point2D(p16.x, -p16.y)
        p22 = Point2D(p15.x, -p15.y)
        p23 = Point2D(p14.x, -p14.y)
        p24 = Point2D(p13.x, -p13.y)
        p25 = Point2D(p12.x, -p12.y)
        p26 = Point2D(p11.x, -p11.y)
        p27 = Point2D(p10.x, -p10.y)
        p28 = Point2D(p9.x, -p9.y)
        p29 = Point2D(p8.x, -p8.y)
        p30 = Point2D(p7.x, -p7.y)
        p31 = Point2D(p6.x, -p6.y)
        p32 = Point2D(p5.x, -p5.y)
        p33 = Point2D(p4.x, -p4.y)
        p34 = Point2D(p3.x, -p3.y)
        p35 = Point2D(p2.x, -p2.y)
        p36 = Point2D(p1.x, -p1.y)

        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Arc2D(p3, p4, p5)
        l4 = Line2D(p5, p6)
        l5 = Arc2D(p6, p7, p8)
        l6 = Line2D(p8, p9)
        l7 = Line2D(p9, p10)
        l8 = Line2D(p10, p11)
        l9 = Arc2D(p11, p12, p13)
        l10 = Line2D(p13, p14)
        l11 = Arc2D(p14, p15, p16)
        l12 = Line2D(p16, p17)
        l13 = Line2D(p17, p18)
        l14 = Line2D(p18, p19)
        l15 = Line2D(p19, p20)
        l16 = Line2D(p20, p21)
        l17 = Arc2D(p21, p22, p23)
        l18 = Line2D(p23, p24)
        l19 = Arc2D(p24, p25, p26)
        l20 = Line2D(p26, p27)
        l21 = Line2D(p27, p28)
        l22 = Line2D(p28, p29)
        l23 = Arc2D(p29, p30, p31)
        l24 = Line2D(p31, p32)
        l25 = Arc2D(p32, p33, p34)
        l26 = Line2D(p34, p35)
        l27 = Line2D(p35, p36)
        l28 = Line2D(p36, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22, l23,
             l24, l25,
             l26, l27, l28])

class ZProfileColdFormed(Profile):
    def __init__(self, name, width, height, t, r1):
        super().__init__(name, "Cold Formed Z Profile", "Unknown", height, width, tw=t, tf=t)

        # parameters
        self.type = __class__.__name__

        self.t = t  # flange thickness
        self.r1 = r1  # inner radius
        self.r2 = r2 = r1 + t  # outer radius
        self.ex = ex = width / 2
        self.ey = ey = height / 2
        r11 = r11 = r1 / math.sqrt(2)
        r21 = r21 = r2 / math.sqrt(2)

        p1 = Point2D(-0.5 * t, -ey + t + r1)  # start arc
        p2 = Point2D(-0.5 * t - r1 + r11, -ey + t +
                     r1 - r11)  # second point arc
        p3 = Point2D(-0.5 * t - r1, -ey + t)  # end arc
        p4 = Point2D(-ex, -ey + t)
        p5 = Point2D(-ex, -ey)  # left bottom
        p6 = Point2D(-r2 + 0.5 * t, -ey)  # start arc
        p7 = Point2D(-r2 + 0.5 * t + r21, -ey + r2 - r21)  # second point arc
        p8 = Point2D(0.5 * t, -ey + r2)  # end arc
        p9 = Point2D(-p1.x, -p1.y)
        p10 = Point2D(-p2.x, -p2.y)
        p11 = Point2D(-p3.x, -p3.y)
        p12 = Point2D(-p4.x, -p4.y)
        p13 = Point2D(-p5.x, -p5.y)
        p14 = Point2D(-p6.x, -p6.y)
        p15 = Point2D(-p7.x, -p7.y)
        p16 = Point2D(-p8.x, -p8.y)

        l1 = Arc2D(p1, p2, p3)
        l2 = Line2D(p3, p4)
        l3 = Line2D(p4, p5)
        l4 = Line2D(p5, p6)
        l5 = Arc2D(p6, p7, p8)
        l6 = Line2D(p8, p9)
        l7 = Arc2D(p9, p10, p11)
        l8 = Line2D(p11, p12)
        l9 = Line2D(p12, p13)
        l10 = Line2D(p13, p14)
        l11 = Arc2D(p14, p15, p16)
        l12 = Line2D(p16, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12])

class ZProfileWithLipsColdFormed(Profile):
    def __init__(self, name, width, height, t, r1, h1):
        super().__init__(name, "Cold Formed Z Profile with Lips", "Unknown", height, width, tw=t, tf=t)

        # parameters
        self.type = __class__.__name__

        self.t = t  # flange thickness
        self.h1 = h1  # lip length
        self.r1 = r1  # inner radius
        self.r2 = r2 = r1 + t  # outer radius
        self.ex = ex = width / 2
        self.ey = ey = height / 2
        r11 = r11 = r1 / math.sqrt(2)
        r21 = r21 = r2 / math.sqrt(2)

        p1 = Point2D(-0.5 * t, -ey + t + r1)  # start arc
        p2 = Point2D(-0.5 * t - r1 + r11, -ey + t + r1 - r11)  # second point arc
        p3 = Point2D(-0.5 * t - r1, -ey + t)  # end arc
        p4 = Point2D(-ex + t + r1, -ey + t)  # start arc
        p5 = Point2D(-ex + t + r1 - r11, -ey + t + r1 - r11)  # second point arc
        p6 = Point2D(-ex + t, -ey + t + r1)  # end arc
        p7 = Point2D(-ex + t, -ey + h1)
        p8 = Point2D(-ex, -ey + h1)
        p9 = Point2D(-ex, -ey + r2)  # start arc
        p10 = Point2D(-ex + r2 - r21, -ey + r2 - r21)  # second point arc
        p11 = Point2D(-ex + r2, -ey)  # end arc
        p12 = Point2D(-r2 + 0.5 * t, -ey)  # start arc
        p13 = Point2D(-r2 + 0.5 * t + r21, -ey + r2 - r21)  # second point arc
        p14 = Point2D(0.5 * t, -ey + r2)  # end arc
        p15 = Point2D(-p1.x, -p1.y)
        p16 = Point2D(-p2.x, -p2.y)
        p17 = Point2D(-p3.x, -p3.y)
        p18 = Point2D(-p4.x, -p4.y)
        p19 = Point2D(-p5.x, -p5.y)
        p20 = Point2D(-p6.x, -p6.y)
        p21 = Point2D(-p7.x, -p7.y)
        p22 = Point2D(-p8.x, -p8.y)
        p23 = Point2D(-p9.x, -p9.y)
        p24 = Point2D(-p10.x, -p10.y)
        p25 = Point2D(-p11.x, -p11.y)
        p26 = Point2D(-p12.x, -p12.y)
        p27 = Point2D(-p13.x, -p13.y)
        p28 = Point2D(-p14.x, -p14.y)

        l1 = Arc2D(p1, p2, p3)
        l2 = Line2D(p3, p4)
        l3 = Arc2D(p4, p5, p6)
        l4 = Line2D(p6, p7)
        l5 = Line2D(p7, p8)
        l6 = Line2D(p8, p9)
        l7 = Arc2D(p9, p10, p11)
        l8 = Line2D(p11, p12)
        l9 = Arc2D(p12, p13, p14)
        l10 = Line2D(p14, p15)
        l11 = Arc2D(p15, p16, p17)
        l12 = Line2D(p17, p18)
        l13 = Arc2D(p18, p19, p20)
        l14 = Line2D(p20, p21)
        l15 = Line2D(p21, p22)
        l16 = Line2D(p22, p23)
        l17 = Arc2D(p23, p24, p25)
        l18 = Line2D(p25, p26)
        l19 = Arc2D(p26, p27, p28)
        l20 = Line2D(p28, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20])

class TProfile(Profile):
    def __init__(self, name, height, width, h1:float, b1:float):
        super().__init__(name, "T-profile", "Unknown", height, width)

        # parameters
        self.type = __class__.__name__
        self.h1 = h1
        self.b1 = b1

        # describe points
        p1 = Point2D(b1 / 2, -height / 2)  # right bottom
        p2 = Point2D(b1 / 2, height / 2 - h1)  # right middle 1
        p3 = Point2D(width / 2, height / 2 - h1)  # right middle 2
        p4 = Point2D(width / 2, height / 2)  # right top
        p5 = Point2D(-width / 2, height / 2)  # left top
        p6 = Point2D(-width / 2, height / 2 - h1)  # left middle 2
        p7 = Point2D(-b1 / 2, height / 2 - h1)  # left middle 1
        p8 = Point2D(-b1 / 2, -height / 2)  # left bottom

        # describe curves
        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Line2D(p3, p4)
        l4 = Line2D(p4, p5)
        l5 = Line2D(p5, p6)
        l6 = Line2D(p6, p7)
        l7 = Line2D(p7, p8)
        l8 = Line2D(p8, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8])

class LProfile(Profile):
    def __init__(self, name, height, width, h1:float, b1:float):
        super().__init__(name, "L-profile", "Unknown", height, width)

        # parameters
        self.type = __class__.__name__
        self.h1 = h1
        self.b1 = b1

        # describe points
        p1 = Point2D(width / 2, -height / 2)  # right bottom
        p2 = Point2D(width / 2, -height / 2 + h1)  # right middle
        p3 = Point2D(-width / 2 + b1, -height / 2 + h1)  # middle
        p4 = Point2D(-width / 2 + b1, height / 2)  # middle top
        p5 = Point2D(-width / 2, height / 2)  # left top
        p6 = Point2D(-width / 2, -height / 2)  # left bottom

        # describe curves
        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Line2D(p3, p4)
        l4 = Line2D(p4, p5)
        l5 = Line2D(p5, p6)
        l6 = Line2D(p6, p1)

        self.curve = PolyCurve2D().by_joined_curves([l1, l2, l3, l4, l5, l6])

class EProfile(Serializable):
    def __init__(self, name, height, width, h1):
        super().__init__(name, "E-profile", "Unknown", height, width)

        # parameters
        self.type = __class__.__name__
        self.h1 = h1

        # describe points
        p1 = Point2D(width / 2, -height / 2)  # right bottom
        p2 = Point2D(width / 2, -height / 2 + h1)
        p3 = Point2D(-width / 2 + h1, -height / 2 + h1)
        p4 = Point2D(-width / 2 + h1, -h1 / 2)
        p5 = Point2D(width / 2, -h1 / 2)
        p6 = Point2D(width / 2, h1 / 2)
        p7 = Point2D(-width / 2 + h1, h1 / 2)
        p8 = Point2D(-width / 2 + h1, height / 2 - h1)
        p9 = Point2D(width / 2, height / 2 - h1)
        p10 = Point2D(width / 2, height / 2)
        p11 = Point2D(-width / 2, height / 2)
        p12 = Point2D(-width / 2, -height / 2)

        # describe curves
        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Line2D(p3, p4)
        l4 = Line2D(p4, p5)
        l5 = Line2D(p5, p6)
        l6 = Line2D(p6, p7)
        l7 = Line2D(p7, p8)
        l8 = Line2D(p8, p9)
        l9 = Line2D(p9, p10)
        l10 = Line2D(p10, p11)
        l11 = Line2D(p11, p12)
        l12 = Line2D(p12, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12])

class NProfile(Serializable):
    def __init__(self, name, height, width, b1):
        super().__init__(name, "N-profile", "Unknown", height, width)

        # parameters
        self.type = __class__.__name__
        self.b1 = b1

        # describe points
        p1 = Point2D(width / 2, -height / 2)  # right bottom
        p2 = Point2D(width / 2, height / 2)
        p3 = Point2D(width / 2 - b1, height / 2)
        p4 = Point2D(width / 2 - b1, -height / 2 + b1 * 2)
        p5 = Point2D(-width / 2 + b1, height / 2)
        p6 = Point2D(-width / 2, height / 2)
        p7 = Point2D(-width / 2, -height / 2)
        p8 = Point2D(-width / 2 + b1, -height / 2)
        p9 = Point2D(-width / 2 + b1, height / 2 - b1 * 2)
        p10 = Point2D(width / 2 - b1, -height / 2)

        # describe curves
        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Line2D(p3, p4)
        l4 = Line2D(p4, p5)
        l5 = Line2D(p5, p6)
        l6 = Line2D(p6, p7)
        l7 = Line2D(p7, p8)
        l8 = Line2D(p8, p9)
        l9 = Line2D(p9, p10)
        l10 = Line2D(p10, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10])


class ArrowProfile(Profile):
    def __init__(self, name, length, width, b1, l1):
        super().__init__(name, "Arrow-profile", "Unknown", length, width)
        
        # parameters
        
        self.length = length  # length
        self.b1 = b1
        self.l1 = l1

        # describe points
        p1 = Point2D(0, length / 2)  # top middle
        p2 = Point2D(width / 2, -length / 2 + l1)
        # p3 = Point2D(b1 / 2, -length / 2 + l1)
        p3 = Point2D(b1 / 2, (-length / 2 + l1) + (length / 2) / 4)
        p4 = Point2D(b1 / 2, -length / 2)
        p5 = Point2D(-b1 / 2, -length / 2)
        # p6 = Point2D(-b1 / 2, -length / 2 + l1)
        p6 = Point2D(-b1 / 2, (-length / 2 + l1) + (length / 2) / 4)
        p7 = Point2D(-width / 2, -length / 2 + l1)

        # describe curves
        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Line2D(p3, p4)
        l4 = Line2D(p4, p5)
        l5 = Line2D(p5, p6)
        l6 = Line2D(p6, p7)
        l7 = Line2D(p7, p1)

        self.curve = PolyCurve2D().by_joined_curves(
            [l1, l2, l3, l4, l5, l6, l7])



class Extrusion:
    # Extrude a 2D profile to a 3D mesh or solid
    """The Extrusion class represents the process of extruding a 2D profile into a 3D mesh or solid form. It is designed to handle geometric transformations and properties related to the extrusion process."""
    def __init__(self, polycurve: PolyCurve, start: Vector, end: Vector):
        """The Extrusion class represents the process of extruding a 2D profile into a 3D mesh or solid form. It is designed to handle geometric transformations and properties related to the extrusion process.
        
        - `id` (str): A unique identifier for the extrusion instance.
        - `type` (str): Class name, indicating the object type as "Extrusion".
        - `parameters` (list): A list of parameters associated with the extrusion.
        - `verts` (list): A list of vertices that define the shape of the extruded mesh.
        - `faces` (list): A list of faces, each defined by indices into the `verts` list.
        - `numberFaces` (int): The total number of faces in the extrusion.
        - `countVertsFaces` (int): The total number of vertices per face, distinct from the total vertex count.
        - `name` (str): The name assigned to the extrusion instance.
        - `color` (tuple): The color of the extrusion, defined as an RGB tuple.
        - `colorlst` (list): A list of colors applied to the extrusion, potentially varying per face or vertex.
        - `topface` (PolyCurve): The top face of the extrusion, returned as a polycurve converted to a surface.
        - `bottomface` (PolyCurve): The bottom face of the extrusion, similar to `topface`.
        - `polycurve_3d_translated` (PolyCurve): A polycurve representing the translated 3D profile of the extrusion.
        - `bottomshape` (list): A list representing the shape of the bottom face of the extrusion.
        """
        
        self.polycurve = polycurve
        self.start = start
        self.end = end

    def set_parameter(self, data: list) -> 'Extrusion':
        """Sets parameters for the extrusion.
        This method allows for the modification of the Extrusion's parameters, which can influence the extrusion process or define additional properties.

        #### Parameters:
        - `data` (list): A list of parameters to be applied to the extrusion.

        #### Returns:
        `Extrusion`: The Extrusion instance with updated parameters.
    
        #### Example usage:
        ```python

        ```
        """
        self.parameters = data
        return self
        
    @staticmethod
    def by_polycurve_height_vector(polycurve: PolyCurve, height: float, start_point: Point, direction_vector: Vector) -> 'Extrusion':
        """Creates an extrusion from a 2D polycurve profile along a specified vector.
        This method extrudes a 2D polycurve profile into a 3D form by translating it to a specified start point and direction. The extrusion is created perpendicular to the polycurve's plane, extending it to the specified height.

        #### Parameters:
        - `polycurve_2d` (PolyCurve2D): The 2D polycurve to be extruded.
        - `height` (float): The height of the extrusion.
        - `cs_old` (CoordinateSystem): The original coordinate system of the polycurve.
        - `start_point` (Point): The start point for the extrusion in the new coordinate system.
        - `direction_vector` (Vector): The direction vector along which the polycurve is extruded.

        #### Returns:
        `Extrusion`: An Extrusion object representing the 3D form of the extruded polycurve.

        #### Example usage:
        ```python
        extrusion = Extrusion.by_polycurve_height_vector(polycurve_2d, 10, oldCS, startPoint, directionVec)
        ```
        """
        return Extrusion(polycurve, start_point, start_point + direction_vector * height)

    @staticmethod
    def by_polycurve_height(polycurve: PolyCurve, height: float, dz_loc: float) -> 'Extrusion':
        """Creates an extrusion from a PolyCurve with a specified height and base elevation.
        This method generates a vertical extrusion of a given PolyCurve. The PolyCurve is first translated vertically by `dz_loc`, then extruded to the specified `height`, creating a solid form.

        #### Parameters:
        - `polycurve` (PolyCurve): The PolyCurve to be extruded.
        - `height` (float): The height of the extrusion.
        - `dz_loc` (float): The base elevation offset from the original plane of the PolyCurve.

        #### Returns:
        `Extrusion`: An Extrusion object that represents the 3D extruded form of the input PolyCurve.

        #### Example usage:
        ```python
        extrusion = Extrusion.by_polycurve_height(polycurve, 5, 0)
        ```
        """
        # global len
        Extrus = Extrusion()
        Points = polycurve.points
        V1 = Vector.by_two_points(Points[0], Points[1])
        V2 = Vector.by_two_points(Points[-2], Points[-1])

        p1 = Plane.by_two_vectors_origin(
            V1, V2, Points[0])  # Workplane of PolyCurve
        norm = p1.Normal

        pnts = []
        faces = []

        Extrus.polycurve_3d_translated = polycurve

        numPoints = len(Points)
        
        # allverts
        for pnt in Points:
            # bottom side moves along the normal with dz_loc units
            pnts.append(Point.translate(pnt, Vector.product(dz_loc, norm)))
        
        # Bottomface
        face = []
        for x in reversed(range(numPoints)):
            face.append(x)
        faces.append(face)
        
        
        # Topface
        # TODO: correct winding
        face = []
        start = numPoints if height else 0
        for x in range(start, start + numPoints):
            face.append(x)
        faces.append(face)
            
        # when the height of an extrusion is 0, we only have to add the top / bottom (it doesn't really matter) side mesh. it would just cause z-buffer glitching
        if height:
            for pnt in Points:
                # Bovenzijde verplaatst met dz_loc
                pnts.append(Point.translate(
                    pnt, Vector.product((dz_loc+height), norm)))
            #other faces



            # Sides
            count = 0
            length = len(faces[0])
            for i, j in zip(faces[0], faces[1]):
                face = []
                face.append(i)
                face.append(faces[0][count + 1])
                face.append(faces[1][count + 1])
                face.append(j)
                count = count + 1
                if count == length-1:
                    face.append(i)
                    face.append(faces[0][0])
                    face.append(faces[1][0])
                    face.append(j)
                    faces.append(face)
                    break
                else:
                    pass
                faces.append(face)

        # toMeshStructure
        for i in pnts:
            Extrus.verts.append(i.x)
            Extrus.verts.append(i.y)
            Extrus.verts.append(i.z)
            
        # faces are laid out like this: face 0 vert count, face 0 vert 0 index, vert ...count index, face 1 vert count etc.
        # for example: 4, 0, 1, 2, 3, 3, 4, 5, 6 => 4, (0, 1, 2, 3), 3, (4, 5, 6)
        for x in faces:
            Extrus.faces.append(len(x))  # Number of verts in face
            for y in x:
                Extrus.faces.append(y)

        Extrus.numberFaces = len(faces)
        Extrus.countVertsFaces = (4 * len(faces))

        for j in range(int(len(Extrus.verts) / 3)):
            Extrus.colorlst.append(Extrus.color)
        return Extrus
    
    @staticmethod
    def from_3d_rect(rect:Rect) -> Self:
        """Generates an extrusion representing a cuboid from the 3D bounding box dimensions.

        #### Returns:
        `Extrusion`: An Extrusion object that represents a cuboid, matching the dimensions and orientation of the bounding box.

        #### Example usage:
        ```python
        bbox2d = Rect().by_dimensions(length=100, width=50)
        cs = CoordinateSystem()
        bbox3d = BoundingBox3d().convert_boundingbox_2d(bbox2d, cs, height=30)
        cuboid = bbox3d.to_cuboid()
        # Generates a cuboid extrusion based on the 3D bounding box
        ```
        """
        pts = rect.corners()
        pc = PolyCurve2D.by_points(pts)
        height = rect.height
        cs = rect.coordinatesystem
        dirXvector = Vector.angle_between(CSGlobal.Y_axis, cs.Y_axis)
        pcrot = pc.rotate(dirXvector)  # bug multi direction
        cuboid = Extrusion.by_polycurve_height_vector(
            pcrot, height, CSGlobal, cs.Origin, cs.Z_axis)
        return cuboid
# check if there are innercurves inside the outer curve.


class Surface:
    """Represents a surface object created from PolyCurves."""
    def __init__(self) -> 'Surface':
        """This class is designed to manage and manipulate surfaces derived from PolyCurve objects. It supports the generation of mesh representations, serialization/deserialization, and operations like filling and voiding based on PolyCurve inputs.
       
        - `type` (str): The class name, "Surface".
        - `mesh` (list): A list of meshes that represent the surface.
        - `length` (float): The total length of the PolyCurves defining the surface.
        - `area` (float): The area of the surface, excluding any inner PolyCurves.
        - `offset` (float): An offset value for the surface.
        - `name` (str): The name of the surface.
        - `id` (str): A unique identifier for the surface.
        - `PolyCurveList` (list): A list of PolyCurve objects that define the surface.
        - `origincurve` (PolyCurve): The original PolyCurve from which the surface was created.
        - `color` (int): The color of the surface, represented as an integer.
        - `colorlst` (list): A list of color values associated with the surface.
        """       
        self.mesh = []
        self.offset = 0
        self.name = None
        
        self.outer_Polygon = None
        self.inner_Polygon = []
        self.colorlst = []
        self.outer_Surface = None
        self.inner_Surface = []
        # self.byPatch = self.fill(self)
        # if color is None:
        #     self.color = Color.rgb_to_int(Color().Components("gray"))
        # else:
        #     self.color = color



    def serialize(self) -> dict:
        """Serializes the Surface object into a dictionary for storage or transfer.
        This method converts the Surface object's properties into a dictionary format, making it suitable for serialization processes like saving to a file or sending over a network.

        #### Returns:
        `dict`: A dictionary representation of the Surface object, containing all relevant data such as type, mesh, dimensions, name, ID, PolyCurve list, origin curve, color, and color list.

        #### Example usage:
        ```python
        surface = Surface(polyCurves, color)
        serialized_surface = surface.serialize()
        # serialized_surface is now a dictionary representation of the surface object
        ```
        """
        return {
            'type': self.type,
            'mesh': self.mesh,
            'length': self.length,
            'area': self.area,
            'offset': self.offset,
            'name': self.name,
            'id': self.id,
            'PolyCurveList': [polycurve.serialize() for polycurve in self.PolyCurveList],
            'origincurve': self.origincurve.serialize() if self.origincurve else None,
            'color': self.color,
            'colorlst': self.colorlst
        }

    @staticmethod
    def deserialize(data: dict) -> 'Surface':
        """Creates a Surface object from a serialized data dictionary.
        This static method reconstructs a Surface object from a dictionary containing serialized surface data. It is particularly useful for loading surfaces from storage or reconstructing them from data received over a network.

        #### Parameters:
        - `data` (`dict`): The dictionary containing the serialized data of a Surface object.

        #### Returns:
        `Surface`: A new Surface object initialized with the data from the dictionary.

        #### Example usage:
        ```python
        data = { ... }  # Serialized Surface data
        surface = Surface.deserialize(data)
        # surface is now a fully reconstructed Surface object
        ```
        """
        polycurves = [PolyCurve.deserialize(
            pc_data) for pc_data in data.get('PolyCurveList', [])]
        surface = Surface(polycurves, data.get('color'))

        surface.mesh = data.get('mesh', [])
        surface.length = data.get('length', 0)
        surface.area = data.get('area', 0)
        surface.offset = data.get('offset', 0)
        surface.name = data.get('name', "test2")
        surface.id = data.get('id')
        surface.colorlst = data.get('colorlst', [])

        if data.get('origincurve'):
            surface.origincurve = PolyCurve.deserialize(data['origincurve'])

        return surface
    @classmethod
    def by_patch_inner_and_outer(self, Polygons: 'list[Polygon]') -> 'Surface':
        valid_polygons = [p for p in Polygons if p is not None]
        sorted_polygons = sorted(valid_polygons, key=lambda p: p.length(), reverse=True)

        if len(sorted_polygons) == 0:
            raise ValueError("No valid polygons provided")

        outer_Polygon = sorted_polygons[0]

        inner_Polygon = sorted_polygons[1:] if len(sorted_polygons) > 1 else []

        return self.by_patch(outer_Polygon, inner_Polygon)


    @classmethod
    def by_patch(self, outer_Polygon: Polygon, inner_Polygon: 'list[Polygon]' = None) -> 'Surface':
        srf = Surface()
        srf.outer_Polygon = outer_Polygon
        srf.inner_Polygon = inner_Polygon
        srf.outer_Surface = Extrusion.by_polycurve_height(outer_Polygon, 0, 0)
        srf.inner_Surface = []
        if inner_Polygon != None:
            for inner in srf.inner_Polygon:
                srf.inner_Surface.append(Extrusion.by_polycurve_height(inner, 0, 0))

        return srf

    def void(self, polyCurve: PolyCurve):
        """Creates a void in the Surface based on the specified PolyCurve.
        This method identifies and removes a part of the Surface that intersects with the given PolyCurve, effectively creating a void in the Surface. It then updates the surface's mesh and color list to reflect this change.

        #### Parameters:
        - `polyCurve` (`PolyCurve`): The PolyCurve object that defines the area of the Surface to be voided.

        #### Example usage:
        ```python
        surface.void(polyCurve)
        # A void is now created in the surface based on the specified PolyCurve.
        ```
        """
        # Find the index of the extrusion that intersects with the polyCurve
        pass

    def __id__(self):
        """Returns the unique identifier of the Surface.
        This method provides a way to retrieve the unique ID of the Surface, which can be useful for tracking or identifying surfaces within a larger system.

        #### Returns:
        `str`: The unique identifier of the Surface.

        #### Example usage:
        ```python
        id_str = surface.__id__()
        print(id_str)
        # Outputs the ID of the surface.
        ```
        """

    def __str__(self) -> str:
        return f"{self.__class__.__name__}({self.outer_Polygon}, {self.inner_Polygon})"

    

class NurbsSurface:  # based on point data / degreeU&countU / degreeV&countV?
    """Represents a NURBS (Non-Uniform Rational B-Spline) surface."""
    def __init__(self) -> 'NurbsSurface':
        """NurbsSurface is a mathematical model representing a 3D surface in terms of NURBS, a flexible method to represent curves and surfaces. It encompasses properties such as ID and type but is primarily defined by its control points, weights, and degree in the U and V directions.

        - `id` (str): A unique identifier for the NurbsSurface.
        - `type` (str): Class name, "NurbsSurface".
        """
        

    def __id__(self) -> 'str':
        """Returns the unique identifier of the NurbsSurface object.
        This method provides a standardized way to access the unique ID of the NurbsSurface, useful for identification and tracking purposes within a system that handles multiple surfaces.

        #### Returns:
        `str`: The unique identifier of the NurbsSurface, prefixed with "id:".

        #### Example usage:
        ```python
        nurbs_surface = NurbsSurface()
        print(nurbs_surface.__id__())
        # Output format: "id:{unique_id}"
        ```
        """
        return f"id:{self.id}"

    def __str__(self) -> 'str':
        """Generates a string representation of the NurbsSurface object.
        This method creates a string that summarizes the NurbsSurface, typically including its class name and potentially its unique ID, providing a concise overview of the object when printed or logged.

        #### Returns:
        `str`: A string representation of the NurbsSurface object.

        #### Example usage:
        ```python
        nurbs_surface = NurbsSurface()
        print(nurbs_surface)
        # Output: "NurbsSurface({self})"
        ```
        """
        return f"{__class__.__name__}({self})"


class PolySurface:
    """Represents a compound surface consisting of multiple connected surfaces."""
    def __init__(self) -> None:
        """PolySurface is a geometric entity that represents a complex surface made up of several simpler surfaces. These simpler surfaces are typically connected along their edges. Attributes include an ID and type, with functionalities to manipulate and query the composite surface structure.
        
        - `id` (str): A unique identifier for the PolySurface.
        - `type` (str): Class name, "PolySurface".
        """
        

    def __id__(self) -> 'str':
        """Returns the unique identifier of the PolySurface object.
        Similar to the NurbsSurface, this method provides the unique ID of the PolySurface, facilitating its identification and tracking across various operations or within data structures that involve multiple surfaces.

        #### Returns:
        `str`: The unique identifier of the PolySurface, prefixed with "id:".

        #### Example usage:
        ```python
        poly_surface = PolySurface()
        print(poly_surface.__id__())
        # Output format: "id:{unique_id}"
        ```
        """
        return f"id:{self.id}"

    def __str__(self) -> 'str':
        """Generates a string representation of the PolySurface object.
        Provides a simple string that identifies the PolySurface, mainly through its class name. This is helpful for debugging, logging, or any scenario where a quick textual representation of the object is beneficial.

        #### Returns:
        `str`: A string representation of the PolySurface object.

        #### Example usage:
        ```python
        poly_surface = PolySurface()
        print(poly_surface)
        # Output: "PolySurface({self})"
        ```
        """
        return f"{__class__.__name__}({self})"


# Rule: line, whitespace, line whitespace etc., scale
HiddenLine1 = ["Hidden Line 1", [1, 1], 100]
# Rule: line, whitespace, line whitespace etc., scale
HiddenLine2 = ["Hidden Line 2", [2, 1], 100]
# Rule: line, whitespace, line whitespace etc., scale
Centerline = ["Center Line 1", [8, 2, 2, 2], 100]


def line_to_pattern(baseline: 'Line', pattern_obj) -> 'list':
    """Converts a baseline (Line object) into a list of line segments based on a specified pattern.
    This function takes a line (defined by its start and end points) and a pattern object. The pattern object defines a repeating sequence of segments to be applied along the baseline. The function calculates the segments according to the pattern and returns a list of Line objects representing these segments.

    #### Parameters:
    - `baseline` (Line): The baseline along which the pattern is to be applied. This line is defined by its start and end points.
    - `pattern_obj` (Pattern): The pattern object defining the sequence of segments. The pattern object should have the following structure:
        - An integer representing the number of repetitions.
        - A list of floats representing the lengths of each segment in the pattern.
        - A float representing the scale factor for the lengths of the segments in the pattern.

    #### Returns:
    `list`: A list of Line objects that represent the line segments created according to the pattern along the baseline.

    #### Example usage:
    ```python
    baseline = Line(Point(0, 0, 0), Point(10, 0, 0))
    pattern_obj = (3, [2, 1], 1)  # 3 repetitions, pattern of lengths 2 and 1, scale factor 1
    patterned_lines = line_to_pattern(baseline, pattern_obj)
    # patterned_lines will be a list of Line objects according to the pattern
    ```

    The function works by calculating the total length of the pattern, the number of whole lengths of the pattern that fit into the baseline, and then generating the line segments according to these calculations. If the end of the baseline is reached before completing a pattern sequence, the last segment is adjusted to end at the baseline's end point.
    """
    # this converts a line to list of lines based on a pattern
    origin = baseline.start
    dir = Vector.by_two_points(baseline.start, baseline.end)
    unityvect = Vector.normalize(dir)

    Pattern = pattern_obj
    l = baseline.length
    patternlength = sum(Pattern[1]) * Pattern[2]
    # number of whole lengths of the pattern
    count = math.floor(l / patternlength)
    lines = []

    startpoint = origin
    ll = 0
    rl = 10000
    for i in range(count + 1):
        n = 0
        for i in Pattern[1]:
            deltaV = Vector.product(i * Pattern[2], unityvect)
            dl = Vector.length(deltaV)
            if rl < dl:  # this is the last line segment on the line where the pattern is going to be cut into pieces.
                endpoint = baseline.end
            else:
                endpoint = Point.translate(startpoint, deltaV)
            if n % 2:
                a = 1 + 1
            else:
                lines.append(Line(start=startpoint, end=endpoint))
            if rl < dl:
                break  # end of line reached
            startpoint = endpoint
            n = n + 1
            ll = ll + dl  # total length
            rl = l - ll  # remaining length within the pattern
        startpoint = startpoint
    return lines

def polycurve_to_pattern(polycurve: 'PolyCurve', pattern_obj) -> 'list':
    res = []
    for i in polycurve.curves:
       res.append(line_to_pattern(i,pattern_obj))
    return res


class Panel(Serializable):
    # Panel
    def __init__(self):
        
        self.extrusion = None
        self.thickness = 0
        self.name = None
        self.perimeter: float = 0
        self.colorint = None
        self.colorlst = []
        self.origincurve = None

    @classmethod
    def by_polycurve_thickness(self, polycurve: PolyCurve, thickness: float, offset: float, name: str, colorrgbint):
        # Create panel by polycurve
        p1 = Panel()
        p1.name = name
        p1.thickness = thickness
        p1.extrusion = Extrusion.by_polycurve_height(
            polycurve, thickness, offset)
        p1.origincurve = polycurve
        p1.colorint = colorrgbint
        for j in range(int(len(p1.extrusion.verts) / 3)):
            p1.colorlst.append(colorrgbint)
        return p1

    @classmethod
    def by_baseline_height(self, baseline: Line, height: float, thickness: float, name: str, colorrgbint):
        # place panel vertical from baseline
        p1 = Panel()
        p1.name = name
        p1.thickness = thickness
        polycurve = PolyCurve.by_points(
            [baseline.start,
             baseline.end,
             Point.translate(baseline.end, Vector(0, 0, height)),
             Point.translate(baseline.start, Vector(0, 0, height))])
        p1.extrusion = Extrusion.by_polycurve_height(polycurve, thickness, 0)
        p1.origincurve = polycurve
        for j in range(int(len(p1.extrusion.verts) / 3)):
            p1.colorlst.append(colorrgbint)
        return p1

jsonFile = "https://raw.githubusercontent.com/3BMLabs/Project-Ocondat/master/steelprofile.json"
url = urllib.request.urlopen(jsonFile)
data = json.loads(url.read())


def is_rectangle_format(shape_name):
    match = re.match(r'^(\d{1,4})x(\d{1,4})$', shape_name)
    if match:
        width, height = int(match.group(1)), int(match.group(2))
        if 0 <= width <= 10000 and 0 <= height <= 10000:
            return True, width, height
    return False, 0, 0


class _getProfileDataFromDatabase:
    def __init__(self, name):
        self.name = name
        self.shape_coords = None
        self.shape_name = None
        self.synonyms = None
        for item in data:
            for i in item.values():
                synonymList = i[0]["synonyms"]
                if self.name.lower() in [synonym.lower() for synonym in synonymList]:
                    self.shape_coords = i[0]["shape_coords"]
                    self.shape_name = i[0]["shape_name"]
                    self.synonyms = i[0]["synonyms"]
        if self.shape_coords == None:
            check_rect, width, height = is_rectangle_format(name)
            if check_rect:
                self.shape_coords = [width, height]
                self.shape_name = "Rectangle"
                self.synonyms = name


class nameToProfile:
    def __init__(self, name1, segmented = True):
        profile_data = _getProfileDataFromDatabase(name1)
        if profile_data == None:
            print(f"profile {name1} not recognised")
        profile_name = profile_data.shape_name
        if profile_name == None:
            profile_data = _getProfileDataFromDatabase(project.structural_fallback_element)
            print(f"Error, profile '{name1}' not recognised, define in {jsonFile} | fallback: '{project.structural_fallback_element}'")
            profile_name = profile_data.shape_name
        self.profile_data = profile_data
        self.profile_name = profile_name
        name = profile_data.name
        self.d1 = profile_data.shape_coords
        d1 = self.d1
        if profile_name == "C-channel parallel flange":
            prof = CChannelParallelFlange(name,d1[0],d1[1],d1[2],d1[3],d1[4],d1[5])
        elif profile_name == "C-channel sloped flange":
            prof = CChannelSlopedFlange(name,d1[0],d1[1],d1[2],d1[3],d1[4],d1[5],d1[6],d1[7],d1[8])
        elif profile_name == "I-shape parallel flange":
            prof = IShapeParallelFlange(name,d1[0],d1[1],d1[2],d1[3],d1[4])
        elif profile_name == "I-shape sloped flange":
            prof = IShapeParallelFlange(name, d1[0], d1[1], d1[2], d1[3], d1[4])
            #Todo: add sloped flange shape
        elif profile_name == "Rectangle":
            prof = Rectangle(name,d1[0], d1[1])
        elif profile_name == "Round":
            prof = Round(name, d1[1])
        elif profile_name == "Round tube profile":
            prof = Roundtube(name, d1[0], d1[1])
        elif profile_name == "LAngle":
            prof = LAngle(name,d1[0],d1[1],d1[2],d1[3],d1[4],d1[5],d1[6],d1[7])
        elif profile_name == "TProfile":
            prof = TProfileRounded(name, d1[0], d1[1], d1[2], d1[3], d1[4], d1[5], d1[6], d1[7], d1[8])
        elif profile_name == "Rectangle Hollow Section":
            prof = RectangleHollowSection(name,d1[0],d1[1],d1[2],d1[3],d1[4])
        self.profile = prof
        self.data = d1
        pc2d = self.profile.curve  # 2D polycurve
        if segmented == True:
            pc3d = PolyCurve.by_polycurve_2D(pc2d)
            pcsegment = PolyCurve.segment(pc3d, 10)
            pc2d2 = pcsegment.to_polycurve_2D()
        else:
            pc2d2 = pc2d
        self.polycurve2d = pc2d2

def justifictionToVector(plycrv2D: PolyCurve, XJustifiction, Yjustification, ey=None, ez=None):

    # print(XJustifiction)
    xval = []
    yval = []
    for i in plycrv2D.curves:
        xval.append(i.start.x)
        yval.append(i.start.y)

    #Rect
    xmin = min(xval)
    xmax = max(xval)
    ymin = min(yval)
    ymax = max(yval)

    b = xmax-xmin
    h = ymax-ymin

    # print(b, h)

    dxleft = -xmax
    dxright = -xmin
    dxcenter = dxleft - 0.5 * b #CHECK
    dxorigin = 0

    dytop = -ymax
    dybottom = -ymin
    dycenter = dytop - 0.5 * h #CHECK
    dyorigin = 0

    if XJustifiction == "center":
        dx = dxorigin #TODO
    elif XJustifiction == "left":
        dx = dxleft
    elif XJustifiction == "right":  
        dx = dxright
    elif XJustifiction == "origin":
        dx = dxorigin #TODO
    else:
        dx = 0

    if Yjustification == "center":
        dy = dyorigin   #TODO
    elif Yjustification == "top":
        dy = dytop
    elif Yjustification == "bottom":
        dy = dybottom
    elif Yjustification == "origin":
        dy = dyorigin #TODO
    else:
        dy = 0

    # print(dx, dy)
    v1 = Vector2(dx, dy)
    # v1 = Vector2(0, 0)

    return v1

def rgb_to_int(rgb):
    r, g, b = [max(0, min(255, c)) for c in rgb]

    return (255 << 24) | (r << 16) | (g << 8) | b

class Material:
    def __init__(self):
        self.name = "none"
        self.color = None
        self.colorint = None

    @classmethod
    def byNameColor(cls, name, color):
        M1 = Material()
        M1.name = name
        M1.color = color
        #M1.colorint = rgb_to_int(color)
        return M1

#Building Materials
BaseConcrete = Material.byNameColor("Concrete", Color().RGB([192, 192, 192]))
BaseTimber = Material.byNameColor("Timber", Color().RGB([191, 159, 116]))
BaseSteel = Material.byNameColor("Steel", Color().RGB([237, 28, 36]))
BaseOther = Material.byNameColor("Other", Color().RGB([150, 150, 150]))
BaseBrick = Material.byNameColor("Brick", Color().RGB([170, 77, 47]))
BaseBrickYellow = Material.byNameColor("BrickYellow", Color().RGB([208, 187, 147]))

#GIS Materials
BaseBuilding = Material.byNameColor("Building", Color().RGB([150, 28, 36]))
BaseWater = Material.byNameColor("Water", Color().RGB([139, 197, 214]))
BaseGreen = Material.byNameColor("Green", Color().RGB([175, 193, 138]))
BaseInfra = Material.byNameColor("Infra", Color().RGB([234, 234, 234]))
BaseRoads = Material.byNameColor("Infra", Color().RGB([140, 140, 140]))

#class Materialfinish

def colorlist(extrus, color):
    colorlst = []
    for j in range(int(len(extrus.verts) / 3)):
        colorlst.append(color)
    return (colorlst)


# ToDo Na update van color moet ook de colorlist geupdate worden
class Frame(Serializable):
    def __init__(self):
        
        self.name = "None"
        self.profileName = "None"
        self.extrusion = None
        self.comments = None
        self.structuralType = None
        self.start = None
        self.end = None
        self.curve = None  # 2D polycurve of the sectionprofile
        self.curve3d = None  # Translated 3D polycurve of the sectionprofile
        self.length = 0
        self.points = []
        self.coordinateSystem: CoordinateSystem = CSGlobal
        self.YJustification = "Origin"  # Top, Center, Origin, Bottom
        self.ZJustification = "Origin"  # Left, Center, Origin, Right
        self.YOffset = 0
        self.ZOffset = 0
        self.rotation = 0
        self.material : Material = None
        self.color = BaseOther.color
        self.profile_data = None #2D polycurve of the sectionprofile (DOUBLE TO BE REMOVED)
        self.profile = None #object of 2D profile
        self.colorlst = []
        self.vector = None
        self.vector_normalised = None
        self.centerbottom = None

    def props(self):
        self.vector = Vector(self.end.x-self.start.x,
                              self.end.y-self.start.y, self.end.z-self.start.z)
        self.vector_normalised = Vector.normalize(self.vector)
        self.length = Vector.length(self.vector)

    @classmethod
    def by_startpoint_endpoint(cls, start: Union[Point, Node], end: Union[Point, Node], profile: Union[str, Profile], name: str, material: None, comments=None):
        f1 = Frame()
        f1.comments = comments

        if start.type == 'Point':
            f1.start = start
        elif start.type == 'Node':
            f1.start = start.point
        if end.type == 'Point':
            f1.end = end
        elif end.type == 'Node':
            f1.end = end.point

        if isinstance(profile,Profile):
            f1.curve = profile.curve
            f1.profile = profile
        elif type(profile).__name__ == "str":
            res = nameToProfile(profile)
            f1.curve = res.polycurve2d  # polycurve2d
            f1.points = res.polycurve2d.points
            f1.profile = res.profile
        else:
            print("[by_startpoint_endpoint_profile], input is not correct.")
            sys.exit()

        f1.directionVector = Vector.by_two_points(f1.start, f1.end)
        f1.length = Vector.length(f1.directionVector)
        f1.name = name
        f1.extrusion = Extrusion.by_polycurve_height_vector(
            f1.curve, f1.length, CSGlobal, f1.start, f1.directionVector)
        f1.extrusion.name = name
        f1.curve3d = f1.extrusion.polycurve_3d_translated
        f1.profileName = profile
        f1.material = material
        f1.color = material.colorint
        f1.colorlst = colorlist(f1.extrusion, f1.color)
        f1.props()
        return f1

    @classmethod
    def by_startpoint_endpoint_profile_shapevector(cls, start: Union[Point, Node], end: Union[Point, Node], profile_name: str, name: str, vector2d: Vector, rotation: float, material: None, comments: None):
        f1 = Frame()
        f1.comments = comments

        if start.type == 'Point':
            f1.start = start
        elif start.type == 'Node':
            f1.start = start.point
        if end.type == 'Point':
            f1.end = end
        elif end.type == 'Node':
            f1.end = end.point
            
        #try:
        curv = nameToProfile(profile_name).polycurve2d
        #except Exception as e:
            # Profile does not exist
        #print(f"Profile does not exist: {profile_name}\nError: {e}")

        f1.rotation = rotation
        curvrot = curv.rotate(rotation)  # rotation in degrees
        f1.curve = curvrot.translate(vector2d)
        f1.XOffset = vector2d.x
        f1.YOffset = vector2d.y
        f1.directionVector = Vector.by_two_points(f1.start, f1.end)
        f1.length = Vector.length(f1.directionVector)
        f1.name = name
        f1.extrusion = Extrusion.by_polycurve_height_vector(
            f1.curve, f1.length, f1.start, f1.directionVector)
        f1.extrusion.name = name
        f1.curve3d = f1.extrusion.polycurve_3d_translated
        f1.profileName = profile_name
        f1.material = material
        f1.color = material.colorint
        f1.colorlst = colorlist(f1.extrusion, f1.color)
        f1.props()
        return f1

    @classmethod
    def by_startpoint_endpoint_profile_justifiction(cls, start: Union[Point, Node], end: Union[Point, Node], profile: Union[str, PolyCurve2D], name: str, XJustifiction: str, YJustifiction: str, rotation: float, material=None, ey: None = float, ez: None = float, structuralType: None = str, comments=None):
        f1 = Frame()
        f1.comments = comments

        if start.type == 'Point':
            f1.start = start
        elif start.type == 'Node':
            f1.start = start.point
        if end.type == 'Point':
            f1.end = end
        elif end.type == 'Node':
            f1.end = end.point

        f1.structuralType = structuralType
        f1.rotation = rotation

        if type(profile).__name__ == "PolyCurve2D":
            profile_name = "None"
            f1.profile_data = profile
            curve = f1.profile_data
        elif type(profile).__name__ == "Polygon":
            profile_name = "None"
            f1.profile_data = PolyCurve2D.by_points(profile.points)
            curve = f1.profile_data
        elif type(profile).__name__ == "str":
            profile_name = profile
            f1.profile_data = nameToProfile(profile).polycurve2d  # polycurve2d
            curve = f1.profile_data
        else:
            print("[by_startpoint_endpoint_profile], input is not correct.")
            sys.exit()

        # curve = f1.profile_data.polycurve2d

        v1 = justifictionToVector(curve, XJustifiction, YJustifiction)  # 1
        f1.XOffset = v1.x
        f1.YOffset = v1.y
        curve = curve.translate(v1)
        curve = curve.translate(Vector2(ey, ez))  # 2
        curve = curve.rotate(f1.rotation)  # 3
        f1.curve = curve

        f1.directionVector = Vector.by_two_points(f1.start, f1.end)
        f1.length = Vector.length(f1.directionVector)
        f1.name = name
        f1.extrusion = Extrusion.by_polycurve_height_vector(
            f1.curve, f1.length, CSGlobal, f1.start, f1.directionVector)
        f1.extrusion.name = name
        f1.curve3d = f1.extrusion.polycurve_3d_translated

        try:
            pnew = PolyCurve.by_joined_curves(f1.curve3d.curves)
            f1.centerbottom = PolyCurve.centroid(pnew)
        except:
            pass

        f1.profileName = profile_name
        f1.material = material
        f1.color = material.colorint
        f1.colorlst = colorlist(f1.extrusion, f1.color)
        f1.props()
        return f1

    @classmethod
    def by_startpoint_endpoint_rect(cls, start: Union[Point, Node], end: Union[Point, Node], width: float, height: float, name: str, rotation: float, material=None, comments=None):
        # 2D polycurve
        f1 = Frame()
        f1.comments = comments

        if start.type == 'Point':
            f1.start = start
        elif start.type == 'Node':
            f1.start = start.point
        if end.type == 'Point':
            f1.end = end
        elif end.type == 'Node':
            f1.end = end.point

        f1.directionVector = Vector.by_two_points(f1.start, f1.end)
        f1.length = Vector.length(f1.directionVector)
        f1.name = name

        prof = Rectangle(str(width)+"x"+str(height),width,height)
        polycurve = prof.curve
        f1.profile = prof
        curvrot = polycurve.rotate(rotation)
        f1.extrusion = Extrusion.by_polycurve_height_vector(
            curvrot, f1.length, CSGlobal, f1.start, f1.directionVector)
        f1.extrusion.name = name
        f1.curve3d = curvrot
        f1.profileName = name
        f1.material = material
        f1.color = material.colorint
        f1.colorlst = colorlist(f1.extrusion, f1.color)
        f1.props()
        return f1


    @classmethod
    def by_point_height_rotation(cls, start: Union[Point, Node], height: float, polycurve: PolyCurve2D, frame_name: str, rotation: float, material=None, comments=None):
        # 2D polycurve
        f1 = Frame()
        f1.comments = comments

        if start.type == 'Point':
            f1.start = start
        elif start.type == 'Node':
            f1.start = start.point

        f1.end = Point.translate(f1.start, Vector(0, 0.00001, height))

        # self.curve = Line(start, end)
        f1.directionVector = Vector.by_two_points(f1.start, f1.end)
        f1.length = Vector.length(f1.directionVector)
        f1.name = frame_name
        f1.profileName = frame_name
        curvrot = polycurve.rotate(rotation)  # rotation in degrees
        f1.extrusion = Extrusion.by_polycurve_height_vector(
            curvrot, f1.length, CSGlobal, f1.start, f1.directionVector)
        f1.extrusion.name = frame_name
        f1.curve3d = curvrot
        f1.material = material
        f1.color = material.colorint
        f1.colorlst = colorlist(f1.extrusion, f1.color)
        f1.props()
        return f1

    @classmethod
    def by_point_profile_height_rotation(cls, start: Union[Point, Node], height: float, profile_name: str, rotation: float, material=None, comments=None):
        f1 = Frame()
        f1.comments = comments

        if start.type == 'Point':
            f1.start = start
        elif start.type == 'Node':
            f1.start = start.point
        # TODO vertical column not possible
        f1.end = Point.translate(f1.start, Vector(0, height))

        # self.curve = Line(start, end)
        f1.directionVector = Vector.by_two_points(f1.start, f1.end)
        f1.length = Vector.length(f1.directionVector)
        f1.name = profile_name
        f1.profileName = profile_name
        curv = nameToProfile(profile_name).polycurve2d
        curvrot = curv.rotate(rotation)  # rotation in degrees
        f1.extrusion = Extrusion.by_polycurve_height_vector(
            curvrot.curves, f1.length, CSGlobal, f1.start, f1.directionVector)
        f1.extrusion.name = profile_name
        f1.curve3d = curvrot
        f1.profileName = profile_name
        f1.material = material
        f1.color = material.colorint
        f1.colorlst = colorlist(f1.extrusion, f1.color)
        f1.props()
        return f1

    @classmethod
    def by_startpoint_endpoint_curve_justifiction(cls, start: Union[Point, Node], end: Union[Point, Node], polycurve: PolyCurve2D, name: str, XJustifiction: str, YJustifiction: str, rotation: float, material=None, comments=None):
        f1 = Frame()
        f1.comments = comments

        if start.type == 'Point':
            f1.start = start
        elif start.type == 'Node':
            f1.start = start.point
        if end.type == 'Point':
            f1.end = end
        elif end.type == 'Node':
            f1.end = end.point

        f1.rotation = rotation
        curv = polycurve
        curvrot = curv.rotate(rotation)  # rotation in degrees
        # center, left, right, origin / center, top bottom, origin
        v1 = justifictionToVector(curvrot, XJustifiction, YJustifiction)
        f1.XOffset = v1.x
        f1.YOffset = v1.y
        f1.curve = curv.translate(v1)
        f1.directionVector = Vector.by_two_points(f1.start, f1.end)
        f1.length = Vector.length(f1.directionVector)
        f1.name = name
        f1.extrusion = Extrusion.by_polycurve_height_vector(
            f1.curve.curves, f1.length, CSGlobal, f1.start, f1.directionVector)
        f1.extrusion.name = name
        f1.profileName = "none"
        f1.material = material
        f1.color = material.colorint
        f1.colorlst = colorlist(f1.extrusion, f1.color)
        f1.props()
        return f1

    def write(self, project):
        project.objects.append(self)
        return self



class System:
    """Represents a generic system with a defined direction."""
    def __init__(self):
        """Initializes a new System instance.
        
        - `type` (str): The class name, indicating the object type as "System".
        - `name` (str, optional): The name of the system.
        - `id` (str): A unique identifier for the system instance.
        - `polycurve` (PolyCurve, optional): An optional PolyCurve associated with the system.
        - `direction` (Vector): A Vector indicating the primary direction of the system.
        """
        self.name = None
        
        self.polycurve = None
        self.direction: Vector = Vector(1, 0, 0)


class DivisionSystem:
    # This class provides divisionsystems. It returns lists with floats based on a length.
    """The `DivisionSystem` class manages division systems, providing functionalities to calculate divisions and spacings based on various criteria."""
    def __init__(self):
        """Initializes a new DivisionSystem instance.

        - `type` (str): The class name, "DivisionSystem".
        - `name` (str): The name of the division system.
        - `id` (str): A unique identifier for the division system instance.
        - `system_length` (float): The total length of the system to be divided.
        - `spacing` (float): The spacing between divisions.
        - `distance_first` (float): The distance of the first division from the start of the system.
        - `width_stud` (float): The width of a stud, applicable in certain division strategies.
        - `fixed_number` (int): A fixed number of divisions.
        - `modifier` (int): A modifier value that adjusts the number of divisions or their placement.
        - `distances` (list): A list containing the cumulative distances of each division from the start.
        - `spaces` (list): A list containing the spaces between each division.
        - `system` (str): A string indicating the current system strategy (e.g., "fixed_distance_unequal_division").
        """
        self.name = None
        
        self.system_length: float = 100
        self.spacing: float = 10
        self.distance_first: float = 5
        self.width_stud: float = 10
        self.fixed_number: int = 2
        self.modifier: int = 0
        self.distances = []  # List with sum of distances
        self.spaces = []  # List with spaces between every divison
        self.system: str = "fixed_distance_unequal_division"

    def __fixed_number_equal_spacing(self):
        """Calculates divisions based on a fixed number with equal spacing.
        This internal method sets up divisions across the system length, ensuring each division is equally spaced. It is triggered by configurations that require a fixed number of divisions, automatically adjusting the spacing to fit the total length.

        #### Effects:
        - Sets the division system name to "fixed_number_equal_spacing".
        - Calculates equal spacing between divisions based on the total system length and the fixed number of divisions.
        - Resets the modifier to 0, as it is not applicable in this configuration.
        - Assigns the calculated spacing to `distance_first` to maintain consistency at the start of the system.
        """
        self.name = "fixed_number_equal_spacing"
        self.distances = Interval.by_start_end_count(
            0, self.system_length, self.fixed_number)
        self.spacing = self.system_length / self.fixed_number
        self.modifier = 0
        self.distance_first = self.spacing

    def __fixed_distance_unequal_division(self):
        """Configures divisions with a fixed starting distance followed by unequal divisions.
        This internal method configures the division system to start with a specified distance for the first division, then continues with divisions spaced according to `spacing`. If the total length cannot be evenly divided, the last division's spacing may differ.

        #### Effects:
        - Sets the division system name to "fixed_distance_unequal_division".
        - Calculates the number of divisions based on the spacing and the total system length minus the first division's distance.
        - Generates a list of distances where each division should occur, considering the initial distance and spacing.
        """
        self.name = "fixed_distance_unequal_division"
        rest_length = self.system_length - self.distance_first
        number_of_studs = int(rest_length / self.spacing)
        number_of_studs = number_of_studs + self.modifier
        distance = self.distance_first
        for i in range(number_of_studs+1):
            if distance < self.system_length:
                self.distances.append(distance)
            else:
                break
            distance = distance + self.spacing

    def __fixed_distance_equal_division(self):
        """Creates divisions with equal spacing across the total system length.
        An internal method that evenly distributes divisions across the system's length. It takes into account the total length and the desired spacing to calculate the number of divisions, ensuring they are equally spaced.

        #### Effects:
        - Sets the division system name to "fixed_distance_equal_division".
        - Calculates the number of divisions based on the desired spacing and total length.
        - Determines the starting distance for the first division to ensure all divisions, including the first and last, are equally spaced within the system length.
        """
        self.name = "fixed_distance_equal_division"
        number_of_studs = int(self.system_length / self.spacing)
        number_of_studs = number_of_studs + self.modifier
        sum_length_studs_x_spacing = (number_of_studs - 1) * self.spacing
        rest_length = self.system_length - sum_length_studs_x_spacing
        distance = rest_length / 2
        for i in range(number_of_studs):
            self.distances.append(distance)
            distance = distance + self.spacing

    def by_fixed_distance_unequal_division(self, length: float, spacing: float, distance_first: float, modifier: int) -> 'DivisionSystem':
        """Configures the division system for unequal divisions with a specified distance first.
        This method sets up the division system to calculate divisions based on a fixed initial distance, followed by unevenly spaced divisions according to the specified parameters.

        #### Parameters:
        - `length` (float): The total length of the system to be divided.
        - `spacing` (float): The target spacing between divisions.
        - `distance_first` (float): The distance of the first division from the system's start.
        - `modifier` (int): An integer modifier to adjust the calculation of divisions.

        #### Returns:
        `DivisionSystem`: The instance itself, updated with the new division configuration.

        #### Example usage:
        ```python
        division_system = DivisionSystem()
        division_system.by_fixed_distance_unequal_division(100, 10, 5, 0)
        ```
        """
        self.system_length = length
        self.modifier = modifier
        self.spacing = spacing
        self.distance_first = distance_first
        self.system = "fixed_distance_unequal_division"
        self.__fixed_distance_unequal_division()
        return self

    def by_fixed_distance_equal_division(self, length: float, spacing: float, modifier: int) -> 'DivisionSystem':
        """Configures the division system for equal divisions with fixed spacing.
        This method sets up the division system to calculate divisions based on a fixed spacing between each division across the total system length. The modifier can adjust the calculation slightly but maintains equal spacing.

        #### Parameters:
        - `length` (float): The total length of the system to be divided.
        - `spacing` (float): The spacing between each division.
        - `modifier` (int): An integer modifier to fine-tune the division process.

        #### Returns:
        `DivisionSystem`: The instance itself, updated with the new division configuration.

        #### Example usage:
        ```python
        division_system = DivisionSystem()
        division_system.by_fixed_distance_equal_division(100, 10, 0)
        ```
        """
        self.system_length = length
        self.modifier = modifier
        self.spacing = spacing
        self.system = "fixed_distance_equal_division"
        self.__fixed_distance_equal_division()
        return self

    def by_fixed_number_equal_spacing(self, length: float, number: int) -> 'DivisionSystem':
        """Establishes the division system for a fixed number of divisions with equal spacing.
        This method arranges for a certain number of divisions to be spaced equally across the system length. It calculates the required spacing based on the total length and desired number of divisions.

        #### Parameters:
        - `length` (float): The total length of the system to be divided.
        - `number` (int): The fixed number of divisions to be created.

        #### Returns:
        `DivisionSystem`: The instance itself, updated with the new division configuration.

        #### Example usage:
        ```python
        division_system = DivisionSystem()
        division_system.by_fixed_number_equal_spacing(100, 5)
        ```
        """
        self.system_length = length
        self.system = "fixed_number_equal_spacing"
        self.spacing = length/number
        self.modifier = 0
        distance = self.spacing
        for i in range(number-1):
            self.distances.append(distance)
            distance = distance + self.spacing
        self.distance_first = self.spacing
        return self

        #  fixed_number_equal_interior_fill
        #  maximum_spacing_equal_division
        #  maximum_spacing_unequal_division
        #  minimum_spacing_equal_division
        #  minimum_spacing_unequal_division


class RectangleSystem:
    # Reclangle Left Bottom is in Local XYZ. Main direction parallel to height direction vector. Top is z=0
    """The `RectangleSystem` class is designed to represent and manipulate rectangular systems, focusing on dimensions, frame types, and panel arrangements within a specified coordinate system."""
    def __init__(self):
        """Initializes a new RectangleSystem instance.
        
        - `type` (str): Class name, indicating the object type as "RectangleSystem".
        - `name` (str, optional): The name of the rectangle system.
        - `id` (str): A unique identifier for the rectangle system instance.
        - `height` (float): The height of the rectangle system.
        - `width` (float): The width of the rectangle system.
        - `bottom_frame_type` (Rectangle): A `Rectangle` instance for the bottom frame type.
        - `top_frame_type` (Rectangle): A `Rectangle` instance for the top frame type.
        - `left_frame_type` (Rectangle): A `Rectangle` instance for the left frame type.
        - `right_frame_type` (Rectangle): A `Rectangle` instance for the right frame type.
        - `inner_frame_type` (Rectangle): A `Rectangle` instance for the inner frame type.
        - `material` (BaseTimber): The material used for the system, pre-defined as `BaseTimber`.
        - `inner_width` (float): The computed inner width of the rectangle system, excluding the width of the left and right frames.
        - `inner_height` (float): The computed inner height of the rectangle system, excluding the height of the top and bottom frames.
        - `coordinatesystem` (CSGlobal): A global coordinate system applied to the rectangle system.
        - `local_coordinate_system` (CSGlobal): A local coordinate system specific to the rectangle system.
        - `division_system` (DivisionSystem, optional): A `DivisionSystem` instance to manage divisions within the rectangle system.
        - `inner_frame_objects` (list): A list of inner frame objects within the rectangle system.
        - `outer_frame_objects` (list): A list of outer frame objects.
        - `panel_objects` (list): A list of panel objects used within the system.
        - `symbolic_inner_mother_surface` (PolyCurve, optional): A symbolic representation of the inner mother surface.
        - `symbolic_inner_panels` (list, optional): Symbolic representations of inner panels.
        - `symbolic_outer_grids` (list): Symbolic representations of outer grids.
        - `symbolic_inner_grids` (list): Symbolic representations of inner grids.
        """
        self.name = None
        
        self.height = 3000
        self.width = 2000
        self.bottom_frame_type = Rectangle("bottom_frame_type", 38, 184)
        self.top_frame_type = Rectangle("top_frame_type", 38, 184)
        self.left_frame_type = Rectangle("left_frame_type", 38, 184)
        self.right_frame_type = Rectangle("left_frame_type", 38, 184)
        self.inner_frame_type = Rectangle("inner_frame_type", 38, 184)

        self.material = BaseTimber
        self.inner_width: float = 0
        self.inner_height: float = 0
        self.coordinatesystem = CSGlobal
        self.local_coordinate_system = CSGlobal
        # self.openings = []
        # self.subsystems = []
        self.division_system = None
        self.inner_frame_objects = []
        self.outer_frame_objects = []
        self.panel_objects = []
        self.symbolic_inner_mother_surface = None
        self.symbolic_inner_panels = None
        self.symbolic_outer_grids = []
        self.symbolic_inner_grids = []

    def __inner_panels(self):
        """Calculates and creates inner panel objects for the RectangleSystem.
        This method iteratively calculates the positions and dimensions of inner panels based on the division system's distances and the inner frame type's width. It populates the `panel_objects` list with created panels.

        #### Effects:
        - Populates `panel_objects` with Panel instances representing the inner panels of the rectangle system.
        """
        # First Inner panel
        i = self.division_system.distances[0]
        point1 = self.mother_surface_origin_point_x_zero
        point2 = Point.translate(self.mother_surface_origin_point_x_zero, Vector(
            i - self.inner_frame_type.b * 0.5, 0, 0))
        point3 = Point.translate(self.mother_surface_origin_point_x_zero,
                                 Vector(i - self.inner_frame_type.b * 0.5, self.inner_height, 0))
        point4 = Point.translate(
            self.mother_surface_origin_point_x_zero, Vector(0, self.inner_height, 0))
        self.panel_objects.append(
            Panel.by_polycurve_thickness(
                PolyCurve.by_points(
                    [point1, point2, point3, point4, point1]), 184, 0, "innerpanel",
                rgb_to_int([255, 240, 160]))
        )
        count = 0
        # In between
        for i in self.division_system.distances:
            try:
                point1 = Point.translate(self.mother_surface_origin_point_x_zero, Vector(
                    self.division_system.distances[count]+self.inner_frame_type.b*0.5, 0, 0))
                point2 = Point.translate(self.mother_surface_origin_point_x_zero, Vector(
                    self.division_system.distances[count+1]-self.inner_frame_type.b*0.5, 0, 0))
                point3 = Point.translate(self.mother_surface_origin_point_x_zero, Vector(
                    self.division_system.distances[count+1]-self.inner_frame_type.b*0.5, self.inner_height, 0))
                point4 = Point.translate(self.mother_surface_origin_point_x_zero, Vector(
                    self.division_system.distances[count]+self.inner_frame_type.b*0.5, self.inner_height, 0))
                self.panel_objects.append(
                    Panel.by_polycurve_thickness(
                        PolyCurve.by_points([point1, point2, point3, point4, point1]), 184, 0, "innerpanel", rgb_to_int([255, 240, 160]))
                )
                count = count + 1
            except:
                # Last panel
                point1 = Point.translate(self.mother_surface_origin_point_x_zero, Vector(
                    self.division_system.distances[count]+self.inner_frame_type.b*0.5, 0, 0))
                point2 = Point.translate(self.mother_surface_origin_point_x_zero, Vector(
                    self.inner_width+self.left_frame_type.b, 0, 0))
                point3 = Point.translate(self.mother_surface_origin_point_x_zero, Vector(
                    self.inner_width+self.left_frame_type.b, self.inner_height, 0))
                point4 = Point.translate(self.mother_surface_origin_point_x_zero, Vector(
                    self.division_system.distances[count]+self.inner_frame_type.b*0.5, self.inner_height, 0))
                self.panel_objects.append(
                    Panel.by_polycurve_thickness(
                        PolyCurve.by_points([point1, point2, point3, point4, point1]), 184, 0, "innerpanel", rgb_to_int([255, 240, 160]))
                )
                count = count + 1

    def __inner_mother_surface(self):
        """Determines the inner mother surface dimensions and creates its symbolic representation.
        Calculates the inner width and height by subtracting the frame widths from the total width and height. It then constructs a symbolic PolyCurve representing the mother surface within the rectangle system's frames.

        #### Effects:
        - Updates `inner_width` and `inner_height` attributes based on frame dimensions.
        - Creates a symbolic PolyCurve `symbolic_inner_mother_surface` representing the inner mother surface.
        """
        # Inner mother surface is the surface within the outer frames dependent on the width of the outer frametypes.
        self.inner_width = self.width-self.left_frame_type.b-self.right_frame_type.b
        self.inner_height = self.height-self.top_frame_type.b-self.bottom_frame_type.b
        self.mother_surface_origin_point = Point(
            self.left_frame_type.b, self.bottom_frame_type.b, 0)
        self.mother_surface_origin_point_x_zero = Point(
            0, self.bottom_frame_type.b, 0)
        self.symbolic_inner_mother_surface = PolyCurve.by_points(
            [self.mother_surface_origin_point,
             Point.translate(self.mother_surface_origin_point,
                             Vector(self.inner_width, 0, 0)),
             Point.translate(self.mother_surface_origin_point, Vector(
                 self.inner_width, self.inner_height, 0)),
             Point.translate(self.mother_surface_origin_point,
                             Vector(0, self.inner_height, 0)),
             self.mother_surface_origin_point]
        )

    def __inner_frames(self):
        """Creates inner frame objects based on division distances within the rectangle system.
        Utilizes the division distances to place vertical frames across the inner width of the rectangle system. These frames are represented both as Frame objects within the system and as symbolic lines for visualization.

        #### Effects:
        - Generates Frame objects for each division, placing them vertically within the rectangle system.
        - Populates `inner_frame_objects` with these Frame instances.
        - Adds symbolic representations of these frames to `symbolic_inner_grids`.
        """
        for i in self.division_system.distances:
            start_point = Point.translate(
                self.mother_surface_origin_point_x_zero, Vector(i, 0, 0))
            end_point = Point.translate(
                self.mother_surface_origin_point_x_zero, Vector(i, self.inner_height, 0))
            self.inner_frame_objects.append(
                Frame.by_start_point_endpoint_curve_justifiction(
                    start_point, end_point, self.inner_frame_type.curve, "innerframe", "center", "top", 0, self.material)
            )
            self.symbolic_inner_grids.append(
                Line(start=start_point, end=end_point))

    def __outer_frames(self):
        """Generates the outer frame objects for the rectangle system.
        Creates Frame objects for the bottom, top, left, and right boundaries of the rectangle system. Each frame is defined by its start and end points, along with its type and material. Symbolic lines representing these frames are also generated for visualization.

        #### Effects:
        - Creates Frame instances for the outer boundaries of the rectangle system and adds them to `outer_frame_objects`.
        - Generates symbolic Line instances for each outer frame and adds them to `symbolic_outer_grids`.
        """
        bottomframe = Frame.by_start_point_endpoint_curve_justifiction(Point(0, 0, 0), Point(
            self.width, 0, 0), self.bottom_frame_type.curve, "bottomframe", "left", "top", 0, self.material)
        self.symbolic_outer_grids.append(
            Line(start=Point(0, 0, 0), end=Point(self.width, 0, 0)))

        topframe = Frame.by_start_point_endpoint_curve_justifiction(Point(0, self.height, 0), Point(
            self.width, self.height, 0), self.top_frame_type.curve, "bottomframe", "right", "top", 0, self.material)
        self.symbolic_outer_grids.append(
            Line(start=Point(0, self.height, 0), end=Point(self.width, self.height, 0)))

        leftframe = Frame.by_start_point_endpoint_curve_justifiction(Point(0, self.bottom_frame_type.b, 0), Point(
            0, self.height-self.top_frame_type.b, 0), self.left_frame_type.curve, "leftframe", "right", "top", 0, self.material)
        self.symbolic_outer_grids.append(Line(start=Point(
            0, self.bottom_frame_type.b, 0), end=Point(0, self.height-self.top_frame_type.b, 0)))

        rightframe = Frame.by_start_point_endpoint_curve_justifiction(Point(self.width, self.bottom_frame_type.b, 0), Point(
            self.width, self.height-self.top_frame_type.b, 0), self.right_frame_type.curve, "leftframe", "left", "top", 0, self.material)
        self.symbolic_outer_grids.append(Line(start=Point(self.width, self.bottom_frame_type.b, 0), end=Point(
            self.width, self.height-self.top_frame_type.b, 0)))

        self.outer_frame_objects.append(bottomframe)
        self.outer_frame_objects.append(topframe)
        self.outer_frame_objects.append(leftframe)
        self.outer_frame_objects.append(rightframe)

    def by_width_height_divisionsystem_studtype(self, width: float, height: float, frame_width: float, frame_height: float, division_system: DivisionSystem, filling: bool) -> 'RectangleSystem':
        """Configures the rectangle system with specified dimensions, division system, and frame types.
        This method sets the dimensions of the rectangle system, configures the frame types based on the provided dimensions, and applies a division system to generate inner frames. Optionally, it can also fill the system with panels based on the inner divisions.

        #### Parameters:
        - `width` (float): The width of the rectangle system.
        - `height` (float): The height of the rectangle system.
        - `frame_width` (float): The width of the frame elements.
        - `frame_height` (float): The height (thickness) of the frame elements.
        - `division_system` (DivisionSystem): The division system to apply for inner divisions.
        - `filling` (bool): A flag indicating whether to fill the divided areas with panels.

        #### Returns:
        `RectangleSystem`: The instance itself, updated with the new configuration.

        #### Example usage:
        ```python
        rectangle_system = RectangleSystem()
        rectangle_system.by_width_height_divisionsystem_studtype(2000, 3000, 38, 184, divisionSystem, True)
        ```
        """
        self.width = width
        self.height = height
        self.bottom_frame_type = Rectangle(
            "bottom_frame_type", frame_width, frame_height)
        self.top_frame_type = Rectangle(
            "top_frame_type", frame_width, frame_height)
        self.left_frame_type = Rectangle(
            "left_frame_type", frame_width, frame_height)
        self.right_frame_type = Rectangle(
            "left_frame_type", frame_width, frame_height)
        self.inner_frame_type = Rectangle(
            "inner_frame_type", frame_width, frame_height)
        self.division_system = division_system
        self.__inner_mother_surface()
        self.__inner_frames()
        self.__outer_frames()
        if filling:
            self.__inner_panels()
        else:
            pass
        return self


class pattern_system:
    """The `pattern_system` class is designed to define and manipulate patterns for architectural or design applications. It is capable of generating various patterns based on predefined or dynamically generated parameters."""
    def __init__(self):
        """Initializes a new pattern_system instance."""
        self.name = None
        
        self.pattern = None
        self.basepanels = []  # contains a list with basepanels of the system
        # contains a list sublists with Vector which represent the repetition of the system
        self.vectors = []

    def stretcher_bond_with_joint(self, name: str, brick_width: float, brick_length: float, brick_height: float, joint_width: float, joint_height: float):
        """Configures a stretcher bond pattern with joints for the pattern_system.
        Establishes the fundamental vectors and base panels for a stretcher bond, taking into account brick dimensions and joint sizes. This pattern alternates bricks in each row, offsetting them by half a brick length.

        #### Parameters:
        - `name` (str): Name of the pattern configuration.
        - `brick_width` (float): Width of the brick.
        - `brick_length` (float): Length of the brick.
        - `brick_height` (float): Height of the brick.
        - `joint_width` (float): Width of the joint between bricks.
        - `joint_height` (float): Height of the joint between brick layers.

        #### Returns:
        The instance itself, updated with the stretcher bond pattern configuration.
    
        #### Example usage:
        ```python

        ```
        """
        self.name = name
        # Vectors of panel 1
        V1 = Vector(0, (brick_height + joint_height)*2, 0)  # dy
        V2 = Vector(brick_length+joint_width, 0, 0)  # dx
        self.vectors.append([V1, V2])

        # Vectors of panel 2
        V3 = Vector(0, (brick_height + joint_height) * 2, 0)  # dy
        V4 = Vector(brick_length + joint_width, 0, 0)  # dx
        self.vectors.append([V3, V4])

        dx = (brick_length+joint_width)/2
        dy = brick_height+joint_height

        PC1 = PolyCurve().by_points([Point(0, 0, 0), Point(0, brick_height, 0), Point(
            brick_length, brick_height, 0), Point(brick_length, 0, 0), Point(0, 0, 0)])
        PC2 = PolyCurve().by_points([Point(dx, dy, 0), Point(dx, brick_height+dy, 0), Point(
            brick_length+dx, brick_height+dy, 0), Point(brick_length+dx, dy, 0), Point(dx, dy, 0)])
        BasePanel1 = Panel.by_polycurve_thickness(
            PC1, brick_width, 0, "BasePanel1", BaseBrick.colorint)
        BasePanel2 = Panel.by_polycurve_thickness(
            PC2, brick_width, 0, "BasePanel2", BaseBrick.colorint)

        self.basepanels.append(BasePanel1)
        self.basepanels.append(BasePanel2)
        return self

    def tile_bond_with_joint(self, name: str, tile_width: float, tile_height: float, tile_thickness: float, joint_width: float, joint_height: float):
        """Configures a tile bond pattern with specified dimensions and joint sizes for the pattern_system.
        Defines a simple tiling pattern where tiles are laid out in rows and columns, separated by specified joint widths and heights. This method sets up base panels to represent individual tiles and their arrangement vectors.

        #### Parameters:
        - `name` (str): The name of the tile bond pattern configuration.
        - `tile_width` (float): The width of a single tile.
        - `tile_height` (float): The height of a single tile.
        - `tile_thickness` (float): The thickness of the tile.
        - `joint_width` (float): The width of the joint between adjacent tiles.
        - `joint_height` (float): The height of the joint between tile rows.

        #### Returns:
        The instance itself, updated with the tile bond pattern configuration.

        #### Example Usage:
        ```python
        pattern_system = pattern_system()
        pattern_system.tile_bond_with_joint('TilePattern', 200, 300, 10, 5, 5)
        ```
        This configures the `pattern_system` with a tile bond pattern named 'TilePattern', where each tile measures 200x300x10 units, with 5 units of spacing between tiles.
        """
        self.name = name
        # Vectors of panel 1
        V1 = Vector(0, (tile_height + joint_height), 0)  # dy
        V2 = Vector(tile_width+joint_width, 0, 0)  # dx
        self.vectors.append([V1, V2])

        PC1 = PolyCurve().by_points([Point(0, 0, 0), Point(0, tile_height, 0), Point(
            tile_width, tile_height, 0), Point(tile_width, 0, 0)])
        BasePanel1 = Panel.by_polycurve_thickness(
            PC1, tile_thickness, 0, "BasePanel1", BaseBrick.colorint)

        self.basepanels.append(BasePanel1)
        return self

    def cross_bond_with_joint(self, name: str, brick_width: float, brick_length: float, brick_height: float, joint_width: float, joint_height: float):
        """Configures a cross bond pattern with joints for the pattern_system.
        Sets up a complex brick laying pattern combining stretcher (lengthwise) and header (widthwise) bricks in alternating rows, creating a cross bond appearance. This method defines the base panels and their positioning vectors to achieve the cross bond pattern.

        #### Parameters:
        - `name` (str): The name of the cross bond pattern configuration.
        - `brick_width` (float): The width of a single brick.
        - `brick_length` (float): The length of the brick.
        - `brick_height` (float): The height of the brick layer.
        - `joint_width` (float): The width of the joint between bricks.
        - `joint_height` (float): The height of the joint between brick layers.

        #### Returns:
        The instance itself, updated with the cross bond pattern configuration.

        #### Example Usage:
        ```python
        pattern_system = pattern_system()
        pattern_system.cross_bond_with_joint('CrossBondPattern', 90, 190, 80, 10, 10)
        ```
        In this configuration, `pattern_system` is set to a cross bond pattern named 'CrossBondPattern', with bricks measuring 90x190x80 units and 10 units of joint spacing in both directions.
        """
        self.name = name
        lagenmaat = brick_height + joint_height
        # Vectors of panel 1 (strek)
        V1 = Vector(0, (brick_height + joint_height) * 4, 0)  # dy spacing
        V2 = Vector(brick_length + joint_width, 0, 0)  # dx spacing
        self.vectors.append([V1, V2])

        # Vectors of panel 2 (koppen 1)
        V3 = Vector(0, (brick_height + joint_height) * 2, 0)  # dy spacing
        V4 = Vector(brick_length + joint_width, 0, 0)  # dx spacing
        self.vectors.append([V3, V4])

        dx2 = (brick_width + joint_width)/2  # start x offset
        dy2 = lagenmaat  # start y offset

        # Vectors of panel 3 (strekken)
        V5 = Vector(0, (brick_height + joint_height) * 4, 0)  # dy spacing
        V6 = Vector(brick_length + joint_width, 0, 0)  # dx spacing
        self.vectors.append([V5, V6])

        dx3 = (brick_length + joint_width)/2  # start x offset
        dy3 = lagenmaat * 2  # start y offset

        # Vectors of panel 4 (koppen 2)
        V7 = Vector(0, (brick_height + joint_height) * 2, 0)  # dy spacing
        V8 = Vector(brick_length + joint_width, 0, 0)  # dx spacing
        self.vectors.append([V7, V8])

        dx4 = (brick_width + joint_width)/2 + \
            (brick_width + joint_width)  # start x offset
        dy4 = lagenmaat  # start y offset

        PC1 = PolyCurve().by_points([Point(0, 0, 0), Point(0, brick_height, 0), Point(
            brick_length, brick_height, 0), Point(brick_length, 0, 0), Point(0, 0, 0)])
        PC2 = PolyCurve().by_points([Point(dx2, dy2, 0), Point(dx2, brick_height+dy2, 0), Point(
            brick_width+dx2, brick_height+dy2, 0), Point(brick_width+dx2, dy2, 0), Point(dx2, dy2, 0)])
        PC3 = PolyCurve().by_points([Point(dx3, dy3, 0), Point(dx3, brick_height+dy3, 0), Point(
            brick_length+dx3, brick_height+dy3, 0), Point(brick_length+dx3, dy3, 0), Point(dx3, dy3, 0)])
        PC4 = PolyCurve().by_points([Point(dx4, dy4, 0), Point(dx4, brick_height+dy4, 0), Point(
            brick_width+dx4, brick_height+dy4, 0), Point(brick_width+dx4, dy4, 0), Point(dx4, dy4, 0)])

        BasePanel1 = Panel.by_polycurve_thickness(
            PC1, brick_width, 0, "BasePanel1", BaseBrick.colorint)
        BasePanel2 = Panel.by_polycurve_thickness(
            PC2, brick_width, 0, "BasePanel2", BaseBrick.colorint)
        BasePanel3 = Panel.by_polycurve_thickness(
            PC3, brick_width, 0, "BasePanel3", BaseBrick.colorint)
        BasePanel4 = Panel.by_polycurve_thickness(
            PC4, brick_width, 0, "BasePanel4", BaseBrickYellow.colorint)

        self.basepanels.append(BasePanel1)
        self.basepanels.append(BasePanel2)
        self.basepanels.append(BasePanel3)
        self.basepanels.append(BasePanel4)

        return self


def pattern_geom(pattern_system, width: float, height: float, start_point: Point = None) -> list[Panel]:
    """Generates a geometric pattern based on a pattern_system within a specified area.
    Takes a pattern_system and fills a defined width and height area starting from an optional start point with the pattern described by the system.

    #### Parameters:
    - `pattern_system`: The pattern_system instance defining the pattern.
    - `width` (float): Width of the area to fill with the pattern.
    - `height` (float): Height of the area to fill with the pattern.
    - `start_point` (Point, optional): Starting point for the pattern generation.

    #### Returns:
    `list[Panel]`: A list of Panel instances constituting the generated pattern.
    
    #### Example usage:
    ```python

    ```
    """
    start_point = start_point or Point(0, 0, 0)
    test = pattern_system
    panels = []

    for i, j in zip(test.basepanels, test.vectors):
        ny = int(height / (j[0].y))  # number of panels in y-direction
        nx = int(width / (j[1].x))  # number of panels in x-direction
        PC = i.origincurve
        thickness = i.thickness
        color = i.colorint

        # YX ARRAY
        yvectdisplacement = j[0]
        yvector = Point.to_vector(start_point)
        xvectdisplacement = j[1]
        xvector = Vector(0, 0, 0)

        ylst = []
        for k in range(ny):
            yvector = yvectdisplacement + yvector
            for l in range(nx):
                # Copy in x-direction
                xvector = xvectdisplacement + xvector
                xyvector = yvector + xvector
                # translate curve in x and y-direction
                PCNew = PolyCurve.copy_translate(PC, xyvector)
                pan = Panel.by_polycurve_thickness(
                    PCNew, thickness, 0, "name", color)
                panels.append(pan)
            xvector = Vector.sum(
                xvectdisplacement, Vector(-test.basepanels[0].origincurve.curves[1].length, 0, 0))
    return panels


def fillin(perimeter: PolyCurve2D, pattern: pattern_geom) -> pattern_system:
    """Fills in a given perimeter with a specified pattern.
    Uses a bounding box to define the perimeter within which a pattern is applied, based on a geometric pattern generation function.

    #### Parameters:
    - `perimeter` (PolyCurve2D): The 2D perimeter to fill in.
    - `pattern` (function): The pattern generation function to apply within the perimeter.

    #### Returns:
    `pattern_system`: A pattern_system object that represents the filled-in area.
    
    #### Example usage:
    ```python

    ```
    """

    bb = Rect().by_points(perimeter.points)

    for pt in bb.corners:
        project.objects.append(pt)
    bb_perimeter = PolyCurve.by_points(bb.corners)

    return [bb_perimeter]


# EVERYWHERE FOR EACH OBJECT A ROTATION/POSITION
# Make sure that the objects can be merged!

class WurksRaster3d(Serializable):
    def __init__(self):
        
        self.bottom = None
        self.top = None
        self.name = "x"
        self.lines = None

    def serialize(self):
        id_value = str(self.id) if not isinstance(
            self.id, (str, int, float)) else self.id
        return {
            'id': id_value,
            'type': self.type,
            'bottom': self.bottom.serialize() if self.bottom else None,
            'top': self.top.serialize() if self.top else None,
            'name': self.name,
            'lines': [line.serialize() for line in self.lines] if self.lines else None
        }

    @staticmethod
    def deserialize(data):
        wurks_raster3d = WurksRaster3d()
        wurks_raster3d.id = data.get('id')
        wurks_raster3d.type = data.get('type')
        wurks_raster3d.bottom = Surface.deserialize(
            data['bottom']) if 'bottom' in data else None
        wurks_raster3d.top = Surface.deserialize(
            data['top']) if 'top' in data else None
        wurks_raster3d.name = data.get('name', "x")

        if 'lines' in data and data['lines'] is not None:
            wurks_raster3d.lines = [PolyCurve.deserialize(
                line_data) for line_data in data['lines']]
        else:
            wurks_raster3d.lines = None

        return wurks_raster3d

    def by_line(self, lines: Line, bottom: float, top: float):
        self.bottom = Vector(0, 0, bottom)
        self.top = Vector(0, 0, top)
        self.lines = lines

        surfList = []
        for line in self.lines:
            pts = []
            pts.append(Point.translate(line.start, self.bottom))
            pts.append(Point.translate(line.end, self.bottom))
            pts.append(Point.translate(line.end, self.top))
            pts.append(Point.translate(line.start, self.top))
            project.objects.append(Surface(PolyCurve.by_points(pts)))
            surfList.append(Surface(PolyCurve.by_points(pts)))

        print(f"{len(surfList)}* {self.__class__.__name__} {project.createdTxt}")


class WurksPedestal:
    def __init__(self):
        self.topfilename = "temp\\jonathan\\pedestal_top.dxf"
        self.basefilename = "temp\\jonathan\\pedestal_foot.dxf"
        self.diameter = 10
        self.topheight = 3
        self.baseheight = 3
        self.cache = {}
        self.top_dxf = None
        self.base_dxf = None

    def load_dxf(self, filename):
        if filename in self.cache:
            return self.cache[filename]
        else:
            dxf = ReadDXF(filename).polycurve
            self.cache[filename] = dxf
            return dxf

    def load_top_dxf(self):
        if self.top_dxf is None:
            self.top_dxf = self.load_dxf(self.topfilename)
        return self.top_dxf

    def load_base_dxf(self):
        if self.base_dxf is None:
            self.base_dxf = self.load_dxf(self.basefilename)
        return self.base_dxf

    def by_point(self, points, height, rotation=None):
        if isinstance(points, Point):
            points = [points]

        top = self.load_top_dxf()
        base = self.load_base_dxf()

        for point in points:
            topcenter = Point.difference(top.centroid(), point)
            translated_top = top.translate(Point.to_vector(topcenter))
            project.objects.append(Extrusion.by_polycurve_height(
                translated_top, self.topheight, 0))

            frame = Rect(
                Vector(x=(translated_top.centroid().x) - (self.diameter / 2),
                        y=(translated_top.centroid().y) - (self.diameter / 2),
                        z=point.z - self.topheight),
                self.diameter, self.diameter
            )
            project.objects.append(Extrusion.by_polycurve_height(
                frame, height - self.baseheight - self.topheight, 0))

            basecenter = Point.difference(base.centroid(), point)
            translated_base = base.translate(Point.to_vector(basecenter))
            project.objects.append(Extrusion.by_polycurve_height(
                translated_base, self.baseheight, -height))

        print(f"{len(points)}* {self.__class__.__name__} {project.createdTxt}")

    pass  # pootje, voet diameter(vierkant), verstelbare hoogte inregelen,


class WurksComputerFloor():  # centerpoint / rotation / panel pattern / ply
    pass  # some type of floor object


class WurksFloorFinish():
    pass  # direction / pattern / ect


class WorkPlane():
    def __init__(self):
        self.length = None
        self.width = None
        self.points = []

    def create(self, length: float = None, width: float = None) -> str:
        self.length = length or 1000
        self.width = width or 1000
        rect = Rect(Vector(0, 0, 0), self.length, self.width)
        for pt in rect.points:
            self.points.append(pt)
        project.objects.append(rect)
        print(f"1* {self.__class__.__name__} {project.createdTxt}")
        return Rect(Vector(0, 0, 0), self.length, self.width)

    pass  # pootje, voet diameter(vierkant), verstelbare hoogte inregelen,


WorkPlane = WorkPlane()
# rotation(Vector)/#volume/#scale



class TickMark:
    # Dimension Tick Mark
    def __init__(self):
        self.name = None
        
        self.curves = []

    @staticmethod
    def by_curves(name, curves):
        TM = TickMark()
        TM.name = name
        TM.curves = curves
        return TM


TMDiagonal = TickMark.by_curves(
    "diagonal", [Line(start=Point(-100, -100, 0), end=Point(100, 100, 0))])


class DimensionType:
    def __init__(self):
        self.name = None
        
        self.font = None
        self.text_height = 2.5
        self.tick_mark: TickMark = TMDiagonal
        self.line_extension = 100

    def serialize(self):
        return {
            'name': self.name,
            'id': self.id,
            'type': self.type,
            'font': self.font,
            'text_height': self.text_height,
            'tick_mark': str(self.tick_mark),
            'line_extension': self.line_extension
        }

    @staticmethod
    def deserialize(data):
        dimension_type = DimensionType()
        dimension_type.name = data.get('name')
        dimension_type.id = data.get('id')
        dimension_type.type = data.get('type')
        dimension_type.font = data.get('font')
        dimension_type.text_height = data.get('text_height', 2.5)

        # Handle TickMark deserialization
        tick_mark_str = data.get('tick_mark')
        # Adjust according to your TickMark implementation
        dimension_type.tick_mark = TickMark(tick_mark_str)

        dimension_type.line_extension = data.get('line_extension', 100)

        return dimension_type

    @staticmethod
    def by_name_font_textheight_tick_mark_extension(name: str, font: str, text_height: float, tick_mark: TickMark, line_extension: float):
        DT = DimensionType()
        DT.name = name
        DT.font = font
        DT.text_height = text_height
        DT.tick_mark = tick_mark
        DT.line_extension = line_extension
        return DT


DT2_5_mm = DimensionType.by_name_font_textheight_tick_mark_extension(
    "2.5 mm", "calibri", 2.5, TMDiagonal, 100)

DT1_8_mm = DimensionType.by_name_font_textheight_tick_mark_extension(
    "1.8 mm", "calibri", 2.5, TMDiagonal, 100)


class Dimension:
    def __init__(self, start: Point, end: Point, dimension_type) -> None:
        
        self.start: Point = start
        self.text_height = 100
        self.end: Point = end
        self.scale = 0.1  # text
        self.dimension_type: DimensionType = dimension_type
        self.curves = []
        self.length: float = Line(start=self.start, end=self.end).length
        self.text = None
        self.geom()

    def serialize(self):
        return {
            'type': self.type,
            'start': self.start.serialize(),
            'end': self.end.serialize(),
            'text_height': self.text_height,
            'id': self.id,
            'scale': self.scale,
            'dimension_type': self.dimension_type.serialize(),
            'curves': [curve.serialize() for curve in self.curves],
            'length': self.length,
            'text': self.text
        }

    @staticmethod
    def deserialize(data):
        start = Point.deserialize(data['start'])
        end = Point.deserialize(data['end'])
        dimension_type = DimensionType.deserialize(data['dimension_type'])
        dimension = Dimension(start, end, dimension_type)

        dimension.text_height = data.get('text_height', 100)
        dimension.id = data.get('id')
        dimension.scale = data.get('scale', 0.1)
        dimension.curves = [Line.deserialize(
            curve_data) for curve_data in data.get('curves', [])]
        dimension.length = data.get('length')
        dimension.text = data.get('text')

        return dimension

    @staticmethod
    def by_startpoint_endpoint_offset(start: Point, end: Point, dimension_type: DimensionType, offset: float):
        DS = Dimension()
        DS.start = start
        DS.end = end
        DS.dimension_type = dimension_type
        DS.geom()
        return DS

    def geom(self):
        # baseline
        baseline = Line(start=self.start, end=self.end)
        midpoint_text = baseline.mid_point()
        direction = Vector.normalize(baseline.vector)
        tick_mark_extension_point_1 = Point.translate(self.start, Vector.reverse(
            Vector.scale(direction, self.dimension_type.line_extension)))
        tick_mark_extension_point_2 = Point.translate(
            self.end, Vector.scale(direction, self.dimension_type.line_extension))
        x = direction
        y = Vector.rotate_XY(x, math.radians(90))
        z = Z_Axis
        cs_new_start = CoordinateSystem(self.start, x, y, z)
        cs_new_mid = CoordinateSystem(midpoint_text, x, y, z)
        cs_new_end = CoordinateSystem(self.end, x, y, z)
        self.curves.append(Line(tick_mark_extension_point_1,
                           self.start))  # extention_start
        self.curves.append(
            Line(tick_mark_extension_point_2, self.end))  # extention_end
        self.curves.append(Line(self.start, self.end))  # baseline
        # erg vieze oplossing. #Todo
        crvs = Line(
            start=self.dimension_type.tick_mark.curves[0].start, end=self.dimension_type.tick_mark.curves[0].end)

        self.curves.append(Line.transform(
            self.dimension_type.tick_mark.curves[0], cs_new_start))  # dimension tick start
        self.curves.append(Line.transform(crvs, cs_new_end)
                           )  # dimension tick end
        self.text = Text(text=str(round(self.length)), font_family=self.dimension_type.font,
                         cs=cs_new_mid, height=self.text_height).write()

    def write(self, project):
        for i in self.curves:
            project.objects.append(i)
        for j in self.text:
            project.objects.append(j)


class FrameTag:
    def __init__(self):
        # Dimensions in 1/100 scale
        
        self.scale = 0.1
        self.cs: CoordinateSystem = CSGlobal
        self.offset_x = 500
        self.offset_y = 100
        self.font_family = "calibri"
        self.text: str = "text"
        self.text_curves = None
        self.text_height = 100

    def serialize(self):
        id_value = str(self.id) if not isinstance(
            self.id, (str, int, float)) else self.id
        return {
            'id': id_value,
            'type': self.type,
            'scale': self.scale,
            'cs': self.cs.serialize(),
            'offset_x': self.offset_x,
            'offset_y': self.offset_y,
            'font_family': self.font_family,
            'text': self.text,
            'text_curves': self.text_curves,
            'text_height': self.text_height
        }

    @staticmethod
    def deserialize(data):
        frame_tag = FrameTag()
        frame_tag.scale = data.get('scale', 0.1)
        frame_tag.cs = CoordinateSystem.deserialize(data['cs'])
        frame_tag.offset_x = data.get('offset_x', 500)
        frame_tag.offset_y = data.get('offset_y', 100)
        frame_tag.font_family = data.get('font_family', "calibri")
        frame_tag.text = data.get('text', "text")
        frame_tag.text_curves = data.get('text_curves')
        frame_tag.text_height = data.get('text_height', 100)

        return frame_tag

    def __textobject(self):
        cstext = self.cs
        # cstextnew = cstext.translate(self.textoff_vector_local)
        self.text_curves = Text(
            text=self.text, font_family=self.font_family, height=self.text_height, cs=cstext).write

    def by_cs_text(self, coordinate_system: CoordinateSystem, text):
        self.cs = coordinate_system
        self.text = text
        self.__textobject()
        return self

    def write(self, project):
        for x in self.text_curves():
            project.objects.append(x)
        return self

    @staticmethod
    def by_frame(frame):
        tag = FrameTag()
        frame_vector = frame.vector_normalised
        x = frame_vector
        y = Vector.rotate_XY(x, math.radians(90))
        z = Z_Axis
        vx = Vector.scale(frame_vector, tag.offset_x)
        frame_width = PolyCurve2D.bounds(frame.curve)[4]
        vy = Vector.scale(y, frame_width*0.5+tag.offset_y)
        origintext = Point.translate(frame.start, vx)
        origintext = Point.translate(origintext, vy)
        csnew = CoordinateSystem(origintext, x, y, z)
        tag.cs = csnew
        tag.text = frame.name
        tag.__textobject()
        return tag


class ColumnTag:
    def __init__(self):
        # Dimensions in 1/100 scale
        
        self.width = 700
        self.height = 500
        self.factor = 3  # hellingsfacor leader
        self.scale = 0.1  # voor tekeningverschaling
        self.position = "TL"  # TL, TR, BL, BR Top Left Top Right Bottom Left Bottom Right
        self.cs: CoordinateSystem = CSGlobal

        # self.textoff_vector_local: Vector = Vector(1,1,1)
        self.font_family = "calibri"
        self.curves = []
        # self.leadercurves()
        self.text: str = "text"
        self.text_height = 100
        self.text_offset_factor = 5
        self.textoff_vector_local: Vector = Vector(
            self.height/self.factor, self.height+self.height/self.text_offset_factor, 0)
        self.text_curves = None
        # self.textobject()

    def serialize(self):
        id_value = str(self.id) if not isinstance(
            self.id, (str, int, float)) else self.id
        return {
            'id': id_value,
            'type': self.type,
            'width': self.width,
            'height': self.height,
            'factor': self.factor,
            'scale': self.scale,
            'position': self.position,
            'cs': self.cs.serialize(),
            'font_family': self.font_family,
            'curves': [curve.serialize() for curve in self.curves],
            'text': self.text,
            'text_height': self.text_height,
            'text_offset_factor': self.text_offset_factor,
            'textoff_vector_local': self.textoff_vector_local.serialize(),
            'text_curves': self.text_curves
        }

    @staticmethod
    def deserialize(data):
        column_tag = ColumnTag()
        column_tag.width = data.get('width', 700)
        column_tag.height = data.get('height', 500)
        column_tag.factor = data.get('factor', 3)
        column_tag.scale = data.get('scale', 0.1)
        column_tag.position = data.get('position', "TL")
        column_tag.cs = CoordinateSystem.deserialize(data['cs'])
        column_tag.font_family = data.get('font_family', "calibri")
        column_tag.curves = [Line.deserialize(
            curve_data) for curve_data in data.get('curves', [])]
        column_tag.text = data.get('text', "text")
        column_tag.text_height = data.get('text_height', 100)
        column_tag.text_offset_factor = data.get('text_offset_factor', 5)
        column_tag.textoff_vector_local = Vector.deserialize(
            data['textoff_vector_local'])
        column_tag.text_curves = data.get('text_curves')

        return column_tag

    def __leadercurves(self):
        self.startpoint = Point(0, 0, 0)
        self.midpoint = Point.translate(self.startpoint, Vector(
            self.height/self.factor, self.height, 0))
        self.endpoint = Point.translate(
            self.midpoint, Vector(self.width, 0, 0))
        crves = [Line(start=self.startpoint, end=self.midpoint),
                 Line(start=self.midpoint, end=self.endpoint)]
        for i in crves:
            j = Line.transform(i, self.cs)
            self.curves.append(j)

    def __textobject(self):
        cstext = self.cs

        cstextnew = CoordinateSystem.translate(
            cstext, self.textoff_vector_local)
        self.text_curves = Text(text=self.text, font_family=self.font_family,
                                height=self.text_height, cs=cstextnew).write

    def by_cs_text(self, coordinate_system: CoordinateSystem, text):
        self.cs = coordinate_system
        self.text = text
        self.__leadercurves()
        self.__textobject()
        return self

    def write(self, project):
        for x in self.text_curves():
            project.objects.append(x)
        for y in self.curves:
            project.objects.append(y)

    @staticmethod
    def by_frame(frame, position="TL"):
        tag = ColumnTag()
        csold = CSGlobal
        tag.position = position
        tag.cs = CoordinateSystem.translate(csold, Vector(
            frame.start.x, frame.start.y, frame.start.z))
        tag.text = frame.name
        tag.__leadercurves()
        tag.__textobject()
        return tag

# class Label:
# class LabelType:
# class TextType:

seqChar = "A B C D E F G H I J K L M N O P Q R S T U V W X Y Z AA AB AC"
seqNumber = "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24"


class GridheadType(Serializable):
    def __init__(self):
        
        self.name = None
        self.curves = []
        self.diameter = 150
        self.text_height = 200
        self.radius = self.diameter/2
        self.font_family = "calibri"

    def serialize(self):
        id_value = str(self.id) if not isinstance(
            self.id, (str, int, float)) else self.id
        return {
            'id': id_value,
            'type': self.type,
            'name': self.name,
            'curves': [curve.serialize() for curve in self.curves],
            'diameter': self.diameter,
            'text_height': self.text_height,
            'radius': self.radius,
            'font_family': self.font_family
        }

    @staticmethod
    def deserialize(data):
        gridhead_type = GridheadType()
        gridhead_type.id = data.get('id')
        gridhead_type.type = data.get('type')
        gridhead_type.name = data.get('name')
        gridhead_type.curves = [Line.deserialize(curve_data) for curve_data in data.get(
            'curves', [])]  # Adjust for your Curve class
        gridhead_type.diameter = data.get('diameter', 150)
        gridhead_type.text_height = data.get('text_height', 200)
        gridhead_type.radius = data.get('radius', gridhead_type.diameter / 2)
        gridhead_type.font_family = data.get('font_family', "calibri")

        return gridhead_type

    def by_diam(self, name, diameter: float, font_family, text_height):
        self.name = name
        self.diameter = diameter
        self.radius = self.diameter / 2
        self.font_family = font_family
        self.text_height = text_height
        self.geom()
        return self

    def geom(self):
        radius = self.radius
        self.curves.append(Arc(startPoint=Point(-radius, radius, 0),
                           midPoint=Point(0, radius*2, 0), endPoint=Point(radius, radius, 0)))
        self.curves.append(Arc(startPoint=Point(-radius, radius, 0),
                           midPoint=Point(0, 0, 0), endPoint=Point(radius, radius, 0)))
        # origin is at center of circle


GHT30 = GridheadType().by_diam("2.5 mm", 400, "calibri", 200)

GHT50 = GridheadType().by_diam("GHT50", 600, "calibri", 350)


class GridHead:
    def __init__(self):
        
        self.grid_name: str = "A"
        self.grid_head_type = GHT50
        self.radius = GHT50.radius
        self.CS: CoordinateSystem = CSGlobal
        self.x: float = 0.5
        self.y: float = 0
        self.text_curves = []
        self.curves = []
        self.__textobject()
        self.__geom()

    def serialize(self):
        id_value = str(self.id) if not isinstance(
            self.id, (str, int, float)) else self.id
        return {
            'id': id_value,
            'type': self.type,
            'grid_name': self.grid_name,
            'grid_head_type': self.grid_head_type.serialize(),
            'radius': self.radius,
            'CS': self.CS.serialize(),
            'x': self.x,
            'y': self.y,
            'text_curves': [curve.serialize() for curve in self.text_curves],
            'curves': [curve.serialize() for curve in self.curves]
        }

    @staticmethod
    def deserialize(data):
        grid_head = GridHead()
        grid_head.id = data.get('id')
        grid_head.type = data.get('type')
        grid_head.grid_name = data.get('grid_name')
        grid_head.grid_head_type = GridheadType.deserialize(
            data['grid_head_type'])
        grid_head.radius = data.get('radius', GHT50.radius)
        grid_head.CS = CoordinateSystem.deserialize(data['CS'])
        grid_head.x = data.get('x', 0.5)
        grid_head.y = data.get('y', 0)
        grid_head.text_curves = [Line.deserialize(
            curve_data) for curve_data in data.get('text_curves', [])]
        grid_head.curves = [Line.deserialize(
            curve_data) for curve_data in data.get('curves', [])]

        return grid_head

    def __geom(self):
        # CStot = CoordinateSystem.translate(self.CS,Vector(0,self.grid_head_type.radius,0))
        for i in self.grid_head_type.curves:
            self.curves.append(transform_arc(i, (self.CS)))

    def __textobject(self):
        cs_text = self.CS
        # to change after center text function is implemented
        cs_text_new = CoordinateSystem.move_local(cs_text, -100, 40, 0)
        self.text_curves = Text(text=self.grid_name, font_family=self.grid_head_type.font_family,
                                height=self.grid_head_type.text_height, cs=cs_text_new).write()
        project.objects.append(Text(text=self.grid_name, font_family=self.grid_head_type.font_family,
                                height=self.grid_head_type.text_height, cs=cs_text_new))

    @staticmethod
    def by_name_gridheadtype_y(name, cs: CoordinateSystem, gridhead_type, y: float):
        GH = GridHead()
        GH.grid_name = name
        GH.grid_head_type = gridhead_type
        GH.CS = cs
        GH.x = 0.5
        GH.y = y
        GH.__textobject()
        GH.__geom()
        return GH

    def write(self, project):
        for x in self.text_curves:
            project.objects.append(x)
        for y in self.curves:
            project.objects.append(y)


class Grid:
    def __init__(self):
        self.line = None
        self.start = None
        self.end = None
        self.direction: Vector = Vector(0, 1, 0)
        self.grid_head_type = GHT50
        self.name = None
        self.bulbStart = False
        self.bulbEnd = True
        self.cs_end: CoordinateSystem = CSGlobal
        self.grid_heads = []

    def __cs(self, line):
        self.direction = line.vector_normalised
        vect3 = Vector.rotate_XY(self.direction, math.radians(-90))
        self.cs_end = CoordinateSystem(line.end, vect3, self.direction, Z_Axis)

    @classmethod
    def by_startpoint_endpoint(cls, line, name):
        # Create panel by polycurve
        g1 = Grid()
        g1.start = line.start
        g1.end = line.start
        g1.name = name
        g1.__cs(line)
        g1.line = line_to_pattern(line, Centerline)
        # g1.__grid_heads()
        return g1

    def __grid_heads(self):
        if self.bulbEnd == True:
            self.grid_heads.append(
                GridHead.by_name_gridheadtype_y(self.name, self.cs_end, self.grid_head_type, 0))

    def write(self, project):
        for x in self.line:
            project.objects.append(x)
        for y in self.grid_heads:
            y.write(project)
        return self


def get_grid_distances(Grids):
    # Function to create grids from the format 0, 4x5400, 4000, 4000 to absolute XYZ-values
    GridsNew = []
    GridsNew.append(0)
    distance = 0.0
    # GridsNew.append(distance)
    for i in Grids:
        # del Grids[0]
        if "x" in i:
            spl = i.split("x")
            count = int(spl[0])
            width = float(spl[1])
            for i in range(count):
                distance = distance + width
                GridsNew.append(distance)
        else:
            distance = distance + float(i)
            GridsNew.append(distance)
    return GridsNew


class GridSystem:
    # rectangle Gridsystem
    def __init__(self):
        
        self.gridsX = None
        self.gridsY = None
        self.dimensions = []
        self.name = None

    def serialize(self):
        id_value = str(self.id) if not isinstance(
            self.id, (str, int, float)) else self.id
        return {
            'id': id_value,
            'type': self.type,
            'gridsX': self.gridsX,
            'gridsY': self.gridsY,
            'dimensions': [dimension.serialize() for dimension in self.dimensions],
            'name': self.name
        }

    @staticmethod
    def deserialize(data):
        grid_system = GridSystem()
        grid_system.id = data.get('id')
        grid_system.type = data.get('type')
        grid_system.gridsX = data.get('gridsX')
        grid_system.gridsY = data.get('gridsY')
        grid_system.dimensions = [Dimension.deserialize(dim_data) for dim_data in data.get(
            'dimensions', [])]  # Adjust for your Dimension class
        grid_system.name = data.get('name')

        return grid_system

    @classmethod
    def by_spacing_labels(cls, spacingX, labelsX, spacingY, labelsY, gridExtension):
        gs = GridSystem()
        # Create gridsystem
        # spacingXformat = "0 3000 3000 3000"
        GridEx = gridExtension

        GridsX = spacingX.split()
        GridsX = get_grid_distances(GridsX)
        Xmax = max(GridsX)
        GridsXLable = labelsX.split()
        GridsY = spacingY.split()
        GridsY = get_grid_distances(GridsY)
        Ymax = max(GridsY)
        GridsYLable = labelsY.split()

        gridsX = []
        dimensions = []
        count = 0
        ymaxdim1 = Ymax+GridEx-300
        ymaxdim2 = Ymax+GridEx-0
        xmaxdim1 = Xmax+GridEx-300
        xmaxdim2 = Xmax+GridEx-0
        for i in GridsX:
            gridsX.append(Grid.by_startpoint_endpoint(
                Line(Point(i, -GridEx, 0), Point(i, Ymax+GridEx, 0)), GridsXLable[count]))
            try:
                dim = Dimension(Point(i, ymaxdim1, 0), Point(
                    GridsX[count+1], ymaxdim1, 0), DT2_5_mm)
                gs.dimensions.append(dim)
            except:
                pass
            count = count + 1

        # Totaal maatvoering 1
        dim = Dimension(Point(GridsX[0], ymaxdim2, 0), Point(
            Xmax, ymaxdim2, 0), DT2_5_mm)
        gs.dimensions.append(dim)

        # Totaal maatvoering 2
        dim = Dimension(Point(xmaxdim2, GridsY[0], 0), Point(
            xmaxdim2, Ymax, 0), DT2_5_mm)
        gs.dimensions.append(dim)

        gridsY = []
        count = 0
        for i in GridsY:
            gridsY.append(Grid.by_startpoint_endpoint(
                Line(Point(-GridEx, i, 0), Point(Xmax+GridEx, i, 0)), GridsYLable[count]))
            try:
                dim = Dimension(Point(xmaxdim1, i, 0), Point(
                    xmaxdim1, GridsY[count+1], 0))  # ,DT3_5_mm)
                gs.dimensions.append(dim)
            except:
                pass
            count = count + 1
        gs.gridsX = gridsX
        gs.gridsY = gridsY
        return gs

    def write(self, project):
        for x in self.gridsX:
            project.objects.append(x)
            for i in x.grid_heads:
                i.write(project)
        for y in self.gridsY:
            project.objects.append(y)
            for j in y.grid_heads:
                j.write(project)
        for z in self.dimensions:
            z.write(project)
        return self


class Door:
    def __init__(self):
        
        self.name = None
        self.verts = None
        self.faces = None
        self.topsurface = None
        self.bottomsurface = None
        # self.polycurve = None or self.profile
        self.parms = None
        self.colorlst = None

    @classmethod
    def by_mesh(self, verts=list, faces=list):
        door = Door()
        door.verts = verts
        door.faces = faces
        return door

    def __str__(self) -> str:
        return f"{self.type}(Name={self.name})"



class Floor:
    def __init__(self):
        
        self.extrusion = None
        self.thickness = 0
        self.name = None
        self.description = None
        self.perimeter: float = 0
        self.colorint = None
        self.colorlst = []
        self.origincurve = None
        self.points = None
        self.thickness = None

class Room:
    def __init__(self):
        
        self.name = None
        self.extrusion = None
        self.verts = None
        self.faces = None
        self.topsurface = None
        self.bottomsurface = None
        self.parms = None
        self.colorlst = None



class Support:
    def __init__(self):
        self.Number = None
        self.Point: Point = Point(0, 0, 0)
        
        self.Tx: str = " "  # A, P, N, S
        self.Ty: str = " "  # A, P, N, S
        self.Tz: str = " "  # A, P, N, S
        self.Rx: str = " "  # A, P, N, S
        self.Ry: str = " "  # A, P, N, S
        self.Rz: str = " "  # A, P, N, S
        self.Kx: float = 0  # kN/m
        self.Ky: float = 0  # kN/m
        self.Kz: float = 0  # kN/m
        self.Cx: float = 0  # kNm/rad
        self.Cy: float = 0  # kNm/rad
        self.Cz: float = 0  # kNm/rad
        self.dx: float = 0  # eccentricity in x
        self.dy: float = 0  # eccentricity in y
        self.dz: float = 0  # eccentricity in z

    def serialize(self):
        return {
            'Number': self.Number,
            'Point': self.Point.serialize(),
            'type': self.type,
            'Tx': self.Tx,
            'Ty': self.Ty,
            'Tz': self.Tz,
            'Rx': self.Rx,
            'Ry': self.Ry,
            'Rz': self.Rz,
            'Kx': self.Kx,
            'Ky': self.Ky,
            'Kz': self.Kz,
            'Cx': self.Cx,
            'Cy': self.Cy,
            'Cz': self.Cz,
            'dx': self.dx,
            'dy': self.dy,
            'dz': self.dz
        }

    @staticmethod
    def deserialize(data):
        support = Support()
        support.Number = data.get('Number')
        support.Point = Point.deserialize(data['Point'])
        support.Tx = data.get('Tx', " ")
        support.Ty = data.get('Ty', " ")
        support.Tz = data.get('Tz', " ")
        support.Rx = data.get('Rx', " ")
        support.Ry = data.get('Ry', " ")
        support.Rz = data.get('Rz', " ")
        support.Kx = data.get('Kx', 0)
        support.Ky = data.get('Ky', 0)
        support.Kz = data.get('Kz', 0)
        support.Cx = data.get('Cx', 0)
        support.Cy = data.get('Cy', 0)
        support.Cz = data.get('Cz', 0)
        support.dx = data.get('dx', 0)
        support.dy = data.get('dy', 0)
        support.dz = data.get('dz', 0)

        return support

    @staticmethod
    def pinned(PlacementPoint):
        sup = Support()
        sup.Point = PlacementPoint
        sup.Tx = "A"
        sup.Ty = "A"
        sup.Tz = "A"
        return (sup)

    @staticmethod
    def x_roller(PlacementPoint):
        sup = Support()
        sup.Point = PlacementPoint
        sup.Ty = "A"
        sup.Tz = "A"
        return (sup)

    @staticmethod
    def y_roller(PlacementPoint):
        sup = Support()
        sup.Point = PlacementPoint
        sup.Tx = "A"
        sup.Tz = "A"
        return (sup)

    @staticmethod
    def z_roller(PlacementPoint):
        sup = Support()
        sup.Point = PlacementPoint
        sup.Tx = "A"
        sup.Ty = "A"
        return (sup)

    @staticmethod
    def fixed(PlacementPoint):
        sup = Support()
        sup.Point = PlacementPoint
        sup.Tx = "A"
        sup.Ty = "A"
        sup.Tz = "A"
        sup.Rx = "A"
        sup.Ry = "A"
        sup.Rz = "A"
        return (sup)


class LoadCase:
    def __init__(self):
        self.Number = None
        self.Description: str = ""
        self.psi0 = 1
        self.psi1 = 1
        self.psi2 = 1
        self.Type = 0  # 0 = permanent, 1 = variabel


class SurfaceLoad:
    def __init__(self):
        self.LoadCase = None
        self.PolyCurve: PolyCurve = None
        self.Description: str = ""
        self.crs = "ccaa0435161960d4c7e436cf107a03f61"
        self.direction = "caf2b4ce743de1df30071f9566b1015c6"
        self.LoadBearingDirection = "cfebf3fce7063ab9a89d28a86508c0fb3"
        self.q1 = 0
        self.q2 = 0
        self.q3 = 0
        self.LoadConstantOrLinear = "cb81ae405e988f21166edf06d7fd646fb"
        self.iq1 = -1
        self.iq2 = -1
        self.iq3 = -1

    @staticmethod
    def by_load_case_polycurve_q(LoadCase, PolyCurve, q):
        SL = SurfaceLoad()
        SL.LoadCase = LoadCase
        SL.PolyCurve = PolyCurve
        SL.q1 = q
        SL.q2 = q
        SL.q3 = q
        return SL


class LoadPanel:
    def __init__(self):
        self.PolyCurve: PolyCurve = None
        self.Description: str = ""
        self.LoadBearingDirection = "X"
        # Wall, saddle_roof_positive_pitch #Wall, / Free-standing wall, Flat roof, Shed roof, Saddle roof, Unknown
        self.SurfaceType = ""


def chess_board_surface_loads_rectangle(startx, starty, dx, dy, nx, ny, width, height, LoadCase, q123, description: str):
    SurfaceLoads = []
    x = startx
    y = starty
    for j in range(ny):
        for i in range(nx):
            SL = SurfaceLoad()
            SL.Description = description
            SL.LoadCase = LoadCase
            SL.PolyCurve = PolyCurve.by_points(
                [Point(x, y, 0),
                 Point(x + width, y, 0),
                 Point(x, y + height, 0),
                 Point(x, y, 0)]
            )
            SL.q1 = SL.q2 = SL.q3 = q123  # [kN/m2]
            SurfaceLoads.append(SL)
            x = x + dx
        y = y + dy
    return SurfaceLoads


class Level:
    def __init__(self):
        
        self.name = None
        self.polycurve = None
        self.plane = None
        self.parms = None
        self.elevation = None

    @classmethod
    def by_point(self, point=Point, name=str):
        if point.type == "Point":
            Lvl = Level()
            XY_plane = [Vector(x=1, y=0, z=0), Vector(x=0, y=1, z=0)]
            Lvl.plane = Plane.by_two_vectors_origin(
                XY_plane[0], XY_plane[1], point)
            Lvl.polycurve = Rect_XY(Point.to_vector(point), 1000, 1000)
            Lvl.elevation = point.z
            if name != None:
                Lvl.name = name
            return Lvl
        elif point.type == "Point2D":
            pass  # 0

    def __str__(self) -> str:
        return f"{self.type}(Name={self.name}, Elevation={self.elevation})"


class Wall:
    def __init__(self):
        
        self.name = None
        self.verts = None
        self.faces = None
        # self.polycurve = None or self.profile
        self.parms = None
        self.coordinatesystem: CoordinateSystem = CSGlobal
        self.colorlst = None

    @classmethod
    def by_mesh(self, verts=list, faces=list):
        wall = Wall()
        wall.verts = [vertex * project.scale for vertex in verts]
        wall.faces = list(faces)
        return wall

    def __str__(self) -> str:
        return f"{self.type}(Name={self.name})"


