#[BuildingPy] DO NOT EDIT THIS FILE. IT IS GENERATED FROM THE SOURCE CODE
import math
import sys
import json
import urllib
import urllib.request
import string
import random
import numpy as np
# from packages.svg.path import parse_path
from typing import List, Tuple
import xml.etree.ElementTree as ET
from pathlib import Path
# import ezdxf





def find_in_list_of_list(mylist, char):
    for sub_list in mylist:
        if char in sub_list:
            return (mylist.index(sub_list))
    raise ValueError("'{char}' is not in list".format(char=char))

class generateID:
    def __init__(self) -> None:
        self.id = None
        self.object = None
        self.name = None
        self.generateID()

    def generateID(self) -> None:
        id = ""
        lengthID = 12
        random_source = string.ascii_uppercase + string.digits
        for x in range(lengthID):
            id += random.choice(random_source)

        id_list = list(id)
        self.id = f"#"+"".join(id_list)
        return f"test {self.__class__.__name__}"

    def __repr__(self) -> str:
        return f"{self.id}"


def findjson(id, json_string):
    #faster way to search in json
    results = []

    def _decode_dict(a_dict):
        try:
            results.append(a_dict[id])
        except KeyError:
            pass
        return a_dict

    json.loads(json_string, object_hook=_decode_dict) # Return value ignored.
    return results

def list_transpose(lst):
    #list of lists, transpose columns/rows
    newlist = list(map(list, zip(*lst)))
    return newlist

def is_null(lst):
    return all(el is None for el in lst)

def clean_list(input_list, preserve_indices=True):
    if not input_list:
        return input_list
    
    culled_list = []

    if preserve_indices:
        if is_null(input_list):
            return None
        
        j = len(input_list) - 1
        while j >= 0 and input_list[j] is None:
            j -= 1

        for i in range(j + 1):
            sublist = input_list[i]

            if isinstance(sublist, list):
                val = clean_list(sublist, preserve_indices)
                culled_list.append(val)
            else:
                culled_list.append(input_list[i])
    else:
        if is_null(input_list):
            return []
        
        for el in input_list:
            if isinstance(el, list):
                if not is_null(el):
                    val = clean_list(el, preserve_indices=False)
                    if val:
                        culled_list.append(val)
            elif el is not None:
                culled_list.append(el)
            
    return culled_list

def flatten(lst):
    flat_list = []
    for sublist in lst:
        try:
            for item in sublist:
                flat_list.append(item)
        except:
            flat_list.append(sublist)
    return flat_list

def all_true(lst):
    for element in lst:
        if not element:
            return False
    return True

def replace_at_index(object, index, new_object):
    if index < 0 or index >= len(object):
        raise IndexError("Index out of range")
    return object[:index] + new_object + object[index+1:]

def xmldata(myurl, xPathStrings):
    urlFile = urllib.request.urlopen(myurl)
    tree = ET.parse(urlFile)
    xPathResults = []
    for xPathString in xPathStrings:
        a = tree.findall(xPathString)
        xPathResulttemp2 = []
        for xPathResult in a:
            xPathResulttemp2.append(xPathResult.text)
        xPathResults.append(xPathResulttemp2)
    return xPathResults


class Vector3:
    def __init__(self, x, y, z):
        self.x: float = 0.0
        self.y: float = 0.0
        self.z: float = 0.0

        self.x = x
        self.y = y
        self.z = z

    @staticmethod
    def sum(v1, v2):
        return Vector3(
            v1.x + v2.x,
            v1.y + v2.y,
            v1.z + v2.z
        )

    @staticmethod
    def sum3(v1, v2, v3):
        return Vector3(
            v1.x + v2.x + v3.x,
            v1.y + v2.y + v3.y,
            v1.z + v2.z + v3.z
        )

    @staticmethod
    def diff(v1, v2):
        return Vector3(
            v1.x - v2.x,
            v1.y - v2.y,
            v1.z - v2.z
        )

    @staticmethod
    def divide(v1, v2):
        return Vector3(
            v1.x / v2.x,
            v1.y / v2.y,
            v1.z / v2.z
        )

    @staticmethod
    def square(v1):
        return Vector3(
            v1.x **2,
            v1.y **2,
            v1.z **2
        )

    @staticmethod
    def toPoint(v1):
        return Point(x=v1.x,y=v1.y,z=v1.z)


    @staticmethod
    def toLine(v1, v2):
        return Line(start = Point(x=v1.x,y=v1.y,z=v1.z), end = Point(x=v2.x,y=v2.y,z=v2.z))

    @staticmethod
    def byLine(l1):
        return Vector3(l1.dx,l1.dy,l1.dz)

    @staticmethod
    def lineByLength(v1, length:float):
        return None
        # return Line(start = Point(x=v1.x,y=v1.y,z=v1.z), end = Point(x=v2.x,y=v2.y,z=v2.z))
    

    @staticmethod #Returns vector perpendicular on the two vectors
    def crossProduct(v1, v2):
        return Vector3(
            v1.y*v2.z - v1.z*v2.y,
            v1.z*v2.x - v1.x*v2.z,
            v1.x*v2.y - v1.y*v2.x
        )

    @staticmethod #inwendig product, if zero, then vectors are perpendicular
    def dotProduct(v1, v2):
        return v1.x*v2.x+v1.y*v2.y+v1.z*v2.z

    @staticmethod
    def product(n, v1): #Same as scale
        return Vector3(
            v1.x*n,
            v1.y*n,
            v1.z*n
        )

    @staticmethod
    def length(v1):
        return math.sqrt(v1.x*v1.x+v1.y*v1.y+v1.z*v1.z)
    
    # @staticmethod
    # def length(v1):
    #     return (v1.x ** 2 + v1.y ** 2 + v1.z ** 2) ** 0.5
    
    @staticmethod
    def pitch(v1, angle):
        return Vector3(
            v1.x,
            v1.y*math.cos(angle) - v1.z*math.sin(angle),
            v1.y*math.sin(angle) + v1.z*math.cos(angle)
        )

    @staticmethod
    def angleBetween(v1, v2):
        return math.degrees(math.acos((Vector3.dotProduct(v1, v2)/(Vector3.length(v1)*Vector3.length(v2)))))
    
    @staticmethod
    def angleRadianBetween(v1, v2):
        return math.acos((Vector3.dotProduct(v1, v2)/(Vector3.length(v1)*Vector3.length(v2))))

    @staticmethod
    def value(v1):
        roundValue = 4
        return (round(v1.x, roundValue),round(v1.y, roundValue),round(v1.z, roundValue))

    @staticmethod
    def reverse(v1):
        return Vector3(
            v1.x*-1,
            v1.y*-1,
            v1.z*-1
        )

    @staticmethod
    def perpendicular(v1):
        #Vector Lokale x en Lokale y haaks op gegeven vector en in globale z-richting.
        lokX = Vector3(v1.y, -v1.x, 0)
        lokZ = Vector3.crossProduct(v1, lokX)
        if lokZ.z<0:
            lokZ = Vector3.reverse(lokZ)
        return lokX, lokZ

    @staticmethod
    def normalize(v1):
        length = Vector3.length(v1)
        if length == 0:
            scale = 1
        else:
            scale = 1 / length
        return Vector3(v1.x * scale, v1.y * scale, v1.z * scale)

    @staticmethod
    def byTwoPoints(p1, p2):
        return Vector3(
            p2.x-p1.x,
            p2.y-p1.y,
            p2.z-p1.z
        )

    @staticmethod
    def rotateXY(v1, Beta):
        return Vector3(
            math.cos(Beta)*v1.x - math.sin(Beta)*v1.y,
            math.sin(Beta)*v1.x + math.cos(Beta)*v1.y,
            v1.z
        )

    @staticmethod
    def scale(v1, scalefactor):
        return Vector3(
            v1.x * scalefactor,
            v1.y * scalefactor,
            v1.z * scalefactor
        )

    @staticmethod
    def new_length(v1, newlength: float):
        scale = newlength /Vector3.length(v1)
    
        return Vector3.scale(v1,scale)

    def __str__(self):
        return f"{__class__.__name__}(" + f"{self.x},{self.y},{self.z})"


XAxis = Vector3(1, 0, 0)

YAxis = Vector3(0, 1, 0)

ZAxis = Vector3(0, 0, 1)


# from project.fileformat import project


class Point:
    def __init__(self, x, y, z):
        self.x: float = 0.0
        self.y: float = 0.0
        self.z: float = 0.0
        self.x = x
        self.y = y
        self.z = z
        self.value = self.x, self.y, self.z
        self.id = generateID()
        self.units = "mm"
        
    def __str__(self) -> str:
        return f"{__class__.__name__}({self.x},{self.y},{self.z})"

    @staticmethod
    def distance(point1, point2):
        return math.sqrt((point1.x - point2.x)**2 + (point1.y - point2.y)**2 + (point1.z - point2.z)**2)

    @staticmethod
    def calculate_distance(points:list) -> float:
        distances = []
        for i in range(len(points)):
            for j in range(i+1, len(points)):
                distances.append((points[i], points[j], Point.distance(points[i], points[j])))
        distances.sort(key=lambda x: x[2])
        return distances

    @staticmethod
    def difference(pointxyz1, pointxyz2):
        return Vector3(
            pointxyz2.x - pointxyz1.x,
            pointxyz2.y - pointxyz1.y,
            pointxyz2.z - pointxyz1.z
        )

    @staticmethod
    def translate(point, vector):
        return Point(
            point.x + vector.x,
            point.y + vector.y,
            point.z + vector.z
        )

    @staticmethod
    def origin(point1, point2):
        return Point(
            (point1.x + point2.x) /2,
            (point1.y + point2.y) /2,
            (point1.z + point2.z) /2
        )

    @staticmethod
    def point2DTo3D(point2D):
        return Point(
            point2D.x,
            point2D.y,
            0
        )

    @staticmethod
    def toVector(point1):
        return Vector3(
            point1.x,
            point1.y,
            point1.z
        )

    @staticmethod
    def sum(p1, p2):
        return Point(
            p1.x + p2.x,
            p1.y + p2.y,
            p1.z + p2.z
        )


    @staticmethod
    def diff(p1, p2):
        return Point(
            p1.x - p2.x,
            p1.y - p2.y,
            p1.z - p2.z
        )


    @staticmethod
    def rotateXY(p1, Beta, dz):
        return Point(
            math.cos(math.radians(Beta))*p1.x - math.sin(math.radians(Beta))*p1.y,
            math.sin(math.radians(Beta))*p1.x + math.cos(math.radians(Beta))*p1.y,
            p1.z + dz
        )

    @staticmethod
    def product(n, p1): #Same as scale
        return Point(
            p1.x*n,
            p1.y*n,
            p1.z*n
        )

    @staticmethod
    def intersect(p1, p2):
        #Intersection of two points
        if p1.x == p2.x and p1.y == p2.y and p1.z == p2.z:
            return 1
        else:
            return 0



class CoordinateSystem:
    #UNITY VECTORS REQUIRED
    def __init__(self, origin: Point, xaxis, yaxis, zaxis):
        self.Origin = origin
        self.Xaxis = xaxis
        self.Yaxis = yaxis
        self.Zaxis = zaxis

    @classmethod
    def by_origin(self, origin: Point):
        self.Origin = origin
        self.Xaxis = XAxis
        self.Yaxis = YAxis
        self.Zaxis = ZAxis
        return self

    @staticmethod
    def translate(CSOld, direction):
        new_origin = Point.translate(CSOld.Origin, direction)
        
        XAxis = Vector3(1, 0, 0)

        YAxis = Vector3(0, 1, 0)

        ZAxis = Vector3(0, 0, 1)

        CSNew = CoordinateSystem(new_origin,xaxis=XAxis,yaxis=YAxis,zaxis=ZAxis)

        CSNew.Origin = new_origin
        return CSNew

    def __str__(self):
        return f"{__class__.__name__}(" + f"{self.Origin}, {self.Xaxis}, {self.Yaxis}, {self.Zaxis})"

    @staticmethod
    def by_point_main_vector(self, NewOriginCoordinateSystem: Point, DirectionVectorZ):
        vz = DirectionVectorZ  # LineVector and new Z-axis
        vz = Vector3.normalize(vz)  # NewZAxis
        vx = Vector3.perpendicular(vz)[0]  # NewXAxis
        try:
            vx = Vector3.normalize(vx)  # NewXAxisnormalized
        except:
            vx = Vector3(1, 0, 0) #In case of vertical element the length is zero
        vy = Vector3.perpendicular(vz)[1]  # NewYAxis
        try:
            vy = Vector3.normalize(vy)  # NewYAxisnormalized
        except:
            vy = Vector3(0, 1, 0)  #In case of vertical element the length is zero
        CSNew = CoordinateSystem(NewOriginCoordinateSystem, vx, vy, vz)
        return CSNew

def transformPoint(PointLocal: Point, CoordinateSystemOld: CoordinateSystem, NewOriginCoordinateSystem: Point, DirectionVector):
    vz = DirectionVector  # LineVector and new Z-axis
    vz = Vector3.normalize(vz)  # NewZAxis
    vx = Vector3.perpendicular(vz)[0]  # NewXAxis
    try:
        vx = Vector3.normalize(vx)  # NewXAxisnormalized
    except:
        vx = Vector3(1, 0, 0) #In case of vertical element the length is zero
    vy = Vector3.perpendicular(vz)[1]  # NewYAxis
    try:
        vy = Vector3.normalize(vy)  # NewYAxisnormalized
    except:
        vy = Vector3(0, 1, 0)  #In case of vertical element the length is zero
    P1 = PointLocal #point to transform
    CSNew = CoordinateSystem(NewOriginCoordinateSystem, vx, vy, vz)
    v1 = Point.difference(CoordinateSystemOld.Origin, CSNew.Origin)
    v2 = Vector3.product(P1.x, CSNew.Xaxis)  # local transformation van X
    v3 = Vector3.product(P1.y, CSNew.Yaxis)  # local transformation van Y
    v4 = Vector3.product(P1.z, CSNew.Zaxis)  # local transformation van Z
    vtot = Vector3(v1.x + v2.x + v3.x + v4.x, v1.y + v2.y + v3.y + v4.y, v1.z + v2.z + v3.z + v4.z)
    pointNew = Point.translate(Point(0, 0, 0), vtot)  # Point 0,0,0 have to be checked
    return pointNew

def transformPoint2(PointLocal: Point, CoordinateSystemNew: CoordinateSystem):
    #Transfrom point from Global Coordinatesystem to a new Coordinatesystem
    #CSold = CSGlobal
    pn = Point.translate(CoordinateSystemNew.Origin, Vector3.scale(CoordinateSystemNew.Xaxis, PointLocal.x))
    pn2 = Point.translate(pn, Vector3.scale(CoordinateSystemNew.Yaxis, PointLocal.y))
    pn3 = Point.translate(pn2, Vector3.scale(CoordinateSystemNew.Zaxis, PointLocal.z))
    return pn3

class BuildingPy:
    def __init__(self, name=None, number=None):
        self.name: str = name
        self.number: str = number
        self.objects = []
        self.units = "mm"
        self.decimals = 3 #not fully implemented yet
        self.origin = Point(0,0,0)
        self.default_font = "calibri"
        self.scale = 1000
        self.font_height = 500
        #prefix objects (name)
        #Geometry settings

        #export selection info
        self.domain = None
        self.applicationId = "OPEN-AEC | BuildingPy"

        #different settings for company's?

        #rename this to autoclose?
        self.closed: bool = False #auto close polygons? By default true, else overwrite
        self.round: bool = False #If True then arcs will be segmented. Can be used in Speckle.

        #text
        self.createdTxt = "has been created"

        #Speckle settings
        self.speckleserver = "speckle.xyz"
        self.specklestream = None

        #FreeCAD settings

        XAxis = Vector3(1, 0, 0)
        YAxis = Vector3(0, 1, 0)
        ZAxis = Vector3(0, 0, 1)
        self.CSGlobal = CoordinateSystem(Point(0, 0, 0), XAxis, YAxis, ZAxis)

    # @property
    # def units(self):
    #     return "mm"



project = BuildingPy("Project","0")


class CoordinateSystem:
    #UNITY VECTORS REQUIRED #TOdo organize resic
    def __init__(self, origin: Point, xaxis, yaxis, zaxis):
        self.Origin = origin
        self.Xaxis = Vector3.normalize(xaxis)
        self.Yaxis = Vector3.normalize(yaxis)
        self.Zaxis = Vector3.normalize(zaxis)

    @classmethod
    def by_origin(self, origin: Point):
        self.Origin = origin
        self.Xaxis = XAxis
        self.Yaxis = YAxis
        self.Zaxis = ZAxis
        return self

    @staticmethod
    def translate(CSOld, direction):
        CSNew = CoordinateSystem(CSOld.Origin, CSOld.Xaxis, CSOld.Yaxis, CSOld.Zaxis)
        new_origin = Point.translate(CSNew.Origin, direction)
        CSNew.Origin = new_origin
        return CSNew

    @staticmethod
    def move_local(CSOld,x: float, y:float, z:float):
        #move coordinatesystem by y in local coordinates(not global)
        xloc_vect_norm = CSOld.Xaxis
        xdisp = Vector3.scale(xloc_vect_norm,x)
        yloc_vect_norm = CSOld.Xaxis
        ydisp = Vector3.scale(yloc_vect_norm, y)
        zloc_vect_norm = CSOld.Xaxis
        zdisp = Vector3.scale(zloc_vect_norm, z)
        disp = Vector3.sum3(xdisp,ydisp,zdisp)
        CS = CoordinateSystem.translate(CSOld,disp)
        return CS

    @staticmethod
    def by_point_main_vector(self, NewOriginCoordinateSystem: Point, DirectionVectorZ):
        vz = DirectionVectorZ  # LineVector and new Z-axis
        vz = Vector3.normalize(vz)  # NewZAxis
        vx = Vector3.perpendicular(vz)[0]  # NewXAxis
        try:
            vx = Vector3.normalize(vx)  # NewXAxisnormalized
        except:
            vx = Vector3(1, 0, 0) #In case of vertical element the length is zero
        vy = Vector3.perpendicular(vz)[1]  # NewYAxis
        try:
            vy = Vector3.normalize(vy)  # NewYAxisnormalized
        except:
            vy = Vector3(0, 1, 0)  #In case of vertical element the length is zero
        CSNew = CoordinateSystem(NewOriginCoordinateSystem, vx, vy, vz)
        return CSNew

    def __str__(self):
        return f"{__class__.__name__}(" + f"{self.Origin}, {self.Xaxis}, {self.Yaxis}, {self.Zaxis})"

CSGlobal = project.CSGlobal


class BoundingBox2d:
    def __init__(self):
        self.id = generateID()
        self.points = []
        self.corners = []
        self.isClosed = True
        self.width = 0
        self.height = 0
        self.z = 0

    def length(self):
        return 0
    
    def area(self):
        return 0

    def byPoints(self, points=Point):
        self.points = points
        x_values = [point.x for point in self.points]
        y_values = [point.y for point in self.points]

        min_x = min(x_values)
        max_x = max(x_values)
        min_y = min(y_values)
        max_y = max(y_values)
        
        left_top = Point(x=min_x, y=max_y, z=self.z)
        left_bottom = Point(x=min_x, y=min_y, z=self.z)
        right_top = Point(x=max_x, y=max_y, z=self.z)
        right_bottom = Point(x=max_x, y=min_y, z=self.z)
        self.width = abs(Point.distance(left_top, right_top))
        self.height = abs(Point.distance(left_top, left_bottom))
        self.corners.append(left_top) 
        self.corners.append(left_bottom) 
        self.corners.append(right_bottom)
        self.corners.append(right_top)
        # print(self.height)
        return self


class BoundingBox3d:
    def __init__(self, points=Point):
        self.points = points


    def corners(self, points=Point):
        x_values = [point.x for point in self.points]
        y_values = [point.y for point in self.points]
        z_values = [point.z for point in self.points]

        min_x = min(x_values)
        max_x = max(x_values)
        min_y = min(y_values)
        max_y = max(y_values)
        min_z = min(z_values)
        max_z = max(z_values)

        left_top_bottom = Point(x=min_x, y=max_y, z=min_z)
        left_bottom_bottom = Point(x=min_x, y=min_y, z=min_z)
        right_top_bottom = Point(x=max_x, y=max_y, z=min_z)
        right_bottom_bottom = Point(x=max_x, y=min_y, z=min_z)
        
        left_top_top = Point(x=min_x, y=max_y, z=max_z)
        left_bottom_top = Point(x=min_x, y=min_y, z=max_z)
        right_top_top = Point(x=max_x, y=max_y, z=max_z)
        right_bottom_top = Point(x=max_x, y=min_y, z=max_z)

        return [left_top_bottom, left_top_top, right_top_top, right_top_bottom, left_top_bottom, left_bottom_bottom, left_bottom_top, left_top_top, left_bottom_top, right_bottom_top, right_bottom_bottom, left_bottom_bottom, right_bottom_bottom, right_top_bottom, right_top_top, right_bottom_top]

    def perimeter(self):
        return PolyCurve.byPoints(self.corners(self.points))


class Line: #add Line.bylenght (start and endpoint)
    def __init__(self, start: Point, end: Point) -> None:
        self.type = __class__.__name__
        self.start: Point = start
        self.end: Point = end
        self.id = generateID()
        self.x = [self.start.x, self.end.x]
        self.y = [self.start.y, self.end.y]
        try:
            self.z = [self.start.z, self.end.z]
        except:
            self.z = 0
        self.dx = self.end.x-self.start.x
        self.dy = self.end.y-self.start.y
        try:
            self.dz = self.end.z-self.start.z
        except:
            self.dz = 0
        self.length = self.length()
        self.vector: Vector3 = Vector3.byTwoPoints(start,end)
        self.vector_normalised = Vector3.normalize(self.vector)

    def translate(self,direction:Vector3):
        self.start = Point.translate(self.start,direction)
        self.end = Point.translate(self.end,direction)
        return self

    @staticmethod
    def transform(line, CSNew: CoordinateSystem):
        ln = Line(start=line.start, end=line.end)
        ln.start = transformPoint2(ln.start,CSNew)
        ln.end = transformPoint2(ln.end,CSNew)
        return ln

    def offset(line, vector):
        start = Point(line.start.x + vector.x, line.start.y + vector.y, line.start.z + vector.z)
        end = Point(line.end.x + vector.x, line.end.y + vector.y, line.end.z + vector.z)
        return Line(start=start, end=end)

    # @classmethod
    def pointAtParameter(self, interval=None):
        if interval == None:
            interval = 0.0
        x1, y1, z1 = self.start.x, self.start.y, self.start.z
        x2, y2, z2 = self.end.x, self.end.y, self.end.z
        if float(interval) == 0.0:
            return self.start
        else:
            devBy = 1/interval
            return Point((x1 + x2) / devBy, (y1 + y2) / devBy, (z1 + z2) / devBy)

    def mid_point(self):
        vect = Vector3.scale(self.vector,0.5)
        mid = Point.translate(self.start,vect)
        return mid

    def split(self, points: Point):
        if isinstance(points, list):        
            points.extend([self.start, self.end])
            sorted_points = sorted(points, key=lambda p: p.distance(p,self.end))
            lines = create_lines(sorted_points)
            return lines
        elif isinstance(points, Point):
            point = points
            lines.append(Line(start=self.start, end=point))
            lines.append(Line(start=point, end=self.end))
            return lines


    def length(self):
        return math.sqrt(math.sqrt(self.dx * self.dx + self.dy * self.dy) * math.sqrt(self.dx * self.dx + self.dy * self.dy) + self.dz * self.dz)

    def __str__(self):
        return f"{__class__.__name__}(" + f"{self.start},{self.end})"


def create_lines(points):
    lines = []
    for i in range(len(points)-1):
        line = Line(points[i], points[i+1])
        lines.append(line)
    return lines


class PolyCurve:
    def __init__(self): #isclosed?
        self.curves = []
        self.points = []
        self.segmentcurves = None
        self.width = None
        self.height = None
        #Methods ()
        #close
        #pointonperimeter
        #Properties
        self.approximateLength = None
        self.graphicsStyleId = None
        self.id = generateID()
        self.isClosed = None
        self.isCyclic = None
        self.isElementGeometry = None
        self.isReadOnly = None
        # self.length = self.calcLength()
        self.period = None
        self.reference = None
        self.visibility = None

    def scale(self, scalefactor):
        crvs = []
        for i in self.curves:
            if i.__class__.__name__ == "Arc":
                arcie = Arc(Point.product(scalefactor, i.start), Point.product(scalefactor, i.end))
                arcie.mid = Point.product(scalefactor,i.mid)
                crvs.append(arcie)
            elif i.__class__.__name__ == "Line":
                crvs.append(Line(Point.product(scalefactor, i.start), Point.product(scalefactor, i.end)))
            else:
                print("Curvetype not found")
        crv = PolyCurve.byJoinedCurves(crvs)
        return crv

    def get_width(self) -> float:
        x_values = [point.x for point in self.points]
        y_values = [point.y for point in self.points]

        min_x = min(x_values)
        max_x = max(x_values)
        min_y = min(y_values)
        max_y = max(y_values)
        
        left_top = Point(x=min_x, y=max_y, z=self.z)
        left_bottom = Point(x=min_x, y=min_y, z=self.z)
        right_top = Point(x=max_x, y=max_y, z=self.z)
        right_bottom = Point(x=max_x, y=min_y, z=self.z)
        self.width = abs(Point.distance(left_top, right_top))
        self.height = abs(Point.distance(left_top, left_bottom))
        return self.width


    def centroid(self) -> Point:
        if self.isClosed:
            if len(self.points) < 3:
                return "Polygon has less than 3 points!"
            num_points = len(self.points)
            polygon = np.array([(self.points[i].x, self.points[i].y) for i in range(num_points)],dtype=np.float64)
            polygon2 = np.roll(polygon, -1, axis=0)
            signed_areas = 0.5 * np.cross(polygon, polygon2)
            centroids = (polygon + polygon2) / 3.0
            centroid = np.average(centroids, axis=0, weights=signed_areas)
            return Point(x=round(centroid[0], project.decimals), y=round(centroid[1], project.decimals), z=self.points[0].z)


    def area(self) -> float: #shoelace formula
        if self.isClosed:
            if len(self.points) < 3:
                return "Polygon has less than 3 points!"
            num_points = len(self.points)
            x_y = np.array([(self.points[i].x, self.points[i].y) for i in range(num_points)])
            x_y = x_y.reshape(-1,2)
            x = x_y[:,0]
            y = x_y[:,1]
            S1 = np.sum(x*np.roll(y,-1))
            S2 = np.sum(y*np.roll(x,-1))

            area = .5*np.absolute(S1 - S2)
            return area
        else:
            print("Polycurve is not closed, no area!")
            return None


    def length(self) -> float:
        return sum(i.length for i in self.curves)


    def close(self) -> bool:
        if self.curves[0] == self.curves[-1]:
            return self
        else:
            self.curves.append(self.curves[0])
            plycrv = PolyCurve()
            for curve in self.curves:
                plycrv.curves.append(curve)
        return plycrv


    @classmethod
    def byJoinedCurves(self, curvelst:Line):
        projectClosed = project.closed
        plycrv = PolyCurve()
        for index, curve in enumerate(curvelst):
            if index == 0:
                plycrv.curves.append(curve)
                plycrv.points.append(curve.start)
                plycrv.points.append(curve.end)
            else:
                plycrv.curves.append(curve)
                plycrv.points.append(curve.end)
        if projectClosed:
            if plycrv.points[0].value == plycrv.points[-1].value:
                plycrv.isClosed = True
            else:
                # plycrv.points.append(curvelst[0].start)
                plycrv.curves.append(curve)
                plycrv.isClosed = True
        elif projectClosed == False:
            if plycrv.points[0].value == plycrv.points[-1].value:
                plycrv.isClosed = True
            else:
                plycrv.isClosed = False
        if plycrv.points[-2].value == plycrv.points[0].value:
            plycrv.curves = plycrv.curves.pop(-1)
        return plycrv


    @classmethod
    def byPoints(self, points:Point):
        projectClosed = project.closed
        plycrv = PolyCurve()
        for index, point in enumerate(points):
            plycrv.points.append(point)
            try:
                nextpoint = points[index+1]
                plycrv.curves.append(Line(start=point, end=nextpoint))
            except:
                firstpoint = points[0]
                plycrv.curves.append(Line(start=point, end=firstpoint))
        
        if projectClosed:
            if plycrv.points[0].value == plycrv.points[-1].value:
                plycrv.isClosed = True
            else:
                plycrv.isClosed = True
                plycrv.points.append(points[0])

        elif projectClosed == False:
            if plycrv.points[0].value == plycrv.points[-1].value:
                plycrv.isClosed = True
            else:
                plycrv.isClosed = False
        return plycrv

    @classmethod
    def unclosed_by_points(self, points: Point):
        plycrv = PolyCurve()
        for index, point in enumerate(points):
            plycrv.points.append(point)
            try:
                nextpoint = points[index + 1]
                plycrv.curves.append(Line(start=point, end=nextpoint))
            except:
                pass
        return plycrv

    @staticmethod
    def segment(self, count): #Create segmented polycurve. Arcs, elips will be translated to straight lines
        crvs = [] #add isClosed
        for i in self.curves:
            if i.__class__.__name__ == "Arc":
                crvs.append(Arc.segmentedarc(i, count))
            elif i.__class__.__name__ == "Line":
                crvs.append(i)
        crv = flatten(crvs)
        pc = PolyCurve.byJoinedCurves(crv)
        return pc

    @staticmethod
    def byPolyCurve2D(PolyCurve2D):
        # by points,
        plycrv = PolyCurve()
        curves = []
        for i in PolyCurve2D.curves:
            if i.__class__.__name__ == "Arc2D":
                curves.append(Arc(Point(i.start.x, i.start.y, 0), Point(i.mid.x, i.mid.y, 0), Point(i.end.x,i.end.y, 0)))
            elif i.__class__.__name__ == "Line2D":
                curves.append(Line(Point(i.start.x, i.start.y,0),Point(i.end.x, i.end.y,0)))
            else:
                print("Curvetype not found")
        pnts = []
        for i in curves:
            pnts.append(i.start)
        pnts.append(curves[0].start)
        plycrv.points = pnts
        plycrv.curves = curves
        return plycrv


    def split(self, line: Line, returnlines=None): #make sure that the lines start/stop already on the edge of the polycurve

        allLines = self.curves.copy()

        # insect = Intersect2d().getIntersectLinePolyCurve(self, line, split=True, stretch=False)
        # for pt in insect["IntersectGridPoints"]:
        #     for index, line in enumerate(allLines):
        #         if is_point_on_line_segment(pt, line) == True:
        #             cuttedLines = line.split([pt])
        #             allLines = replace_at_index(allLines,index, cuttedLines)

        insect = Intersect2d().getIntersectLinePolyCurve(self, line, split=True, stretch=False)
        for pt in insect["IntersectGridPoints"]:
            for index, line in enumerate(allLines):
                if is_point_on_line_segment(pt, line) == True:
                    cuttedLines = line.split([pt])
                    allLines = replace_at_index(allLines,index, cuttedLines)

        if len(insect["IntersectGridPoints"]) == 2:
            part1 = []
            part2 = []

            for j in allLines:
                #part1
                if j.start == insect["IntersectGridPoints"][1]:
                    part1LineEnd = j.end
                    part1.append(j.start)
                if j.end == insect["IntersectGridPoints"][0]:
                    part1LineStart = j.start
                    part1.append(j.end)
                #part2
                if j.start == insect["IntersectGridPoints"][0]:
                    part2LineEnd = j.end
                    part2.append(j.start)
                if j.end == insect["IntersectGridPoints"][1]:
                    part2LineStart = j.start
                    part2.append(j.end)

            s2 = self.points.index(part1LineStart)
            s1 = self.points.index(part1LineEnd)
            completelist = list(range(len(self.points)))
            partlist1 = flatten(completelist[s2:s1+1])
            partlist2 = flatten([completelist[s1+1:]] + [completelist[:s2]])

            SplittedPolyCurves = []
            #part1
            if part1LineStart != None and part1LineEnd != None:
                for i, index in enumerate(partlist1):
                    pts = self.points[index]
                    part1.insert(i+1, pts)
                if returnlines:
                    SplittedPolyCurves.append(PolyCurve.byPoints(part1))
                else:
                    project.objects.append(PolyCurve.byPoints(part1))

            #part2 -> BUGG?
            if part2LineStart != None and part2LineEnd != None:
                for index in partlist2:
                    pts = self.points[index]
                    part2.insert(index, pts)
                if returnlines:
                    SplittedPolyCurves.append(PolyCurve.byPoints(part2))
                else:
                    project.objects.append(PolyCurve.byPoints(part2))

            if returnlines: #return lines while using multi_split
                return SplittedPolyCurves

        else:
            print(f"Must need 2 points to split PolyCurve into PolyCurves, got now {len(insect['IntersectGridPoints'])} points.")


    def multi_split(self, lines:Line): #SOOOO SLOW, MUST INCREASE SPEAD
        lines = flatten(lines)
        new_polygons = []
        for index, line in enumerate(lines):
            if index == 0:
                n_p = self.split(line, returnlines=True)
                if n_p != None:
                    for np in n_p:
                        if np != None:
                            new_polygons.append(n_p)
            else:
                for new_poly in flatten(new_polygons):
                    n_p = new_poly.split(line, returnlines=True)
                    if n_p != None:
                        for np in n_p:
                            if np != None:
                                new_polygons.append(n_p)
        project.objects.append(flatten(new_polygons))
        return flatten(new_polygons)


    def translate(self, vector3d:Vector3):
        crvs = []
        v1 = vector3d
        for i in self.curves:
            if i.__class__.__name__ == "Arc":
                crvs.append(Arc(Point.translate(i.start, v1), Point.translate(i.middle, v1), Point.translate(i.end, v1)))
            elif i.__class__.__name__ == "Line":
                crvs.append(Line(Point.translate(i.start, v1), Point.translate(i.end, v1)))
            else:
                print("Curvetype not found")
        pc = PolyCurve()
        pc.curves = crvs
        return pc

    def rotate(self, angle, dz):
        #angle in degrees
        #dz = displacement in z-direction
        crvs = []
        for i in self.curves:
            if i.__class__.__name__ == "Arc":
                crvs.append(Arc(Point.rotateXY(i.start, angle, dz), Point.rotateXY(i.middle, angle, dz), Point.rotateXY(i.end, angle, dz)))
            elif i.__class__.__name__ == "Line":
                crvs.append(Line(Point.rotateXY(i.start, angle, dz), Point.rotateXY(i.end, angle, dz)))
            else:
                print("Curvetype not found")
        crv = PolyCurve.byJoinedCurves(crvs)
        return crv

    def toPolyCurve2D(self):
        # by points,

        p1 = PolyCurve2D()
        count = 0
        curves = []
        for i in self.curves:
            if i.__class__.__name__ == "Arc":
                curves.append(Arc2D(Point2D(i.start.x, i.start.y), Point2D(i.middle.x, i.middle.y),
                                  Point2D(i.end.x, i.end.y)))
            elif i.__class__.__name__ == "Line":
                curves.append(Line2D(Point2D(i.start.x, i.start.y), Point2D(i.end.x, i.end.y)))
            else:
                print("Curvetype not found")
        pnts = []
        for i in curves:
            pnts.append(i.start)
        pnts.append(curves[0].start)
        p1.points = pnts
        p1.curves = curves
        return p1

    @staticmethod
    def transform_from_origin(polycurve, startpoint: Point,directionvector: Vector3):
        crvs = []
        for i in polycurve.curves:
            if i.__class__.__name__ == "Arc":
                crvs.append(Arc(transformPoint(i.start,CSGlobal,startpoint,directionvector),
                                transformPoint(i.mid, CSGlobal, startpoint, directionvector),
                                transformPoint(i.end, CSGlobal, startpoint, directionvector)
                                ))
            elif i.__class__.__name__ == "Line":
                crvs.append(Line(start = transformPoint(i.start,CSGlobal,startpoint,directionvector),
                                end = transformPoint(i.end, CSGlobal, startpoint, directionvector)
                                ))
            elif i.__class__.__name__ == "Arc2D":
                # print(Point.point2DTo3D(i.start),CSGlobal, startpoint, directionvector)
                crvs.append(Arc(transformPoint(Point.point2DTo3D(i.start),CSGlobal, startpoint, directionvector),
                                transformPoint(Point.point2DTo3D(i.mid), CSGlobal, startpoint, directionvector),
                                transformPoint(Point.point2DTo3D(i.end), CSGlobal, startpoint, directionvector)
                                ))
            elif i.__class__.__name__ == "Line2D":
                crvs.append(Line(start = transformPoint(Point.point2DTo3D(i.start),CSGlobal,startpoint,directionvector),
                                end = transformPoint(Point.point2DTo3D(i.end), CSGlobal, startpoint, directionvector)
                                ))
            else:
                print(i.__class__.__name__ + "Curvetype not found")
        pc = PolyCurve()
        pc.curves = crvs
        return pc

    def __str__(self):
        l = len(self.points)
        return f"{__class__.__name__}, ({l} points)"
            
# 2D PolyCurve to 3D PolyGon

def Rect(vector: Vector3, width: float, height: float):
    #Rectangle in XY-plane with translation of vector
    p1 = Point(0,0,0).translate(Point(0, 0, 0), vector)
    p2 = Point(0,0,0).translate(Point(width, 0, 0), vector)
    p3 = Point(0,0,0).translate(Point(width, height, 0), vector)
    p4 = Point(0,0,0).translate(Point(0, height, 0), vector)
    crv = PolyCurve.byPoints([p1, p2, p3, p4, p1])
    return crv

def RectXY(vector: Vector3, width: float, height: float):
    #Rectangle in XY-plane
    p1 = Point(0,0,0).translate(Point(0, 0, 0), vector)
    p2 = Point(0,0,0).translate(Point(width, 0, 0), vector)
    p3 = Point(0,0,0).translate(Point(width, 0, height), vector)
    p4 = Point(0,0,0).translate(Point(0, 0, height), vector)
    crv = PolyCurve.byPoints([p1, p2, p3, p4, p1])
    return crv

def RectYZ(vector: Vector3, width: float, height: float):
    #Rectangle in XY-plane
    p1 = Point(0,0,0).translate(Point(0, 0, 0), vector)
    p2 = Point(0,0,0).translate(Point(0, width, 0), vector)
    p3 = Point(0,0,0).translate(Point(0, width, height), vector)
    p4 = Point(0,0,0).translate(Point(0, 0, height), vector)
    crv = PolyCurve.byPoints([p1, p2, p3, p4, p1])
    return crv



class PolyGon:
    def __init__(self, lines) -> None:
        self.Lines = lines#collect in list
        self.id = generateID()
        pass #Lines
    
    @staticmethod
    def polygon(flatCurves: Line) -> Point:
        points = []
        for i in flatCurves:
            points.append(i.start)
            try:
                points.append(i.middle)
            except:
                pass
        points.append(points[0])
        points3D = []
        for i in points:
            points3D.append(Point.point2DTo3D(i))
        return points3D

    def __id__(self):
        return f"id:{self.id}"

    def __str__(self) -> str:
        return f"{__class__.__name__}({self})"


class Arc:
    def __init__(self, startPoint: Point, midPoint: Point, endPoint: Point):
        self.id = generateID()
        self.start = startPoint
        self.mid = midPoint
        self.end = endPoint
        self.origin = self.originarc()
        v1 = Vector3(x=1, y=0, z=0)
        v2 = Vector3(x=0, y=1, z=0)
        self.plane = Plane.byTwoVectorsOrigin(
            v1,
            v2,
            self.origin
        )
        self.radius = self.radiusarc()
        self.startAngle = 0
        self.endAngle = 0
        self.angleRadian = self.angleRadian()
        self.area = 0
        self.length = self.length()
        self.units = project.units
        self.coordinatesystem = self.coordinatesystemarc()

    def distance(self, p1, p2):
        return math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2 + (p2.z - p1.z) ** 2)

    def coordinatesystemarc(self):
        vx = Vector3.byTwoPoints(self.origin, self.start)  # Local X-axe
        v2 = Vector3.byTwoPoints(self.end, self.origin)
        vz = Vector3.crossProduct(vx, v2)  # Local Z-axe
        vy = Vector3.crossProduct(vx, vz)  # Local Y-axe
        self.coordinatesystem = CoordinateSystem(self.origin, Vector3.normalize(vx), Vector3.normalize(vy),
                                                 Vector3.normalize(vz))
        return self.coordinatesystem

    def radiusarc(self):
        a = self.distance(self.start, self.mid)
        b = self.distance(self.mid, self.end)
        c = self.distance(self.end, self.start)
        s = (a + b + c) / 2
        A = math.sqrt(s * (s - a) * (s - b) * (s - c))
        R = (a * b * c) / (4 * A)
        return R

    def originarc(self):
        # calculation of origin of arc #Todo can be simplified for sure
        Vstartend = Vector3.byTwoPoints(self.start, self.end)
        halfVstartend = Vector3.scale(Vstartend, 0.5)
        b = 0.5 * Vector3.length(Vstartend)  # half distance between start and end
        x = math.sqrt(Arc.radiusarc(self) * Arc.radiusarc(self) - b * b)  # distance from start-end line to origin
        mid = Point.translate(self.start, halfVstartend)
        v2 = Vector3.byTwoPoints(self.mid, mid)
        v3 = Vector3.normalize(v2)
        tocenter = Vector3.scale(v3, x)
        center = Point.translate(mid, tocenter)
        return center

    def angleRadian(self):
        v1 = Vector3.byTwoPoints(self.origin, self.end)
        v2 = Vector3.byTwoPoints(self.origin, self.start)
        v3 = Vector3.byTwoPoints(self.origin, self.mid)
        v4 = Vector3.sum(v1,v2)
        try:
            v4b = Vector3.new_length(v4,self.radius)
            if Vector3.value(v3) == Vector3.value(v4b):
                angle = Vector3.angleRadianBetween(v1, v2)
            else:
                angle = 2*math.pi-Vector3.angleRadianBetween(v1, v2)
            return angle
        except:
            angle = 2*math.pi-Vector3.angleRadianBetween(v1, v2)
            return angle

    def length(self):
        x1, y1, z1 = self.start.x, self.start.y, self.start.z
        x2, y2, z2 = self.mid.x, self.mid.y, self.mid.z
        x3, y3, z3 = self.end.x, self.end.y, self.end.z

        r1 = ((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2) ** 0.5 / 2
        a = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2)
        b = math.sqrt((x3 - x2) ** 2 + (y3 - y2) ** 2 + (z3 - z2) ** 2)
        c = math.sqrt((x3 - x1) ** 2 + (y3 - y1) ** 2 + (z3 - z1) ** 2)
        cos_angle = (a ** 2 + b ** 2 - c ** 2) / (2 * a * b)
        m1 = math.acos(cos_angle)
        arc_length = r1 * m1

        return arc_length

    @staticmethod
    def pointsAtParameter(arc, count: int):
        # Create points at parameter on an arc based on an interval
        d_alpha = arc.angleRadian / (count - 1)
        alpha = 0
        pnts = []
        for i in range(count):
            pnts.append(Point(arc.radius * math.cos(alpha), arc.radius * math.sin(alpha), 0))
            alpha = alpha + d_alpha
        CSNew = arc.coordinatesystem
        pnts2 = []  # transformed points
        for i in pnts:
            pnts2.append(transformPoint2(i, CSNew))
        return pnts2

    @staticmethod
    def segmentedarc(arc, count):
        pnts = Arc.pointsAtParameter(arc, count)
        i = 0
        lines = []
        for j in range(len(pnts) - 1):
            lines.append(Line(pnts[i], pnts[i + 1]))
            i = i + 1
        return lines

    def __str__(self) -> str:
        return f"{__class__.__name__}()"

def transformArc(Arcold,CSNew: CoordinateSystem):
    start = transformPoint2(Arcold.start,CSNew)
    mid = transformPoint2(Arcold.mid,CSNew)
    end = transformPoint2(Arcold.end,CSNew)
    Arcnew = Arc(startPoint=start,midPoint=mid,endPoint=end)

    return Arcnew

class Circle: #auto calculate length!
    def __init__(self, radius, plane, length) -> None:
        self.radius = radius
        self.plane = plane
        self.length = length
        self.id = generateID()
        pass #Curve

    def __id__(self):
        return f"id:{self.id}"

    def __str__(self) -> str:
        return f"{__class__.__name__}({self})"


class Ellipse:
    def __init__(self, firstRadius, secondRadius, plane) -> None:
        self.firstRadius = firstRadius
        self.secondRadius = secondRadius
        self.plane = plane
        self.id = generateID()
        pass #Curve
    pass

    def __id__(self):
        return f"id:{self.id}"

    def __str__(self) -> str:
        return f"{__class__.__name__}({self})"



class Color:
	"""Documentation: output returns [r, g, b]"""
	def __init__(self, colorInput=None):
		self.colorInput = colorInput

	red = [255, 0, 0]
	green = [0, 255, 0]
	blue = [0, 0, 255]

	def Components(self, colorInput=None):
		"""1"""
		if colorInput is None:
			return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}('green')"
		else:
			try:
				JSONfile = "library/color/colorComponents.json"
				with open(JSONfile,'r') as file:
					components_dict = json.load(file)
					checkExist = components_dict.get(str(colorInput))
					if checkExist is not None:
						r, g, b, a = components_dict[colorInput]
						return [r, g, b]
					else:
						return f"Invalid {sys._getframe(0).f_code.co_name}-color, check '{JSONfile}' for available {sys._getframe(0).f_code.co_name}-colors."
			except:
				return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"

	def Hex(self, colorInput=None):
		"""NAN"""
		if colorInput is None:
			return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}('#2ba4ff')"
		else:
			# validate if value is correct/found
			try:
				colorInput = colorInput.split("#")[1]
				rgb_color = list(int(colorInput[i:i+2], 16) for i in (1, 3, 5))
				return [rgb_color[0], rgb_color[1], rgb_color[2], 255]

				# colorInput = colorInput.lstrip('#')
				# return list(int(colorInput[i:i+2], 16) for i in (0, 2, 4))
			except:
				return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"

	def rgba_to_hex(self, colorInput=None):
		"""NAN"""
		if colorInput is None:
			return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}('#2ba4ff')"
		else:
			#validate if value is correct/found
			try:
				red_i = int(colorInput[0] * 255)
				green_i = int(colorInput[1] * 255)
				blue_i = int(colorInput[2] * 255)
				alpha_i = int(colorInput[3] * 255)

				red_hex = hex(red_i)[2:].zfill(2)
				green_hex = hex(green_i)[2:].zfill(2)
				blue_hex = hex(blue_i)[2:].zfill(2)
				alpha_hex = hex(alpha_i)[2:].zfill(2)

				colorInput = "#" + red_hex + green_hex + blue_hex + alpha_hex

				return colorInput.upper()

			except:
				return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"

	def hex_to_rgba(self, colorInput=None):
		"""NAN"""
		if colorInput is None:
			return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}('#2ba4ff')"
		else:
			# validate if value is correct/found
			try:
				colorInput = colorInput.lstrip('#')
				red_int = int(colorInput[0:2], 16)
				green_int = int(colorInput[2:4], 16)
				blue_int = int(colorInput[4:6], 16)

				if len(colorInput) == 8:
					alpha_int = int(colorInput[6:8], 16)
					alpha = round(alpha_int / 255, 2)
				else:
					alpha = 1.0

				red = round(red_int / 255, 2)
				green = round(green_int / 255, 2)
				blue = round(blue_int / 255, 2)

				return [red, green, blue, alpha]

			except:
				return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"

	def CMYK(self, colorInput=None):
		"""NAN"""
		if colorInput is None:
			return f"Error: Example usage Color().CMYK([0.5, 0.25, 0, 0.2])"
		else:
			try:
				c, m, y, k = colorInput
				r = int((1-c) * (1-k) * 255)
				g = int((1-m) * (1-k) * 255)
				b = int((1-y) * (1-k) * 255)
				return [r, g, b]
			except:
				# add check help attribute
				return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"

	def Alpha(self, colorInput=None):
		"""NAN"""
		if colorInput is None:
			return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}([255, 0, 0, 128])"
		else:
			try:
				r, g, b, a = colorInput
				return [r, g, b]
			except:
				return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"

	def Brightness(self, colorInput=None):
		"""Expected value is int(0) - int(1)"""
		if colorInput is None:
			return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}([255, 0, 0, 128])"
		else:
			try:
				if colorInput >= 0 and colorInput <= 1:
					r = g = b = int(255 * colorInput)
					return [r, g, b]
				else:
					return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"
			except:
				return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"


	def RGB(self, colorInput=None):
		"""NAN"""
		if colorInput is None:
			return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}([255, 0, 0])"
		else:
			try:
				r, g, b = colorInput
				return [r, g, b]
			except:
				return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"


	def HSV(self, colorInput=None):
		"""NAN"""
		if colorInput is None:
			return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}()"
		else:
			try:
				h, s, v = colorInput
				h /= 60.0
				c = v * s
				x = c * (1 - abs(h % 2 - 1))
				m = v - c
				if 0 <= h < 1:
					r, g, b = c, x, 0
				elif 1 <= h < 2:
					r, g, b = x, c, 0
				elif 2 <= h < 3:
					r, g, b = 0, c, x
				elif 3 <= h < 4:
					r, g, b = 0, x, c
				elif 4 <= h < 5:
					r, g, b = x, 0, c
				else:
					r, g, b = c, 0, x
				return [int((r + m) * 255), int((g + m) * 255), int((b + m) * 255)]
			except:
				return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"


	def HSL(self, colorInput=None):
		"""NAN"""
		if colorInput is None:
			return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}()"
		else:
			try:
				h, s, l = colorInput
				c = (1 - abs(2 * l - 1)) * s
				x = c * (1 - abs(h / 60 % 2 - 1))
				m = l - c / 2
				if h < 60:
					r, g, b = c, x, 0
				elif h < 120:
					r, g, b = x, c, 0
				elif h < 180:
					r, g, b = 0, c, x
				elif h < 240:
					r, g, b = 0, x, c
				elif h < 300:
					r, g, b = x, 0, c
				else:
					r, g, b = c, 0, x
				r, g, b = int((r + m) * 255), int((g + m) * 255), int((b + m) * 255)
				return [r, g, b]
			except:
				return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"


	def RAL(self, colorInput=None):
		"""NAN"""
		if colorInput is None:
			return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}(1000)"
		else:
			try:
			#validate if value is correct/found
				JSONfile = "library/color/colorRAL.json"
				with open(JSONfile,'r') as file:
					ral_dict = json.load(file)
					checkExist = ral_dict.get(str(colorInput))
					if checkExist is not None:
						r, g, b = ral_dict[str(colorInput)]["rgb"].split("-")
						return [int(r), int(g), int(b), 100]
					else:
						return f"Invalid {sys._getframe(0).f_code.co_name}-color, check '{JSONfile}' for available {sys._getframe(0).f_code.co_name}-colors."
			except:
				return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"


	def Pantone(self, colorInput=None):
		"""NAN"""
		if colorInput is None:
			return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}()"
		else:
			try:
				JSONfile = "library/color/colorPantone.json"
				with open(JSONfile,'r') as file:
					pantone_dict = json.load(file)
					checkExist = pantone_dict.get(str(colorInput))
					if checkExist is not None:
						PantoneHex = pantone_dict[str(colorInput)]['hex']
						return Color().Hex(PantoneHex)
					else:
						return f"Invalid {sys._getframe(0).f_code.co_name}-color, check '{JSONfile}' for available {sys._getframe(0).f_code.co_name}-colors."
			except:
				return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"


	def LRV(self, colorInput=None):
		"""NAN"""
		if colorInput is None:
			return f"Error: Example usage Color().{sys._getframe(0).f_code.co_name}()"
		else:
			try:
				b = (colorInput - 0.2126 * 255 - 0.7152 * 255) / 0.0722
				b = int(max(0, min(255, b)))
				return [255, 255, b]
			except:
				return f"Error: Color {sys._getframe(0).f_code.co_name} attribute usage is incorrect. Documentation: Color().{sys._getframe(0).f_code.co_name}.__doc__"


	def rgb_to_int(rgb):
		r, g, b = [max(0, min(255, c)) for c in rgb]
		return (255 << 24) | (r << 16) | (g << 8) | b


	def __str__(self, colorInput=None):
		colorattributes = ["Components", "Hex", "rgba_to_hex", "hex_to_rgba", "CMYK", "Alpha", "Brightness", "RGB", "HSV", "HSL", "RAL", "Pantone", "LRV"]
		if colorInput is None:
			header = "Available attributes: \n"
			footer = "\nColor().red | Color().green | Color().blue"
			return header + '\n'.join([f"Color().{func}()" for func in colorattributes]) + footer
		return f"Color().{colorInput}"


	def Info(self, colorInput=None):
		pass



class Interval:
    def __init__(self, start:float, end:float):
        self.start = start
        self.end = end
        self.interval = None

    @classmethod
    def bystartendcount(self, start: float, end: float, count: int):
        intval = []
        numb = start
        delta = end-start
        for i in range(count):
            intval.append(numb)
            numb = numb + (delta / (count - 1))
        self.interval = intval
        return self


    def __str__(self):
        return f"{__class__.__name__}"



class Plane:
    #Plane is an infinite element in space defined by a point and a normal
    def __init__(self):
        self.Origin = Point(0, 0, 0)
        self.Normal = Vector3(x=0, y=0, z=1)
        self.v1 = Vector3(x=1, y=0, z=0)
        self.v2 = Vector3(x=0, y=1, z=0)

    @classmethod
    def byTwoVectorsOrigin(cls, v1, v2, origin):
        p1 = Plane()
        p1.Normal = Vector3.normalize(Vector3.crossProduct(v1, v2))
        p1.Origin = origin
        p1.v1 = v1
        p1.v2 = v2
        return p1

    def __str__(self):
        return f"{__class__.__name__}(" + f"{self.Origin}, {self.Normal}, {self.v1}, {self.v2})"

    #TODO
    #byLineAndPoint
    #byOriginNormal
    #byThreePoints


class Text:
    def __init__(self, text: str = None, font_family: str = None, cs= CoordinateSystem, height=None):
        self.text = text
        self.font_family = font_family or "arial"
        self.xyz = cs.Origin
        self.csglobal = cs
        self.x, self.y, self.z = 0,0,0
        self.scale = None
        self.height = height or project.font_height
        self.bbHeight = None
        self.width = None
        self.character_offset = 150
        self.space = 850
        self.curves = []
        self.points = []
        self.path_list = self.load_path()
        self.load_o_example = self.load_o()


    def load_path(self) -> str:
      #  with open(f'library/text/json/{self.font_family}.json', 'r') as f:
        with open(f'C:/Users/mikev/Documents/GitHub/building.py/library/text/json/{self.font_family}.json','r') as f:
            glyph_data = json.load(f)
            output = []
            for letter in self.text:
                if letter in glyph_data:
                    output.append(glyph_data[letter]["glyph-path"])
                elif letter == " ":
                    output.append("space")
            return output


    def load_o(self) -> str:
       # with open(f'library/text/json/{self.font_family}.json', 'r') as f:
        with open(f'C:/Users/mikev/Documents/GitHub/building.py/library/text/json/{self.font_family}.json','r') as f:
            glyph_data = json.load(f)
            load_o = []
            letter = "o"
            if letter in glyph_data:
                load_o.append(glyph_data[letter]["glyph-path"])
            return load_o


    def write(self) -> List[List[PolyCurve]]:
        #start ref_symbol
        path = self.load_o_example
        ref_points = []
        ref_allPoints = []
        for segment in path:
            pathx = parse_path(segment)
            for segment in pathx:
                segment_type = segment.__class__.__name__
                if segment_type == 'Line':
                    ref_points.extend([(segment.start.real, segment.start.imag), (segment.end.real, segment.end.imag)])
                    ref_allPoints.extend([(segment.start.real, segment.start.imag), (segment.end.real, segment.end.imag)])
                elif segment_type == 'CubicBezier':
                    ref_points.extend(segment.sample(10))
                    ref_allPoints.extend(segment.sample(10))
                elif segment_type == 'QuadraticBezier':
                    for i in range(11):
                        t = i / 10.0
                        point = segment.point(t)
                        ref_points.append((point.real, point.imag))
                        ref_allPoints.append((point.real, point.imag))
                elif segment_type == 'Arc':
                    ref_points.extend(segment.sample(10))
                    ref_allPoints.extend(segment.sample(10))
        height = self.calculate_bounding_box(ref_allPoints)[2]
        self.scale = self.height / height 
        #end ref_symbol

        output_list = []
        for letter_path in self.path_list:
            points = []
            allPoints = []
            if letter_path == "space":
                self.x += self.space + self.character_offset
                pass
            else:
                path = parse_path(letter_path)
                for segment in path:
                    segment_type = segment.__class__.__name__
                    if segment_type == 'Move':
                        if len(points) > 0:
                            points = []
                            allPoints.append("M")
                        subpath_started = True
                    elif subpath_started:
                        if segment_type == 'Line':
                            points.extend([(segment.start.real, segment.start.imag), (segment.end.real, segment.end.imag)])
                            allPoints.extend([(segment.start.real, segment.start.imag), (segment.end.real, segment.end.imag)])
                        elif segment_type == 'CubicBezier':
                            points.extend(segment.sample(10))
                            allPoints.extend(segment.sample(10))
                        elif segment_type == 'QuadraticBezier':
                            for i in range(11):
                                t = i / 10.0
                                point = segment.point(t)
                                points.append((point.real, point.imag))
                                allPoints.append((point.real, point.imag))
                        elif segment_type == 'Arc':
                            points.extend(segment.sample(10))
                            allPoints.extend(segment.sample(10))
                if points:
                    output_list.append(self.convert_points_to_polyline(allPoints))
                    width = self.calculate_bounding_box(allPoints)[1]
                    self.x += width + self.character_offset
                    
                height = self.calculate_bounding_box(allPoints)[2]
                self.bbHeight = height
        pList = []
        for ply in flatten(output_list):
            translated = self.translate(ply)
            pList.append(translated)


        for pl in pList:
            for pt in pl.points:
                self.points.append(pt)
        
        #print(f'Object text naar objects gestuurd.')
        return pList


    def translate(self, polyCurve):
        trans = []
        for pt in polyCurve.points:
            pscale = Point.product(self.scale, pt)
            pNew = transformPoint2(pscale, self.csglobal)
            trans.append(pNew)
        return polyCurve.byPoints(trans)



    def calculate_bounding_box(self, points):
        points = [elem for elem in points if elem != 'M']
        ptList = [Point2D(pt[0], pt[1]) for pt in points]
        bounding_box_polyline = BoundingBox2d().byPoints(ptList)
        return bounding_box_polyline, bounding_box_polyline.width, bounding_box_polyline.height


    def convert_points_to_polyline(self, points: Point) -> PolyCurve: #move
        output_list = []
        sub_lists = [[]]
        tempPoints = [elem for elem in points if elem != 'M']
        x_values = [point[0] for point in tempPoints]
        y_values = [point[1] for point in tempPoints]

        xmin = min(x_values)
        ymin = min(y_values)

        for item in points:
            if item == 'M':
                sub_lists.append([])
            else:
                x = item[0] + self.x - xmin
                y = item[1] + self.y - ymin
                z = self.xyz.z
                eput = x, y, z
                sub_lists[-1].append(eput)
        output_list = [[Point(point[0], point[1], self.xyz.z) for point in element] for element in sub_lists]

        polyline_list = [
            PolyCurve.byPoints([Point(coord.x, coord.y, self.xyz.z) for coord in pts])
            for pts in output_list
        ]
        return polyline_list




class Vector2:
    def __init__(self, x, y) -> None:
        self.x: float = 0.0
        self.y: float = 0.0
        self.x = x
        self.y = y
        self.id = generateID()

    @staticmethod
    def byTwoPoints(p1, p2):
        return Vector2(
            p2.x-p1.x,
            p2.y-p1.y
        )

    @staticmethod
    def length(v1):
        return math.sqrt(v1.x * v1.x + v1.y * v1.y)

    @staticmethod
    def scale(v1, scalefactor):
        return Vector2(
            v1.x * scalefactor,
            v1.y * scalefactor
        )

    @staticmethod
    def normalize(v1):
        scale = 1/Vector2.length(v1)
        return Vector2(
            v1.x*scale,
            v1.y*scale
        )

    @staticmethod #inwendig product, if zero, then vectors are perpendicular
    def dotProduct(v1, v2):
        return v1.x*v2.x+v1.y*v2.y

    @staticmethod
    def angleBetween(v1, v2):
        return math.degrees(math.acos((Vector2.dotProduct(v1, v2)/(Vector2.length(v1) * Vector2.length(v2)))))

    @staticmethod
    def angleRadianBetween(v1, v2):
        return math.acos((Vector2.dotProduct(v1, v2)/(Vector2.length(v1) * Vector2.length(v2))))

    @staticmethod #Returns vector perpendicular on the two vectors
    def crossProduct(v1, v2):
        return Vector3(
            v1.y - v2.y,
            v2.x - v1.x,
            v1.x*v2.y - v1.y*v2.x
        )

    def __id__(self):
        return f"id:{self.id}"

    def __str__(self) -> str:
        return f"{__class__.__name__}({self.X},{self.Y})"

class Point2D:
    def __init__(self, x, y) -> None:
        self.x: float = 0.0
        self.y: float = 0.0
        self.x = x
        self.y = y
        self.id = generateID()

    def __id__(self):
        return f"id:{self.id}"
    
    def translate(self, vector: Vector2):
        x = self.x + vector.x
        y = self.y + vector.y
        p1 = Point2D(x, y)
        return p1

    def rotate(self, rotation):
        x = self.x
        y = self.y
        r = math.sqrt(x * x + y * y)
        rotationstart = math.degrees(math.atan2(y, x))
        rotationtot = rotationstart + rotation
        xn = round(math.cos(math.radians(rotationtot)) * r,3)
        yn = round(math.sin(math.radians(rotationtot)) * r,3)
        p1 = Point2D(xn, yn)
        return p1

    def __str__(self) -> str:
        return f"{__class__.__name__}({self.x},{self.y})"

    @staticmethod
    def distance(point1, point2):
        return math.sqrt((point1.x - point2.x)**2 + (point1.y - point2.y)**2)

    @staticmethod
    def midpoint(point1, point2):
        return Point2D((point2.x-point1.x)/2, (point2.y-point1.y)/2)

    @staticmethod
    def toPixel(point1, Xmin, Ymin, TotalWidth, TotalHeight, ImgWidthPix: int, ImgHeightPix: int):
      # Convert Point to pixel on a image given a deltaX, deltaY, Width of the image etc.
      x = point1.x
      y = point1.y
      xpix = math.floor(((x - Xmin) / TotalWidth) * ImgWidthPix)
      ypix = ImgHeightPix-math.floor(((y - Ymin) / TotalHeight) * ImgHeightPix) # min vanwege coord stelsel Image.Draw
      return xpix, ypix

def transformPoint2D(PointLocal1: Point2D, CoordinateSystemNew: CoordinateSystem):
    # Transform point from Global Coordinatesystem to a new Coordinatesystem
    # CSold = CSGlobal
    PointLocal = Point(PointLocal1.x, PointLocal1.y, 0)
    pn = Point.translate(CoordinateSystemNew.Origin, Vector3.scale(CoordinateSystemNew.Xaxis, PointLocal.x))
    pn2 = Point.translate(pn, Vector3.scale(CoordinateSystemNew.Yaxis, PointLocal.y))
    pn3 = Point2D(pn.x,pn.y)
    return pn3

class Line2D:
    def __init__(self, pntxy1, pntxy2) -> None:
        self.start: Point2D = pntxy1
        self.end: Point2D = pntxy2
        self.x = [self.start.x, self.end.x]
        self.y = [self.start.y, self.end.y]
        self.dx = self.start.x-self.end.x
        self.dy = self.start.y-self.end.y
        self.length = 0
        self.id = generateID()

    def __id__(self):
        return f"id:{self.id}"

    def length(self):
        self.length = math.sqrt(self.dx*self.dx+self.dy*self.dy)
        return self.length

    def fline(self):
        #returns line for Folium(GIS)
        return [[self.start.y,self.start.x],[self.end.y,self.end.x]]
    def __str__(self) -> str:
        return f"{__class__.__name__}({self.start},{self.end})"


class Arc2D:
    def __init__(self,pntxy1,pntxy2,pntxy3) -> None:
        self.start:Point2D = pntxy1
        self.mid: Point2D = pntxy2
        self.end: Point2D = pntxy3
        self.origin = self.originarc()
        self.angleRadian = self.angleRadian()
        #self.radius = self.radiusarc()
        self.coordinatesystem = self.coordinatesystemarc()
        #self.length

        self.id = generateID()

    def __id__(self):
        return f"id:{self.id}"

    def points(self):
        #returns point on the curve
        return (self.start, self.mid, self.end)

    def coordinatesystemarc(self):
        vx2d = Vector2.byTwoPoints(self.origin, self.start)  # Local X-axe
        vx = Vector3(vx2d.x, vx2d.y, 0)
        vy = Vector3(vx.y, vx.x * -1,0)
        vz = Vector3(0,0,1)
        self.coordinatesystem = CoordinateSystem(self.origin, Vector3.normalize(vx), Vector3.normalize(vy), Vector3.normalize(vz))
        return self.coordinatesystem

    def angleRadian(self):
        v1 = Vector2.byTwoPoints(self.origin, self.end)
        v2 = Vector2.byTwoPoints(self.origin, self.start)
        angle = Vector2.angleRadianBetween(v1,v2)
        return angle

    def originarc(self):
        #calculation of origin of arc #Todo can be simplified for sure
        Vstartend = Vector2.byTwoPoints(self.start, self.end)
        halfVstartend = Vector2.scale(Vstartend,0.5)
        b = 0.5 * Vector2.length(Vstartend) #half distance between start and end
        try:
            x = math.sqrt(Arc2D.radiusarc(self) * Arc2D.radiusarc(self) - b * b) #distance from start-end line to origin
        except:
            x = 0
        mid = Point2D.translate(self.start, halfVstartend)
        v2 = Vector2.byTwoPoints(self.mid, mid)
        v3 = Vector2.normalize(v2)
        tocenter = Vector2.scale(v3, x)
        center = Point2D.translate(mid, tocenter)
        self.origin = center
        return center

    def radiusarc(self):
        a = Vector2.length(Vector2.byTwoPoints(self.start, self.mid))
        b = Vector2.length(Vector2.byTwoPoints(self.mid, self.end))
        c = Vector2.length(Vector2.byTwoPoints(self.end, self.start))
        s = (a + b + c) / 2
        A = math.sqrt(s * (s-a) * (s-b) * (s-c))
        R = (a * b * c) / (4 * A)
        return R


    @staticmethod
    def pointsAtParameter(arc, count: int):
        # Create points at parameter on an arc based on an interval
        d_alpha = arc.angleRadian / (count - 1)
        alpha = 0
        pnts = []
        for i in range(count):
            pnts.append(Point2D(arc.radius * math.cos(alpha), arc.radius * math.sin(alpha), 0))
            alpha = alpha + d_alpha
        CSNew = arc.coordinatesystem
        pnts2 = []  # transformed points
        for i in pnts:
            pnts2.append(transformPoint2D(i, CSNew))
        return pnts2

    @staticmethod
    def segmentedarc(arc, count):
        pnts = Arc2D.pointsAtParameter(arc,count)
        i = 0
        lines = []
        for j in range(len(pnts)-1):
            lines.append(Line2D(pnts[i],pnts[i+1]))
            i = i + 1
        return lines

    def __str__(self):
        return f"{__class__.__name__}({self.start},{self.mid},{self.end})"


class PolyCurve2D:
    def __init__(self) -> None:
        self.curves = [] #collect in list
        self.points2D = []
        self.id = generateID()

    def __id__(self):
        return f"id:{self.id}"

    @classmethod
    def byJoinedCurves(cls, curves):
        pc = PolyCurve2D()
        for i in curves:
            pc.curves.append(i)
            pc.points2D.append(i.start)
            pc.points2D.append(i.end)
        return pc

    def points(self):
        for i in self.curves:
            self.points2D.append(i.start)
            self.points2D.append(i.end)
        return self.points2D

    @classmethod
    def byPoints(self, points: list):
        plycrv = PolyCurve2D()
        for index, point2D in enumerate(points):
            plycrv.points2D.append(point2D)
            try:
                nextpoint = points[index + 1]
                plycrv.curves.append(Line2D(point2D, nextpoint))
            except:
                firstpoint = points[0]
                plycrv.curves.append(Line2D(point2D, firstpoint))
        return plycrv

    def translate(self, vector2d:Vector2):
        crvs = []
        v1 = vector2d
        for i in self.curves:
            if i.__class__.__name__ == "Arc2D":
                crvs.append(Arc2D(i.start.translate(v1), i.mid.translate(v1), i.end.translate(v1)))
            elif i.__class__.__name__ == "Line2D":
                crvs.append(Line2D(i.start.translate(v1), i.end.translate(v1)))
            else:
                print("Curvetype not found")
        crv = PolyCurve2D.byJoinedCurves(crvs)
        return crv

    def rotate(self, rotation):
        crvs = []
        for i in self.curves:
            if i.__class__.__name__ == "Arc2D":
                crvs.append(Arc2D(i.start.rotate(rotation), i.mid.rotate(rotation), i.end.rotate(rotation)))
            elif i.__class__.__name__ == "Line2D":
                crvs.append(Line2D(i.start.rotate(rotation), i.end.rotate(rotation)))
            else:
                print("Curvetype not found")
        crv = PolyCurve2D.byJoinedCurves(crvs)
        return crv

    @staticmethod
    def boundingboxGlobalCS(PC):
        x =[]
        y =[]
        for i in PC.curves():
            x.append(i.start.x)
            y.append(i.start.y)
        xmin = min(x)
        xmax = max(x)
        ymin = min(y)
        ymax = max(y)
        bbox = PolyCurve2D.byPoints([Point2D(xmin,ymin),Point2D(xmax,ymin),Point2D(xmax,ymax),Point2D(xmin,ymax),Point2D(xmin,ymin)])
        return bbox

    @staticmethod
    def bounds(PC):
        #returns xmin,xmax,ymin,ymax,width,height of polycurve 2D
        x =[]
        y =[]
        for i in PC.curves:
            x.append(i.start.x)
            y.append(i.start.y)
        xmin = min(x)
        xmax = max(x)
        ymin = min(y)
        ymax = max(y)
        width = xmax-xmin
        height = ymax-ymin
        return xmin,xmax,ymin,ymax,width,height

    @staticmethod
    def polygon(self):
        points = []
        for i in self.curves:
            if i == Arc2D:
                points.append(i.start, i.mid) #
            else:
                points.append(i.start)
        points.append(points[0])
        return points

 #   def __str__(self) -> str:
#        return f"{__class__.__name__}({self})"


class Surface2D:
    def __init__(self) -> None:
        pass #PolyCurve2D
        self.id = generateID()
    pass #opening(PolyCurve2D)
        
    def __id__(self):
        return f"id:{self.id}"

    def __str__(self) -> str:
        return f"{__class__.__name__}({self})"


class Profile2D:
    def __init__(self) -> None:
        pass #Surface2D, collect curves and add parameters
        self.id = generateID()
    #voorzien van parameters
    #gebruiken voor objecten(kanaalplaatvloer, HEA200, iets)
    pass

    def __id__(self):
        return f"id:{self.id}"

    def __str__(self) -> str:
        return f"{__class__.__name__}({self})"


class ParametricProfile2D:
    def __init__(self) -> None:
        pass #iets van profile hier inladen
        self.id = generateID()
    # Aluminium
    # Generic
    # Precast Concrete
    # ParametricProfile2D
    pass

    def __id__(self):
        return f"id:{self.id}"

    def __str__(self) -> str:
        return f"{__class__.__name__}({self})"


class Intersect:
    def __init__(self):
        pass
    
    def getLineIntersect(line1: Line, line2: Line) -> Point:
        p1, p2 = line1.start, line1.end
        p1X, p1Y, P1Z = p1.x, p1.y, p1.z
        p2X, p2Y, P2Z = p2.x, p2.y, p2.z

        p3, p4 = line2.start, line2.end
        p3X, p3Y, P3Z = p3.x, p3.y, p3.z
        p4X, p4Y, P4Z = p4.x, p4.y, p4.z

        print(p1X, p1Y, P1Z)


class Intersect2d:
    def __init__(self):
        pass

    def perp(self, a):
        b = np.empty_like(a)
        b[0] = -a[1]
        b[1] = a[0]
        return b
    
    #two lines intersect
    def getLineIntersect(self, line1, line2):
        if line1.start == line1.end or line2.start == line2.end:
            return None

        p1, p2 = line1.start, line1.end
        p1X, p1Y, p1Z = p1.x, p1.y, p1.z
        p2X, p2Y, p2Z = p2.x, p2.y, p2.z

        p3, p4 = line2.start, line2.end
        p3X, p3Y, p3Z = p3.x, p3.y, p3.z
        p4X, p4Y, p4Z = p4.x, p4.y, p4.z

        da = np.array([p2X, p2Y]) - np.array([p1X, p1Y])
        db = np.array([p4X, p4Y]) - np.array([p3X, p3Y])
        dp = np.array([p1X, p1Y]) - np.array([p3X, p3Y])
        dap = self.perp(da)
        denom = np.dot(dap, db)
        if abs(denom) < 1e-6:
            return None
        num = np.dot(dap, dp)
        t = num / denom
        nX, nY = np.array([p3X, p3Y]) + t * db
        return Point(nX, nY, 0)


    def getMultiLineIntersect(self, lines=Line) -> Point:
        pts = []
        for i in range(len(lines)):
            line1 = lines[i]
            for j in range(i+1, len(lines)):
                line2 = lines[j]
                intersection = Intersect2d().getLineIntersect(line1, line2)
                if intersection not in pts and intersection != None and is_point_on_line_segment(intersection, line2) == True:
                    pts.append(intersection)
        return pts

    
    #polycurve to line intersect
    def getIntersectLinePolyCurve(self, polycurves: Point, lines, split=None, stretch=None) -> Point:
        dict = {}
        intersectionsPointsList = []
        splitedLinesList = []
        InnerGridLines = []
        OuterGridLines = []
        if isinstance(lines, Line):
            lines = [lines]
        for line in lines:
            IntersectGridPoints = []
            for i in range(len(polycurves.points) - 1):
                genLine = Line(polycurves.points[i], polycurves.points[i+1])
                checkIntersect = Intersect2d().getLineIntersect(genLine, line)
                if stretch == False or stretch == None:
                    if checkIntersect != None:
                        if is_point_on_line_segment(checkIntersect, line) == False:
                            checkIntersect = None
                        else:
                            minX = min(polycurves.points[i].x, polycurves.points[i+1].x)
                            maxX = max(polycurves.points[i].x, polycurves.points[i+1].x)
                            minY = min(polycurves.points[i].y, polycurves.points[i+1].y)
                            maxY = max(polycurves.points[i].y, polycurves.points[i+1].y)
                        if checkIntersect != None:
                            if minX <= checkIntersect.x <= maxX and minY <= checkIntersect.y <= maxY:
                                intersectionsPointsList.append(checkIntersect)
                                IntersectGridPoints.append(checkIntersect)

                elif stretch == True: #autojoin/combine the lines if they in same direction.
                    minX = min(polycurves.points[i].x, polycurves.points[i+1].x)
                    maxX = max(polycurves.points[i].x, polycurves.points[i+1].x)
                    minY = min(polycurves.points[i].y, polycurves.points[i+1].y)
                    maxY = max(polycurves.points[i].y, polycurves.points[i+1].y)
                    if checkIntersect != None:
                        if minX <= checkIntersect.x <= maxX and minY <= checkIntersect.y <= maxY:
                            intersectionsPointsList.append(checkIntersect)
                            IntersectGridPoints.append(checkIntersect)

            if split == True:
                if len(IntersectGridPoints) > 0:
                    splitedLinesList.append(line.split(IntersectGridPoints))


        for splittedLines in splitedLinesList:
            for line in splittedLines:
                centerLinePoint = line.pointAtParameter(0.5)
                if is_point_in_polygon(centerLinePoint, polycurves) == True:
                    InnerGridLines.append(line)
                else:
                    OuterGridLines.append(line)

        # dict["IntersectPolyCurve"] = polycurves
        dict["IntersectGridPoints"] = intersectionsPointsList
        dict["SplittedLines"] = flatten(splitedLinesList)
        dict["InnerGridLines"] = InnerGridLines
        dict["OuterGridLines"] = OuterGridLines

        return dict
    


def is_point_in_line(point, line): #check if point is in align with line (in direction)
    distance = abs((line.end.y - line.start.y) * point.x
                   - (line.end.x - line.start.x) * point.y
                   + line.end.x * line.start.y
                   - line.end.y * line.start.x) \
               / line.length()
    return distance < 1e-9


def is_point_on_line_segment(point, line):
    x_min = min(line.start.x, line.end.x)
    x_max = max(line.start.x, line.end.x)
    y_min = min(line.start.y, line.end.y)
    y_max = max(line.start.y, line.end.y)

    # Check if the point is in the bounding box of the line segment
    if x_min <= point.x <= x_max and y_min <= point.y <= y_max:
        # Check if the distance from the point to the line is within a small tolerance
        distance = abs((line.end.y - line.start.y) * point.x
                       - (line.end.x - line.start.x) * point.y
                       + line.end.x * line.start.y
                       - line.end.y * line.start.x) \
                   / line.length
        return distance < 1e-9
    else:
        return False


def is_point_in_polygon(point, polygon):
    x, y, z = point.x, point.y, point.z
    intersections = 0
    for curve in polygon.curves:
        p1, p2 = curve.start, curve.end
        if (y > min(p1.y, p2.y)) and (y <= max(p1.y, p2.y)) and (x <= max(p1.x, p2.x)):
            if p1.y != p2.y:
                x_inters = (y - p1.y) * (p2.x - p1.x) / (p2.y - p1.y) + p1.x
                if (p1.x == p2.x) or (x <= x_inters):
                    intersections += 1
    # print(intersections % 2 != 0)
    return intersections % 2 != 0


def is_polygon_in_polygon(polygon1, polygon2):
    booleans2 = []
    pts2 = []
    for curve in polygon2.curves:
        pts2S, pts2E = curve.start, curve.end
        booleans2.append(is_point_in_polygon(pts2S, polygon1))
        booleans2.append(is_point_in_polygon(pts2E, polygon1))
    print(all_true(booleans2))
    return all_true(booleans2)
    #is_point_in_polygon(Point5, ply1) #True


def planelineIntersection():
    # Define a line by its direction vector and a point on it
    line_dir = [1, 2, 3] # direction vector of the line
    line_pt = [0, 0, 0] # a point on the line

    # Define a plane by its normal vector and a point on it
    plane_norm = [4, 5, 6] # normal vector of the plane
    plane_pt = [1, 1, 1] # a point on the plane

    # Compute the dot product of the line direction and the plane normal
    dot_prod = sum([a*b for a,b in zip(line_dir, plane_norm)])

    # Check if the dot product is zero, which means the line is parallel to the plane
    if dot_prod == 0:
        print("The line is parallel to the plane. No intersection point.")
    else:
        # Compute the parameter t that gives the intersection point
        t = sum([(a-b)*c for a,b,c in zip(plane_pt, line_pt, plane_norm)]) / dot_prod

        # Compute the intersection point by plugging t into the line equation
        inter_pt = [a + b*t for a,b in zip(line_pt, line_dir)]

        # Print the intersection point
        print("The intersection point is", inter_pt)


HiddenLine1 = ["Hidden Line 1", [1, 1], 100]  # Rule: line, whitespace, line whitespace etc., scale
HiddenLine2 = ["Hidden Line 2", [2, 1], 100]  # Rule: line, whitespace, line whitespace etc., scale
Centerline = ["Center Line 1", [8, 2, 2, 2], 100]  # Rule: line, whitespace, line whitespace etc., scale

def lineToPattern(baseline, patternobj):
    #This converts a line to list of lines based on a pattern
    origin = baseline.start
    dir = Vector3.byTwoPoints(baseline.start, baseline.end)
    unityvect = Vector3.normalize(dir)

    Pattern = patternobj
    l = baseline.length
    patternlength = sum(Pattern[1]) * Pattern[2]
    count = math.floor(l / patternlength)  # aantal hele lengtes van het patroon
    lines = []

    startpoint = origin
    ll = 0
    rl = 10000
    for i in range(count + 1):
        n = 0
        for i in Pattern[1]:
            deltaV = Vector3.product(i * Pattern[2], unityvect)
            dl = Vector3.length(deltaV)
            if rl < dl:  # dit is het laatste lijnstuk op de lijn waarbij het patroon in stukje geknipt gaat worden.
                endpoint = baseline.end
            else:
                endpoint = Point.translate(startpoint, deltaV)
            if n % 2:
                a = 1 + 1
            else:
                lines.append(Line(start=startpoint, end=endpoint))
            if rl < dl:
                break  # Einde lijn bereikt
            startpoint = endpoint
            n = n + 1
            ll = ll + dl  # totale lengte
            rl = l - ll  # resterende lengte binnen het patroon
        startpoint = startpoint
    return lines



class Extrusion:
    #Extrude a 2D profile to a 3D mesh or solid
    def __init__(self):
        self.verts = []
        self.faces = []
        self.numberFaces = 0
        self.countVertsFaces = 0 # total number of verts per face (not the same as total verts)
        self.name = "none"
        self.color = (255,255,0)
        self.colorlst = []
        self.topface = None #return polycurve -> surface
        self.bottomface = None #return polycurve -> surface
        self.polycurve_3d_translated = None
        self.id = generateID()

    @classmethod
    def merge(self, extrusions:list, name=None):
        Outrus = Extrusion()
        if isinstance(extrusions, list):
            Outrus.verts = []
            Outrus.faces = []
            Outrus.colorlst = []
            for ext in extrusions:
                Outrus.verts.append(ext.verts)
                Outrus.faces.append(ext.faces)
                Outrus.colorlst.append(ext.colorlst)
            Outrus.verts = flatten(Outrus.verts)
            Outrus.faces = flatten(Outrus.faces)
            Outrus.colorlst = flatten(Outrus.colorlst)
            return Outrus

        elif isinstance(extrusions, Extrusion):
            return extrusions


    @classmethod
    def byPolyCurveHeightVector(self, polycurve2d: PolyCurve, height, CSOld, startpoint, DirectionVector: Vector3):
        Extrus = Extrusion()
        #2D PolyCurve @ Global origin
        count = 0
        
        Extrus.polycurve_3d_translated = PolyCurve.transform_from_origin(polycurve2d,startpoint,DirectionVector)
        for i in polycurve2d.curves:
            startpointLow = transformPoint(Point(i.start.x,i.start.y,0), CSOld, startpoint, DirectionVector)
            endpointLow = transformPoint(Point(i.end.x,i.end.y,0), CSOld, startpoint, DirectionVector)
            endpointHigh = transformPoint(Point(i.end.x,i.end.y,height), CSOld, startpoint, DirectionVector)
            startpointHigh = transformPoint(Point(i.start.x,i.start.y,height), CSOld, startpoint, DirectionVector)

            #Construct faces perpendicular on polycurve
            Extrus.faces.append(4)
            Extrus.verts.append(startpointLow.x)
            Extrus.verts.append(startpointLow.y)
            Extrus.verts.append(startpointLow.z)
            Extrus.faces.append(count)
            count += 1
            Extrus.verts.append(endpointLow.x)
            Extrus.verts.append(endpointLow.y)
            Extrus.verts.append(endpointLow.z)
            Extrus.faces.append(count)
            count += 1
            Extrus.verts.append(endpointHigh.x)
            Extrus.verts.append(endpointHigh.y)
            Extrus.verts.append(endpointHigh.z)
            Extrus.faces.append(count)
            count += 1
            Extrus.verts.append(startpointHigh.x)
            Extrus.verts.append(startpointHigh.y)
            Extrus.verts.append(startpointHigh.z)
            Extrus.faces.append(count)
            count += 1
            Extrus.numberFaces = Extrus.numberFaces + 1
            #    vert = [0, 0, 0, 1000, 0, 0, 1000, 2000, 0, 0, 1000, 0, 0, 2000, 2000, 3000, 2000, 1000]
            # list structure of verts is x y z x y z x y z
            #    faces = [3, 0, 1, 2, 3, 2, 3, 5]
            # list structure of faces is [number of verts], vert.index, vert.index, vert.index, vert2.index. enz.
            # first number is number of vertices.
            # then

        #bottomface
        Extrus.faces.append(len(polycurve2d.curves))
        count = 0
        for i in polycurve2d.curves:
            Extrus.faces.append(count)
            count = count + 4

        # topface
        Extrus.faces.append(len(polycurve2d.curves))
        count = 3
        for i in polycurve2d.curves:
            Extrus.faces.append(count)
            count = count + 4

        Extrus.countVertsFaces = (4 * Extrus.numberFaces) #aantal zonder bovenzijde/onderzijde

        Extrus.countVertsFaces = Extrus.countVertsFaces + len(polycurve2d.curves)*2
        Extrus.numberFaces = Extrus.numberFaces + 2

        for j in range(int(len(Extrus.verts) / 3)):
            Extrus.colorlst.append(Extrus.color)


        return Extrus

    @classmethod
    def byPolyCurveHeight(self, polycurve: PolyCurve, height, dzloc: float):
        #global len
        Extrus = Extrusion()
        Points = polycurve.points
        V1 = Vector3.byTwoPoints(Points[0], Points[1])  # Vector op basis van punt 0 en 1
        V2 = Vector3.byTwoPoints(Points[-2], Points[-1])  # Vector op basis van laatste punt en een na laatste punt

        p1 = Plane.byTwoVectorsOrigin(V1, V2, Points[0]) #Workplane of PolyCurve
        norm = p1.Normal

        pnts = []
        faces = []

        Extrus.polycurve_3d_translated = polycurve

        #allverts
        for pnt in Points:
            pnts.append(Point.translate(pnt, Vector3.product(dzloc, norm))) # Onderzijde verplaatst met dzloc
        for pnt in Points:
            pnts.append(Point.translate(pnt, Vector3.product((dzloc+height), norm)))  # Bovenzijde verplaatst met dzloc

        numPoints = len(Points)

        #Bottomface
        count = 0
        face = []
        for x in range(numPoints):
            face.append(count)
            count = count + 1
        faces.append(face)

        # Topface
        count = 0
        face = []
        for x in range(numPoints):
            face.append(count+numPoints)
            count = count + 1
        faces.append(face)

        # Sides
        count = 0
        length = len(faces[0])
        for i,j in zip(faces[0],faces[1]):
            face = []
            face.append(i)
            face.append(faces[0][count + 1])
            face.append(faces[1][count + 1])
            face.append(j)
            count = count + 1
            if count == length-1:
                face.append(i)
                face.append(faces[0][0])
                face.append(faces[1][0])
                face.append(j)
                faces.append(face)
                break
            else:
                pass
            faces.append(face)

        #toMeshStructure
        for i in pnts:
            Extrus.verts.append(i.x)
            Extrus.verts.append(i.y)
            Extrus.verts.append(i.z)

        for x in faces:
            Extrus.faces.append(len(x)) #Number of verts in face
            for y in x:
                Extrus.faces.append(y)

        Extrus.numberFaces = len(faces)
        Extrus.countVertsFaces = (4 * len(faces))

        for j in range(int(len(Extrus.verts) / 3)):
            Extrus.colorlst.append(Extrus.color)
        return Extrus

#check if there are innercurves inside the outer curve.

class Surface: #Polycurves must be closed!!!!!!!
    def __init__(self, PolyCurves:PolyCurve, color=None) -> None:
        #self.outerPolyCurve
        #self.innerPolyCurves
        if isinstance(PolyCurves, PolyCurve):
            PolyCurves = [PolyCurves]

        self.mesh = []
        self.length = 0
        self.area = 0 #return the same area of the polyCurve but remove the innerpolycurves
        self.offset = 0
        self.name = "test2"
        self.id = generateID()
        self.PolyCurveList = PolyCurves
        self.origincurve = None
        if color is None:
            self.color = Color.rgb_to_int(Color().Components("gray"))
        else:
            self.color = color

        self.colorlst = []
        self.fill(self.PolyCurveList)

    def fill(self, PolyCurveList):
        if isinstance(PolyCurveList, PolyCurve):
            plycColorList = []
            p = Extrusion.byPolyCurveHeight(PolyCurveList, 0, self.offset)
            self.mesh.append(p)
            for j in range(int(len(p.verts) / 3)):
                plycColorList.append(self.color)
            self.colorlst.append(plycColorList)

        elif isinstance(PolyCurveList, list):
            for polyCurve in PolyCurveList:
                plycColorList = []
                p = Extrusion.byPolyCurveHeight(polyCurve, 0, self.offset)
                self.mesh.append(p)
                for j in range(int(len(p.verts) / 3)):
                    plycColorList.append(self.color)
                self.colorlst.append(plycColorList)

    def void(self, polyCurve):
        # Find the index of the extrusion that intersects with the polyCurve
        idx = None
        for i, extr in enumerate(self.mesh):
            if extr.intersects(polyCurve):
                idx = i
                break

        if idx is not None:
            # Remove the intersected extrusion from the extrusion list
            removed = self.mesh.pop(idx)

            # Remove the corresponding color list from the colorlst list
            removed_colors = self.colorlst.pop(idx)

            # Create a new list of colors for the remaining extrusions
            new_colors = []
            for colors in self.colorlst:
                new_colors.extend(colors)

            # Fill the hole with a new surface
            hole_surface = Surface([polyCurve], color=self.color)
            hole_surface.fill([polyCurve])
            hole_extrusion = hole_surface.extrusion[0]

            # Add the hole extrusion to the extrusion list
            self.mesh.append(hole_extrusion)

            # Add the hole colors to the colorlst list
            hole_colors = [Color.rgb_to_int(Color().Components("red"))] * int(len(hole_extrusion.verts) / 3)
            self.colorlst.append(hole_colors)

            # Add the remaining colors to the colorlst list
            self.colorlst.extend(new_colors)

            # Update the origin curve
            self.origincurve = self.PolyCurveList[0]


    def __id__(self):
        return f"id:{self.id}"

    # def __str__(self) -> str:
    #     return f"{__class__.__name__}({self})"


class NurbsSurface: #based on point data / degreeU&countU / degreeV&countV?
    def __init__(self) -> None:
        pass
        self.id = generateID()
    pass

    def __id__(self):
        return f"id:{self.id}"

    def __str__(self) -> str:
        return f"{__class__.__name__}({self})"


class PolySurface:
    def __init__(self) -> None:
        pass
        self.id = generateID()
    pass

    def __id__(self):
        return f"id:{self.id}"

    def __str__(self) -> str:
        return f"{__class__.__name__}({self})"


class System:
    #Generic class for systems
    def __init__(self):
        self.name = None
        self.id = generateID()
        self.polycurve = None
        self.direction: Vector3 = Vector3(1,0,0)


class DivisionSystem:
    # This class provides divisionsystems. It returns lists with floats based on a length.

    def __init__(self):
        self.name = None
        self.id = generateID()
        self.system_length: float = 100
        self.spacing: float = 10
        self.distance_first: float = 5
        self.width_stud: float = 10
        self.fixed_number: int = 2
        self.modifier: int = 0
        self.distances = [] #List with sum of distances
        self.spaces = [] #List with spaces between every divison
        self.system: str = "fixed_distance_unequal_division"

    def __fixed_number_equal_spacing(self):
        self.name = "fixed_number_equal_spacing"
        self.distances = Interval.bystartendcount(0, self.system_length, self.fixed_number)
        self.spacing = self.system_length / self.fixed_number
        self.modifier = 0
        self.distance_first = self.spacing

    def __fixed_distance_unequal_division(self):
        self.name = "fixed_distance_unequal_division"
        rest_length = self.system_length - self.distance_first
        number_of_studs = int(rest_length / self.spacing)
        number_of_studs = number_of_studs + self.modifier
        distance = self.distance_first
        for i in range(number_of_studs+1):
            if distance < self.system_length:
                self.distances.append(distance)
            else: break
            distance = distance + self.spacing

    def __fixed_distance_equal_division(self):
        self.name = "fixed_distance_equal_division"
        number_of_studs = int(self.system_length / self.spacing)
        number_of_studs = number_of_studs + self.modifier
        sum_length_studs_x_spacing = (number_of_studs - 1) * self.spacing
        rest_length = self.system_length - sum_length_studs_x_spacing
        distance = rest_length / 2
        for i in range(number_of_studs):
            self.distances.append(distance)
            distance = distance + self.spacing

    def by_fixed_distance_unequal_division(self, length, spacing, distance_first, modifier):
        self.system_length = length
        self.modifier = modifier
        self.spacing = spacing
        self.distance_first = distance_first
        self.system = "fixed_distance_unequal_division"
        self.__fixed_distance_unequal_division()
        return self

    def by_fixed_distance_equal_division(self, length, spacing, modifier):
        self.system_length = length
        self.modifier = modifier
        self.spacing = spacing
        self.system = "fixed_distance_equal_division"
        self.__fixed_distance_equal_division()
        return self

    def by_fixed_number_equal_spacing(self, length, number):
        self.system_length = length
        self.system = "fixed_number_equal_spacing"
        self.spacing = length/number
        self.modifier = 0
        distance = self.spacing
        for i in range(number-1):
            self.distances.append(distance)
            distance = distance + self.spacing
        self.distance_first = self.spacing
        return self

        #  fixed_number_equal_interior_fill
        #  maximum_spacing_equal_division
        #  maximum_spacing_unequal_division
        #  minimum_spacing_equal_division
        #  minimum_spacing_unequal_division

class RectangleSystem:
    #Reclangle Left Bottom is in Local XYZ. Main direction parallel to height direction vector. Top is z=0
    def __init__(self):
        self.name = None
        self.id = generateID()
        self.height = 3000
        self.width = 2000
        self.bottom_frame_type = Rectangle("bottom_frame_type", 38, 184)
        self.top_frame_type = Rectangle("top_frame_type", 38, 184)
        self.left_frame_type = Rectangle("left_frame_type", 38, 184)
        self.right_frame_type = Rectangle("left_frame_type", 38, 184)
        self.inner_frame_type = Rectangle("inner_frame_type", 38, 184)

        self.material = BaseTimber
        self.inner_width: float =  0
        self.inner_height: float =  0
        self.coordinatesystem = CSGlobal
        self.local_coordinate_system = CSGlobal
        #self.openings = []
        #self.subsystems = []
        self.division_system = None
        self.inner_frame_objects = []
        self.outer_frame_objects = []
        self.panel_objects = []
        self.symbolic_inner_mother_surface = None
        self.symbolic_inner_panels = None
        self.symbolic_outer_grids = []
        self.symbolic_inner_grids = []

    def __inner_panels(self):
        #First Inner panel
        i = self.division_system.distances[0]
        point1 = self.mother_surface_origin_point_x_zero
        point2 = Point.translate(self.mother_surface_origin_point_x_zero, Vector3(i - self.inner_frame_type.b * 0.5, 0, 0))
        point3 = Point.translate(self.mother_surface_origin_point_x_zero,
                                 Vector3(i - self.inner_frame_type.b * 0.5, self.inner_height, 0))
        point4 = Point.translate(self.mother_surface_origin_point_x_zero, Vector3(0, self.inner_height, 0))
        self.panel_objects.append(
            Panel.byPolyCurveThickness(
                PolyCurve.byPoints([point1, point2, point3, point4, point1]), 184, 0, "innerpanel",
                rgb_to_int([255, 240, 160]))
        )
        count = 0
        # In between
        for i in self.division_system.distances:
            try:
                point1 = Point.translate(self.mother_surface_origin_point_x_zero,Vector3(self.division_system.distances[count]+self.inner_frame_type.b*0.5,0,0))
                point2 = Point.translate(self.mother_surface_origin_point_x_zero,Vector3(self.division_system.distances[count+1]-self.inner_frame_type.b*0.5,0,0))
                point3 = Point.translate(self.mother_surface_origin_point_x_zero,Vector3(self.division_system.distances[count+1]-self.inner_frame_type.b*0.5,self.inner_height,0))
                point4 = Point.translate(self.mother_surface_origin_point_x_zero,Vector3(self.division_system.distances[count]+self.inner_frame_type.b*0.5, self.inner_height, 0))
                self.panel_objects.append(
                    Panel.byPolyCurveThickness(
                        PolyCurve.byPoints([point1,point2,point3,point4,point1]),184,0,"innerpanel",rgb_to_int([255,240,160]))
                    )
                count = count + 1
            except:
                #Last panel
                point1 = Point.translate(self.mother_surface_origin_point_x_zero,Vector3(self.division_system.distances[count]+self.inner_frame_type.b*0.5,0,0))
                point2 = Point.translate(self.mother_surface_origin_point_x_zero,Vector3(self.inner_width+self.left_frame_type.b,0,0))
                point3 = Point.translate(self.mother_surface_origin_point_x_zero,Vector3(self.inner_width+self.left_frame_type.b,self.inner_height,0))
                point4 = Point.translate(self.mother_surface_origin_point_x_zero,Vector3(self.division_system.distances[count]+self.inner_frame_type.b*0.5, self.inner_height, 0))
                self.panel_objects.append(
                    Panel.byPolyCurveThickness(
                        PolyCurve.byPoints([point1,point2,point3,point4,point1]),184,0,"innerpanel",rgb_to_int([255,240,160]))
                    )
                count = count + 1

    def __inner_mother_surface(self):
        #Inner mother surface is the surface within the outer frames dependent on the width of the outer frametypes.
        self.inner_width = self.width-self.left_frame_type.b-self.right_frame_type.b
        self.inner_height = self.height-self.top_frame_type.b-self.bottom_frame_type.b
        self.mother_surface_origin_point = Point(self.left_frame_type.b,self.bottom_frame_type.b,0)
        self.mother_surface_origin_point_x_zero = Point(0,self.bottom_frame_type.b,0)
        self.symbolic_inner_mother_surface = PolyCurve.byPoints(
            [self.mother_surface_origin_point,
             Point.translate(self.mother_surface_origin_point,Vector3(self.inner_width,0,0)),
             Point.translate(self.mother_surface_origin_point,Vector3(self.inner_width,self.inner_height,0)),
             Point.translate(self.mother_surface_origin_point, Vector3(0, self.inner_height, 0)),
             self.mother_surface_origin_point]
        )

    def __inner_frames(self):
        for i in self.division_system.distances:
            start_point = Point.translate(self.mother_surface_origin_point_x_zero,Vector3(i,0,0))
            end_point = Point.translate(self.mother_surface_origin_point_x_zero,Vector3(i,self.inner_height,0))
            self.inner_frame_objects.append(
                Frame.byStartpointEndpointCurveJustifiction(start_point,end_point, self.inner_frame_type.curve, "innerframe","center","top", 0,self.material)
            )
            self.symbolic_inner_grids.append(Line(start=start_point,end=end_point))

    def __outer_frames(self):
        bottomframe = Frame.byStartpointEndpointCurveJustifiction(Point(0,0,0),Point(self.width,0,0), self.bottom_frame_type.curve, "bottomframe","left","top", 0,self.material)
        self.symbolic_outer_grids.append(Line(start=Point(0,0,0), end=Point(self.width,0,0)))

        topframe = Frame.byStartpointEndpointCurveJustifiction(Point(0,self.height,0),Point(self.width,self.height,0), self.top_frame_type.curve, "bottomframe","right","top", 0,self.material)
        self.symbolic_outer_grids.append(Line(start=Point(0,self.height,0), end=Point(self.width,self.height,0)))

        leftframe = Frame.byStartpointEndpointCurveJustifiction(Point(0,self.bottom_frame_type.b,0),Point(0,self.height-self.top_frame_type.b,0), self.left_frame_type.curve, "leftframe","right","top", 0,self.material)
        self.symbolic_outer_grids.append(Line(start=Point(0,self.bottom_frame_type.b,0), end=Point(0,self.height-self.top_frame_type.b,0)))

        rightframe = Frame.byStartpointEndpointCurveJustifiction(Point(self.width,self.bottom_frame_type.b,0),Point(self.width,self.height-self.top_frame_type.b,0), self.right_frame_type.curve, "leftframe","left","top", 0,self.material)
        self.symbolic_outer_grids.append(Line(start=Point(self.width,self.bottom_frame_type.b,0), end=Point(self.width,self.height-self.top_frame_type.b,0)))

        self.outer_frame_objects.append(bottomframe)
        self.outer_frame_objects.append(topframe)
        self.outer_frame_objects.append(leftframe)
        self.outer_frame_objects.append(rightframe)
    def by_width_height_divisionsystem_studtype(self,width,height,framewidth,frameheight,division_system,filling):
        self.width = width
        self.height = height
        self.bottom_frame_type = Rectangle("bottom_frame_type", framewidth, frameheight)
        self.top_frame_type = Rectangle("top_frame_type", framewidth, frameheight)
        self.left_frame_type = Rectangle("left_frame_type", framewidth, frameheight)
        self.right_frame_type = Rectangle("left_frame_type", framewidth, frameheight)
        self.inner_frame_type = Rectangle("inner_frame_type", framewidth, frameheight)
        self.division_system = division_system
        self.__inner_mother_surface()
        self.__inner_frames()
        self.__outer_frames()
        if filling:
            self.__inner_panels()
        else:
            pass
        return self


#   def geom_substem:





def rgb_to_int(rgb):
    r, g, b = [max(0, min(255, c)) for c in rgb]

    return (255 << 24) | (r << 16) | (g << 8) | b

class Material:
    def __init__(self):
        self.name = "none"
        self.color = None
        self.colorint = None

    @classmethod
    def byNameColor(cls, name, color):
        M1 = Material()
        M1.name = name
        M1.color = color
        M1.colorint = rgb_to_int(color)
        return M1



BaseConcrete = Material.byNameColor("Concrete", Color().RGB([192, 192, 192]))
BaseTimber = Material.byNameColor("Timber", Color().RGB([191, 159, 116]))
BaseSteel = Material.byNameColor("Steel", Color().RGB([237, 28, 36]))
BaseOther = Material.byNameColor("Other", Color().RGB([150, 150, 150]))

#class Materialfinish

jsonFile = "https://raw.githubusercontent.com/3BMLabs/building.py/main/library/profile_database/steelprofile.json"
# jsonFile = "https://raw.githubusercontent.com/DutchSailor/Project-Ocondat/master/steelprofile.json"
# jsonFile = "https://raw.githubusercontent.com/joas1606/jupyter/main/jsontestfile.json"
url = urllib.request.urlopen(jsonFile)
data = json.loads(url.read())


class searchProfile:
    def __init__(self, name):
        self.name = name
        self.shape_coords = None
        self.shape_name = None
        self.synonyms = None
        for item in data:
            for i in item.values():
                synonymList = i[0]["synonyms"]
                #if self.name in synonymList:
                #bools = [self.name.lower() in e for e in [synonym.lower() for synonym in synonymList]]
                #if True in bools:
                if self.name.lower() in [synonym.lower() for synonym in synonymList]:
                    self.shape_coords = i[0]["shape_coords"]
                    self.shape_name = i[0]["shape_name"]
                    self.synonyms = i[0]["synonyms"]


class profiledataToShape:
    def __init__(self, name1, segmented = False):
        profile_data = searchProfile(name1)
        shape_name = profile_data.shape_name
        self.shape_name = shape_name
        name = profile_data.name
        self.d1 = profile_data.shape_coords
        #self.d1.insert(0,name)
        d1 = self.d1
        if shape_name == "C-channel parallel flange":
            prof = CChannelParallelFlange(name,d1[0],d1[1],d1[2],d1[3],d1[4],d1[5])
        elif shape_name == "C-channel sloped flange":
            prof = CChannelSlopedFlange(name,d1[0],d1[1],d1[2],d1[3],d1[4],d1[5],d1[6],d1[7],d1[8])
        elif shape_name == "I-shape parallel flange":
            prof = IShapeParallelFlange(name,d1[0],d1[1],d1[2],d1[3],d1[4])
        elif shape_name == "I-shape sloped flange":
            prof = IShapeParallelFlange(name, d1[0], d1[1], d1[2], d1[3], d1[4])
            #Todo: add sloped flange shape
        elif shape_name == "Rectangle":
            prof = Rectangle(name,d1[0], d1[1])
        elif shape_name == "Round":
            prof = Round(name, d1[1])
        elif shape_name == "Round tube profile":
            prof = Roundtube(name, d1[0], d1[1])
        elif shape_name == "LAngle":
            prof = LAngle(name,d1[0],d1[1],d1[2],d1[3],d1[4],d1[5],d1[6],d1[7])
        elif shape_name == "TProfile":
            prof = TProfile(name, d1[0], d1[1], d1[2], d1[3], d1[4], d1[5], d1[6], d1[7], d1[8])
        elif shape_name == "Rectangle Hollow Section":
            prof = RectangleHollowSection(name,d1[0],d1[1],d1[2],d1[3],d1[4])
        else:
            prof = "error, profile not created"
        self.prof = prof
        self.data = d1
        pc2d = self.prof.curve  # 2D polycurve
        if segmented == True:
            pc3d = PolyCurve.byPolyCurve2D(pc2d)
            pcsegment = PolyCurve.segment(pc3d, 10)
            pc2d2 = pcsegment.toPolyCurve2D()
        else:
            pc2d2 = pc2d
        self.polycurve2d = pc2d2

def justifictionToVector(plycrv2D: PolyCurve2D, XJustifiction, Yjustification, ey=None, ez=None):
    
    # print(XJustifiction)
    xval = []
    yval = []
    for i in plycrv2D.curves:
        xval.append(i.start.x)
        yval.append(i.start.y)

    #Boundingbox2D
    xmin = min(xval)
    xmax = max(xval)
    ymin = min(yval)
    ymax = max(yval)

    b = xmax-xmin
    h = ymax-ymin

    # print(b, h)

    dxleft = -xmax
    dxright = -xmin
    dxcenter = dxleft - 0.5 * b #CHECK
    dxorigin = 0

    dytop = -ymax
    dybottom = -ymin
    dycenter = dytop - 0.5 * h #CHECK
    dyorigin = 0

    if XJustifiction == "center":
        dx = 0 #TODO
    elif XJustifiction == "left":
        dx = dxleft
    elif XJustifiction == "right":
        dx = dxright
    elif XJustifiction == "origin":
        dx = 0 #TODO
    else:
        dx = 0

    if Yjustification == "center":
        dy = 0   #TODO
    elif Yjustification == "top":
        dy = dytop
    elif Yjustification == "bottom":
        dy = dybottom
    elif Yjustification == "origin":
        dy = 0 #TODO
    else:
        dy = 0

    # print(dx, dy)
    v1 = Vector2(dx, dy)

    return v1


class Support:
    def __init__(self):
        self.Number = None
        self.Point: Point = Point(0,0,0)
        self.Tx: str = " " # A, P, N, S
        self.Ty: str = " " # A, P, N, S
        self.Tz: str = " " # A, P, N, S
        self.Rx: str = " " # A, P, N, S
        self.Ry: str = " " # A, P, N, S
        self.Rz: str = " " # A, P, N, S
        self.Kx: float = 0 # kN/m
        self.Ky: float = 0 # kN/m
        self.Kz: float = 0 # kN/m
        self.Cx: float = 0 # kNm/rad
        self.Cy: float = 0 # kNm/rad
        self.Cz: float = 0 # kNm/rad
        self.dx: float = 0 #eccentricity in x
        self.dy: float = 0 #eccentricity in y
        self.dz: float = 0 #eccentricity in z

    @staticmethod
    def pinned(PlacementPoint):
        sup = Support()
        sup.Point = PlacementPoint
        sup.Tx = "A"
        sup.Ty = "A"
        sup.Tz = "A"
        return(sup)

    @staticmethod
    def xRoller(PlacementPoint):
        sup = Support()
        sup.Point = PlacementPoint
        sup.Ty = "A"
        sup.Tz = "A"
        return(sup)

    @staticmethod
    def yRoller(PlacementPoint):
        sup = Support()
        sup.Point = PlacementPoint
        sup.Tx = "A"
        sup.Tz = "A"
        return(sup)

    @staticmethod
    def zRoller(PlacementPoint):
        sup = Support()
        sup.Point = PlacementPoint
        sup.Tx = "A"
        sup.Ty = "A"
        return(sup)

    @staticmethod
    def fixed(PlacementPoint):
        sup = Support()
        sup.Point = PlacementPoint
        sup.Tx = "A"
        sup.Ty = "A"
        sup.Tz = "A"
        sup.Rx = "A"
        sup.Ry = "A"
        sup.Rz = "A"
        return(sup)

class LoadCase:
    def __init__(self):
        self.Number = None
        self.Description: str = ""
        self.psi0 = 1
        self.psi1 = 1
        self.psi2 = 1
        self.Type = 0   #0 = permanent, 1 = variabel

class SurfaceLoad:
    def __init__(self):
        self.LoadCase = None
        self.PolyCurve: PolyCurve = None
        self.Description: str = ""
        self.crs = "ccaa0435161960d4c7e436cf107a03f61"
        self.direction = "caf2b4ce743de1df30071f9566b1015c6"
        self.LoadBearingDirection = "cfebf3fce7063ab9a89d28a86508c0fb3"
        self.q1 = 0
        self.q2 = 0
        self.q3 = 0
        self.LoadConstantOrLinear = "cb81ae405e988f21166edf06d7fd646fb"
        self.iq1 = -1
        self.iq2 = -1
        self.iq3 = -1

    @staticmethod
    def byLoadCasePolyCurveQ(LoadCase, PolyCurve, q):
        SL = SurfaceLoad()
        SL.LoadCase = LoadCase
        SL.PolyCurve = PolyCurve
        SL.q1 = q
        SL.q2 = q
        SL.q3 = q
        return SL


class LoadPanel:
    def __init__(self):
        self.PolyCurve: PolyCurve = None
        self.Description: str = ""
        self.LoadBearingDirection = "X"
        self.SurfaceType = "" #Wall, saddle_roof_positive_pitch #Wall, / Free-standing wall, Flat roof, Shed roof, Saddle roof, Unknown

def ChessBoardSurfaceLoadsRectangle(startx, starty, dx, dy, nx, ny, width, height, LoadCase, q123, description:str):
    SurfaceLoads = []
    x = startx
    y = starty
    for j in range(ny):
        for i in range(nx):
            SL = SurfaceLoad()
            SL.Description = description
            SL.LoadCase = LoadCase
            SL.PolyCurve = PolyCurve.byPoints(
                [Point(x, y, 0),
                Point(x + width, y, 0),
                Point(x, y + height, 0),
                Point(x, y, 0)]
            )
            SL.q1 = SL.q2 = SL.q3 = q123 #[kN/m2]
            SurfaceLoads.append(SL)
            x = x + dx
        y = y + dy
    return SurfaceLoads



class TickMark:
    #Dimension Tick Mark
    def __init(self):
        self.name = None
        self.id = generateID()
        self.curves = []

    @staticmethod
    def by_curves(name,curves):
        TM = TickMark()
        TM.name = name
        TM.curves = curves
        return TM

TMDiagonal = TickMark.by_curves("diagonal",[Line(start = Point(-100,-100,0),end = Point(100,100,0))])

class DimensionType:
    def __init__(self):
        self.name = None
        self.id = generateID()
        self.font = None
        self.text_height = 2.5
        self.tick_mark: TickMark = TMDiagonal
        self.line_extension = 100

    @staticmethod
    def by_name_font_textheight_tick_mark_extension(name: str,font: str,text_height: float,tick_mark: TickMark,line_extension:float):
        DT = DimensionType()
        DT.name = name
        DT.font = font
        DT.text_height = text_height
        DT.tick_mark = tick_mark
        DT.line_extension = line_extension
        return DT


DT2_5_mm = DimensionType.by_name_font_textheight_tick_mark_extension("2.5 mm","calibri",2.5,TMDiagonal,100)

DT1_8_mm = DimensionType.by_name_font_textheight_tick_mark_extension("1.8 mm","calibri",2.5,TMDiagonal,100)

class Dimension:
    def __init__(self, start: Point, end: Point, dimension_type) -> None:
        self.start: Point = start
        self.text_height = 100
        self.end: Point = end
        self.id = generateID()
        self.scale = 0.1 #text
        self.dimension_type: DimensionType = dimension_type
        self.curves = []
        self.length: float = Line(start=self.start,end=self.end).length
        self.text = None
        self.geom()

    @staticmethod
    def by_startpoint_endpoint_offset(start:Point,end:Point,dimension_type: DimensionType, offset: float):
        DS = Dimension()
        DS.start = start
        DS.end = end
        DS.dimension_type = dimension_type
        DS.geom()
        return DS

    def geom(self):
        #baseline
        baseline = Line(start=self.start,end=self.end)
        midpoint_text = baseline.mid_point()
        direction = Vector3.normalize(baseline.vector)
        tick_mark_extension_point_1 = Point.translate(self.start,Vector3.reverse(Vector3.scale(direction,self.dimension_type.line_extension)))
        tick_mark_extension_point_2 = Point.translate(self.end,Vector3.scale(direction,self.dimension_type.line_extension))
        x = direction
        y = Vector3.rotateXY(x, math.radians(90))
        z = ZAxis
        cs_new_start = CoordinateSystem(self.start,x,y,z)
        cs_new_mid = CoordinateSystem(midpoint_text, x, y, z)
        cs_new_end = CoordinateSystem(self.end,x,y,z)
        self.curves.append(Line(tick_mark_extension_point_1,self.start)) #extention_start
        self.curves.append(Line(tick_mark_extension_point_2,self.end)) #extention_end
        self.curves.append(Line(self.start,self.end)) #baseline
        crvs = Line(start = self.dimension_type.tick_mark.curves[0].start,end = self.dimension_type.tick_mark.curves[0].end) #erg vieze oplossing. #Todo

        self.curves.append(Line.transform(self.dimension_type.tick_mark.curves[0], cs_new_start)) #dimension tick start
        self.curves.append(Line.transform(crvs, cs_new_end))  #dimension tick end
        self.text = Text(text=str(round(self.length)), font_family=self.dimension_type.font, cs=cs_new_mid, height=self.text_height).write()

    def write(self,project):
        for i in self.curves:
            project.objects.append(i)
        for j in self.text:
            project.objects.append(j)


class FrameTag:
    def __init__(self):
        # Dimensions in 1/100 scale
        self.scale = 0.1
        self.cs: CoordinateSystem = CSGlobal
        self.offset_x = 500
        self.offset_y = 100
        self.font_family = "calibri"
        self.text: str = "text"
        self.text_curves = None
        self.text_height = 100

    def __textobject(self):
        cstext = self.cs
        # cstextnew = cstext.translate(self.textoff_vector_local)
        self.text_curves = Text(text=self.text, font_family=self.font_family, height=self.text_height, cs=cstext).write

    def by_cs_text(self, coordinate_system: CoordinateSystem, text):
        self.cs = coordinate_system
        self.text = text
        self.__textobject()
        return self

    def write(self, project):
        for x in self.text_curves():
            project.objects.append(x)
        return self

    @staticmethod
    def by_frame(frame):
        tag = FrameTag()
        frame_vector = frame.vector_normalised
        x = frame_vector
        y = Vector3.rotateXY(x,math.radians(90))
        z = ZAxis
        vx = Vector3.scale(frame_vector,tag.offset_x)
        frame_width = PolyCurve2D.bounds(frame.curve)[4]
        vy = Vector3.scale(y,frame_width*0.5+tag.offset_y)
        origintext = Point.translate(frame.start,vx)
        origintext = Point.translate(origintext,vy)
        csnew = CoordinateSystem(origintext,x,y,z)
        tag.cs = csnew
        tag.text = frame.name
        tag.__textobject()
        return tag


class ColumnTag:
    def __init__(self):
        #Dimensions in 1/100 scale
        self.width = 700
        self.height = 500
        self.factor = 3 #hellingsfacor leader
        self.scale = 0.1 #voor tekeningverschaling
        self.position = "TL"  # TL, TR, BL, BR Top Left Top Right Bottom Left Bottom Right
        self.cs: CoordinateSystem = CSGlobal

        #self.textoff_vector_local: Vector3 = Vector3(1,1,1)
        self.font_family = "calibri"
        self.curves = []
        #self.leadercurves()
        self.text: str = "text"
        self.text_height = 100
        self.text_offset_factor = 5
        self.textoff_vector_local: Vector3 = Vector3(self.height/self.factor,self.height+self.height/self.text_offset_factor,0)
        self.text_curves = None
        #self.textobject()

    def __leadercurves(self):
        self.startpoint = Point(0,0,0)
        self.midpoint = Point.translate(self.startpoint, Vector3(self.height/self.factor, self.height,0))
        self.endpoint = Point.translate(self.midpoint,Vector3(self.width,0,0))
        crves = [Line(start=self.startpoint,end=self.midpoint), Line(start=self.midpoint,end=self.endpoint)]
        for i in crves:
            j = Line.transform(i,self.cs)
            self.curves.append(j)

    def __textobject(self):
        cstext = self.cs

        cstextnew = CoordinateSystem.translate(cstext,self.textoff_vector_local)
        self.text_curves = Text(text=self.text, font_family=self.font_family, height=self.text_height, cs=cstextnew).write

    def by_cs_text(self,coordinate_system: CoordinateSystem, text):
        self.cs = coordinate_system
        self.text = text
        self.__leadercurves()
        self.__textobject()
        return self

    def write(self,project):
        for x in self.text_curves():
            project.objects.append(x)
        for y in self.curves:
            project.objects.append(y)

    @staticmethod
    def by_frame(frame, position= "TL"):
        tag = ColumnTag()
        csold = CSGlobal
        tag.position = position
        tag.cs = CoordinateSystem.translate(csold,Vector3(frame.start.x,frame.start.y,frame.start.z))
        tag.text = frame.name
        tag.__leadercurves()
        tag.__textobject()
        return tag


#class Label:
#class LabelType:
#class TextType:

seqChar = "A B C D E F G H I J K L M N O P Q R S T U V W X Y Z AA AB AC"
seqNumber = "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24"

class GridheadType:
    def __init__(self):
        self.name = None
        self.curves = []
        self.diameter = 150
        self.text_height = 200
        self.radius = self.diameter/2
        self.font_family = "calibri"

    def by_diam(self,name, diameter: float, font_family,text_height):
        self.name = name
        self.diameter = diameter
        self.radius = self.diameter / 2
        self.font_family = font_family
        self.text_height = text_height
        self.geom()
        return self

    def geom(self):
        radius = self.radius
        self.curves.append(Arc(startPoint=Point(-radius,radius,0),midPoint=Point(0,radius*2,0),endPoint=Point(radius,radius,0)))
        self.curves.append(Arc(startPoint=Point(-radius,radius,0),midPoint=Point(0,0,0),endPoint=Point(radius,radius,0)))
        #origin is at center of circle

GHT30 = GridheadType().by_diam("2.5 mm",400,"calibri",200)

GHT50 = GridheadType().by_diam("GHT50",600,"calibri",350)

class GridHead:
    def __init__(self):
        self.grid_name: str = "A"
        self.grid_head_type = GHT50
        self.radius = GHT50.radius
        self.CS: CoordinateSystem = CSGlobal
        self.x: float = 0.5
        self.y: float = 0
        self.text_curves = []
        self.curves = []
        self.__textobject()
        self.__geom()

    def __geom(self):
        #CStot = CoordinateSystem.translate(self.CS,Vector3(0,self.grid_head_type.radius,0))
        for i in self.grid_head_type.curves:
            self.curves.append(transformArc(i,(self.CS)))

    def __textobject(self):
        cs_text = self.CS
        cs_text_new = CoordinateSystem.move_local(cs_text,-100,40,0) #to change after center text function is implemented
        self.text_curves = Text(text=self.grid_name, font_family=self.grid_head_type.font_family, height=self.grid_head_type.text_height, cs=cs_text_new).write()

    @staticmethod
    def by_name_gridheadtype_y(name,cs: CoordinateSystem, gridhead_type,y: float):
        GH = GridHead()
        GH.grid_name = name
        GH.grid_head_type = gridhead_type
        GH.CS = cs
        GH.x = 0.5
        GH.y = y
        GH.__textobject()
        GH.__geom()
        return GH

    def write(self, project):
        for x in self.text_curves:
            project.objects.append(x)
        for y in self.curves:
            project.objects.append(y)

class Grid:
    def __init__(self):
        self.line = None
        self.start = None
        self.end = None
        self.direction: Vector3 = Vector3(0,1,0)
        self.grid_head_type = GHT50
        self.name = None
        self.bulbStart = False
        self.bulbEnd = True
        self.cs_end: CoordinateSystem = CSGlobal
        self.grid_heads = []

    def __cs(self,line):
        self.direction = line.vector_normalised
        vect3 = Vector3.rotateXY(self.direction,math.radians(-90))
        self.cs_end = CoordinateSystem(line.end,vect3,self.direction,ZAxis)


    @classmethod
    def byStartpointEndpoint(cls, line, name):
        #Create panel by polycurve
        g1 = Grid()
        g1.start = line.start
        g1.end = line.start
        g1.name = name
        g1.__cs(line)
        g1.line = lineToPattern(line, Centerline)
        g1.__grid_heads()
        return g1

    def __grid_heads(self):
        if self.bulbEnd == True:
            self.grid_heads.append(
                GridHead.by_name_gridheadtype_y(self.name,self.cs_end,self.grid_head_type,0))

    def write(self, project):
        for x in self.line:
            project.objects.append(x)
        for y in self.grid_heads:
            y.write(project)
        return self

def getGridDistances(Grids):
    #Function to create grids from the format 0, 4x5400, 4000, 4000 to absolute XYZ-values
    GridsNew = []
    GridsNew.append(0)
    distance = 0.0
    #GridsNew.append(distance)
    for i in Grids:
        #del Grids[0]
        if "x" in i:
            spl = i.split("x")
            count = int(spl[0])
            width = float(spl[1])
            for i in range(count):
                distance = distance + width
                GridsNew.append(distance)
        else:
            distance = distance + float(i)
            GridsNew.append(distance)
    return GridsNew

class GridSystem:
    #rectangle Gridsystem
    def __init__(self):
        self.gridsX = None
        self.gridsY = None
        self.dimensions = []
        self.name = None
    @classmethod
    def bySpacingLabels(cls, spacingX, labelsX, spacingY, labelsY, gridExtension):
        gs = GridSystem()
        # Create gridsystem
        #spacingXformat = "0 3000 3000 3000"
        GridEx = gridExtension

        GridsX = spacingX.split()
        GridsX = getGridDistances(GridsX)
        Xmax = max(GridsX)
        GridsXLable = labelsX.split()
        GridsY = spacingY.split()
        GridsY = getGridDistances(GridsY)
        Ymax = max(GridsY)
        GridsYLable = labelsY.split()

        gridsX = []
        dimensions = []
        count = 0
        ymaxdim1 = Ymax+GridEx-300
        ymaxdim2 = Ymax+GridEx-0
        xmaxdim1 = Xmax+GridEx-300
        xmaxdim2 = Xmax+GridEx-0
        for i in GridsX:
            gridsX.append(Grid.byStartpointEndpoint(Line(Point(i, -GridEx, 0),Point(i, Ymax+GridEx, 0)),GridsXLable[count]))
            try:
                dim = Dimension(Point(i,ymaxdim1,0),Point(GridsX[count+1],ymaxdim1,0),DT2_5_mm)
                gs.dimensions.append(dim)
            except:
                pass
            count = count + 1

        #Totaal maatvoering 1
        dim = Dimension(Point(GridsX[0], ymaxdim2, 0), Point(Xmax, ymaxdim2, 0), DT2_5_mm)
        gs.dimensions.append(dim)

        #Totaal maatvoering 2
        dim = Dimension(Point(xmaxdim2, GridsY[0], 0), Point(xmaxdim2,Ymax,0), DT2_5_mm)
        gs.dimensions.append(dim)

        gridsY = []
        count = 0
        for i in GridsY:
            gridsY.append(Grid.byStartpointEndpoint(Line(Point(-GridEx, i, 0),Point(Xmax+GridEx, i, 0)),GridsYLable[count]))
            try:
                dim = Dimension(Point(xmaxdim1,i,0),Point(xmaxdim1,GridsY[count+1],0))#,DT3_5_mm)
                gs.dimensions.append(dim)
            except:
                pass
            count = count + 1
        gs.gridsX = gridsX
        gs.gridsY = gridsY
        return gs

    def write(self, project):
        for x in self.gridsX:
            project.objects.append(x)
            for i in x.grid_heads:
                i.write(project)
        for y in self.gridsY:
            project.objects.append(y)
            for j in y.grid_heads:
                j.write(project)
        for z in self.dimensions:
            z.write(project)
        return self




def colorlist(extrus,color):
    colorlst = []
    for j in range(int(len(extrus.verts) / 3)):
        colorlst.append(color)
    return(colorlst)


# ToDo Na update van color moet ook de colorlist geupdate worden
class Frame:
    # Frame
    def __init__(self):
        self.extrusion = None
        self.type = __class__.__name__
        self.name = "none"
        self.profileName = "none"
        self.start = None
        self.end = None
        self.curve = None # 2D polycurve of the sectionprofile
        self.curve3d = None # Translated 3D polycurve of the sectionprofile
        self.length = 0
        self.coordinateSystem: CoordinateSystem = CSGlobal
        self.YJustification = "Origin"  #Top, Center, Origin, Bottom
        self.ZJustification = "Origin" #Left, Center, Origin, Right
        self.YOffset = 0
        self.ZOffset = 0
        self.rotation = 0
        self.material = None
        self.color = BaseOther.color
        self.colorlst = []
        self.vector = None
        self.vector_normalised = None

    def props(self):
        self.vector = Vector3(self.end.x-self.start.x,self.end.y-self.start.y,self.end.z-self.start.z)
        self.vector_normalised = Vector3.normalize(self.vector)
        self.length = Vector3.length(self.vector)

    @classmethod
    def byStartpointEndpointProfileName(cls, start: Point, end: Point, profile_name: str, name: str, material):
        
        f1 = Frame()
        f1.start = start
        f1.end = end
        # self.curve = Line(start, end)
        f1.curve = profiledataToShape(profile_name).polycurve2d #polycurve2d
        #except:
            #print(profile_name)
        f1.directionVector = Vector3.byTwoPoints(start, end)
        f1.length = Vector3.length(f1.directionVector)
        f1.name = name
        f1.extrusion = Extrusion.byPolyCurveHeightVector(f1.curve, f1.length, CSGlobal, start, f1.directionVector)
        f1.extrusion.name = name
        f1.curve3d = f1.extrusion.polycurve_3d_translated
        f1.profileName = profile_name
        f1.material = material
        f1.color = material.colorint
        f1.colorlst = colorlist(f1.extrusion, f1.color)
        f1.props()
        return f1

    @classmethod
    def byStartpointEndpointProfileNameShapevector(cls, start: Point, end: Point, profile_name: str, name: str, vector2d: Vector2, rotation: float, material = None):
        f1 = Frame()
        f1.start = start
        f1.end = end
        # self.curve = Line(start, end)
        try:
            curv = profiledataToShape(profile_name).polycurve2d
        except:
            # pass
            print(f"Profile does not exist: {profile_name}") #Profile does not exist
        f1.rotation = rotation
        curvrot = curv.rotate(rotation)  # rotation in degrees
        f1.curve = curvrot.translate(vector2d)
        f1.XOffset = vector2d.x
        f1.YOffset = vector2d.y
        f1.directionVector = Vector3.byTwoPoints(start, end)
        f1.length = Vector3.length(f1.directionVector)
        f1.name = name
        f1.extrusion = Extrusion.byPolyCurveHeightVector(f1.curve, f1.length, CSGlobal, start, f1.directionVector)
        f1.extrusion.name = name
        f1.curve3d = f1.extrusion.polycurve_3d_translated
        f1.profileName = profile_name
        f1.material = material
        f1.color = material.colorint
        f1.colorlst = colorlist(f1.extrusion, f1.color)
        f1.props()
        return f1

    @classmethod
    def byStartpointEndpointProfileNameJustifiction(cls, start: Point, end: Point, profile_name: str, name: str, XJustifiction: str, YJustifiction: str, rotation: float, material = None, ey: None = float, ez: None = float):
        f1 = Frame()
        f1.start = start
        f1.end = end
        # self.curve = Line(start, end)
        f1.rotation = rotation

        curv = profiledataToShape(profile_name).polycurve2d
        curv = curv.translate(Vector2(ey, ez))

        # print(rotation)
        curvrot = curv.rotate(rotation)  # rotation in degrees

        v1 = justifictionToVector(curvrot, XJustifiction, YJustifiction)
        f1.XOffset = v1.x
        f1.YOffset = v1.y
        f1.curve = curvrot.translate(v1)
        f1.directionVector = Vector3.byTwoPoints(start, end)
        f1.length = Vector3.length(f1.directionVector)
        f1.name = name
        f1.extrusion = Extrusion.byPolyCurveHeightVector(f1.curve, f1.length, CSGlobal, start, f1.directionVector)
        f1.extrusion.name = name
        f1.curve3d = f1.extrusion.polycurve_3d_translated
        f1.profileName = profile_name
        f1.material = material
        f1.color = material.colorint
        f1.colorlst = colorlist(f1.extrusion, f1.color)
        f1.props()
        return f1

            # print(profile_name) #Profile does not exist
        # curv = profiledataToShape(profile_name).prof.curve



    @classmethod
    def byStartpointEndpoint(cls, start: Point, end: Point, polycurve: PolyCurve2D, name: str, rotation: float, material = None):
        # 2D polycurve
        f1 = Frame()
        f1.start = start
        f1.end = end
        # self.curve = Line(start, end)
        f1.directionVector = Vector3.byTwoPoints(start, end)
        f1.length = Vector3.length(f1.directionVector)
        f1.name = name
        curvrot = polycurve.rotate(rotation)  # rotation in degrees
        f1.extrusion = Extrusion.byPolyCurveHeightVector(curvrot, f1.length, CSGlobal, start, f1.directionVector)
        f1.extrusion.name = name
        f1.curve3d = curvrot
        f1.profileName = name
        f1.material = material
        f1.color = material.colorint
        f1.colorlst = colorlist(f1.extrusion, f1.color)
        f1.props()
        return f1

    @classmethod
    def by_point_height_rotation(cls, start: Point, height: float, polycurve: PolyCurve2D, frame_name: str, rotation: float, material = None):
        # 2D polycurve
        f1 = Frame()
        f1.start = start
        f1.end = Point.translate(start,Vector3(0,0.00001,height))
        # self.curve = Line(start, end)
        f1.directionVector = Vector3.byTwoPoints(start, f1.end)
        f1.length = Vector3.length(f1.directionVector)
        f1.name = frame_name
        f1.profileName = frame_name
        curvrot = polycurve.rotate(rotation)  # rotation in degrees
        f1.extrusion = Extrusion.byPolyCurveHeightVector(curvrot, f1.length, CSGlobal, start, f1.directionVector)
        f1.extrusion.name = frame_name
        f1.curve3d = curvrot
        f1.material = material
        f1.color = material.colorint
        f1.colorlst = colorlist(f1.extrusion, f1.color)
        f1.props()
        return f1

    @classmethod
    def by_point_profile_height_rotation(cls, start: Point, height: float, profile_name: str, rotation: float, material = None):
        f1 = Frame()
        f1.start = start
        f1.end = Point.translate(start,Vector3(0,0.00001,height)) #TODO vertical column not possible
        # self.curve = Line(start, end)
        f1.directionVector = Vector3.byTwoPoints(start, f1.end)
        f1.length = Vector3.length(f1.directionVector)
        f1.name = profile_name
        f1.profileName = profile_name
        curv = profiledataToShape(profile_name).polycurve2d
        curvrot = curv.rotate(rotation)  # rotation in degrees
        f1.extrusion = Extrusion.byPolyCurveHeightVector(curvrot.curves, f1.length, CSGlobal, start, f1.directionVector)
        f1.extrusion.name = profile_name
        f1.curve3d = curvrot
        f1.profileName = profile_name
        f1.material = material
        f1.color = material.colorint
        f1.colorlst = colorlist(f1.extrusion, f1.color)
        f1.props()
        return f1


    @classmethod
    def byStartpointEndpointCurveJustifiction(cls, start: Point, end: Point, polycurve: PolyCurve2D, name: str, XJustifiction: str, YJustifiction: str, rotation: float, material = None):
        f1 = Frame()
        f1.start = start
        f1.end = end
        # self.curve = Line(start, end)
        f1.rotation = rotation
        curv = polycurve
        curvrot = curv.rotate(rotation)  # rotation in degrees
        v1 = justifictionToVector(curvrot, XJustifiction, YJustifiction) #center, left, right, origin / center, top bottom, origin
        f1.XOffset = v1.x
        f1.YOffset = v1.y
        f1.curve = curv.translate(v1)
        f1.directionVector = Vector3.byTwoPoints(start, end)
        f1.length = Vector3.length(f1.directionVector)
        f1.name = name
        f1.extrusion = Extrusion.byPolyCurveHeightVector(f1.curve.curves, f1.length, CSGlobal, start, f1.directionVector)
        f1.extrusion.name = name
        f1.profileName = "none"
        f1.material = material
        f1.color = material.colorint
        f1.colorlst = colorlist(f1.extrusion, f1.color)
        f1.props()
        return f1

    def write(self,project):
        project.objects.append(self)
        return self

#EVERYWHERE FOR EACH OBJECT A ROTATION/POSITION
#Make sure that the objects can be merged!

class WurksRaster3d:
    def __init__(self):
        self.bottom = None
        self.top = None
        self.name = "x"
        self.lines = None

    def byLine(self, lines: Line, bottom: float, top: float):
        self.bottom = Vector3(0, 0, bottom)
        self.top = Vector3(0, 0, top)
        self.lines = lines

        surfList = []
        for line in self.lines:
            pts = []
            pts.append(Point.translate(line.start, self.bottom))
            pts.append(Point.translate(line.end, self.bottom))
            pts.append(Point.translate(line.end, self.top))
            pts.append(Point.translate(line.start, self.top))
            project.objects.append(Surface(PolyCurve.byPoints(pts)))
            surfList.append(Surface(PolyCurve.byPoints(pts)))

        print(f"{len(surfList)}* {self.__class__.__name__} {project.createdTxt}")


class WurksPedestal:
    def __init__(self):
        self.topfilename = "temp\\jonathan\\pedestal_top.dxf"
        self.basefilename = "temp\\jonathan\\pedestal_foot.dxf"
        self.diameter = 10
        self.topheight = 3
        self.baseheight = 3
        self.cache = {}
        self.top_dxf = None
        self.base_dxf = None

    def load_dxf(self, filename):
        if filename in self.cache:
            return self.cache[filename]
        else:
            dxf = ReadDXF(filename).polycurve
            self.cache[filename] = dxf
            return dxf

    def load_top_dxf(self):
        if self.top_dxf is None:
            self.top_dxf = self.load_dxf(self.topfilename)
        return self.top_dxf

    def load_base_dxf(self):
        if self.base_dxf is None:
            self.base_dxf = self.load_dxf(self.basefilename)
        return self.base_dxf

    def byPoint(self, points, height, rotation=None):
        if isinstance(points, Point):
            points = [points]

        top = self.load_top_dxf()
        base = self.load_base_dxf()

        for point in points:
            topcenter = Point.difference(top.centroid(), point)
            translated_top = top.translate(Point.toVector(topcenter))
            project.objects.append(Extrusion.byPolyCurveHeight(translated_top, self.topheight, 0))

            frame = Rect(
                Vector3(x=(translated_top.centroid().x) - (self.diameter / 2),
                        y=(translated_top.centroid().y) - (self.diameter / 2),
                        z=point.z - self.topheight),
                self.diameter, self.diameter
            )
            project.objects.append(Extrusion.byPolyCurveHeight(frame, height - self.baseheight - self.topheight, 0))

            basecenter = Point.difference(base.centroid(), point)
            translated_base = base.translate(Point.toVector(basecenter))
            project.objects.append(Extrusion.byPolyCurveHeight(translated_base, self.baseheight, -height))

        print(f"{len(points)}* {self.__class__.__name__} {project.createdTxt}")

    pass #pootje, voet diameter(vierkant), verstelbare hoogte inregelen, 


class WurksComputerFloor(): #centerpoint / rotation / panel pattern / ply
    pass #some type of floor object


class WurksFloorFinish():
    pass #direction / pattern / ect


class WorkPlane():
    def __init__(self):
        self.length = None
        self.width = None
        self.points = []

    def create(self, length: float = None, width: float = None) -> str:
        self.length = length or 1000
        self.width = width or 1000
        rect = Rect(Vector3(0, 0, 0), self.length, self.width)
        for pt in rect.points:
            self.points.append(pt)
        project.objects.append(rect)
        print(f"1* {self.__class__.__name__} {project.createdTxt}")
        return Rect(Vector3(0, 0, 0), self.length, self.width)

    pass #pootje, voet diameter(vierkant), verstelbare hoogte inregelen, 

WorkPlane = WorkPlane()
#rotation(Vector3)/#volume/#scale

class Panel:
    #Panel
    def __init__(self):
        self.extrusion = None
        self.thickness = 0
        self.name = "none"
        self.perimeter: float = 0
        self.coordinatesystem: CoordinateSystem = CSGlobal #TODO: implementend real coordinatesystem based on first curve and/or overruled by user
        self.color = None
        self.colorlst = []
        self.origincurve = None

    @classmethod
    def byPolyCurveThickness(self, polycurve: PolyCurve, thickness: float, offset: float, name: str, colorrgbint):
        #Create panel by polycurve
        p1 = Panel()
        p1.name = name
        p1.thickness = thickness
        p1.extrusion = Extrusion.byPolyCurveHeight(polycurve, thickness, offset)
        p1.origincurve = polycurve
        for j in range(int(len(p1.extrusion.verts) / 3)):
            p1.colorlst.append(colorrgbint)
        return p1

    @classmethod
    def byBaselineHeight(self, baseline: Line, height: float, thickness: float, name: str, colorrgbint):
        #place panel vertical from baseline
        p1 = Panel()
        p1.name = name
        p1.thickness = thickness
        polycurve = PolyCurve.byPoints(
            [baseline.start,
             baseline.end,
             Point.translate(baseline.end, Vector3(0, 0, height)),
             Point.translate(baseline.start, Vector3(0, 0, height)),
             baseline.start])
        p1.extrusion = Extrusion.byPolyCurveHeight(polycurve, thickness, 0)
        p1.origincurve = polycurve
        for j in range(int(len(p1.extrusion.verts) / 3)):
            p1.colorlst.append(colorrgbint)
        return p1



sqrt2 = math.sqrt(2)
class Tshape:
    def __init__(self, name, h, b, h1, b1):
        self.Description = "T-shape"
        self.ID = "T"

        # parameters
        self.name = name
        self.curve = []
        self.h = h  # height
        self.b = b  # width
        self.h1 = h1
        self.b1 = b1

        # describe points
        p1 = Point2D(b1 / 2, -h / 2)  # right bottom
        p2 = Point2D(b1 / 2, h / 2 - h1)  # right middle 1
        p3 = Point2D(b / 2, h / 2 - h1) # right middle 2
        p4 = Point2D(b / 2, h / 2) # right top
        p5 = Point2D(-b / 2, h / 2)  # left top
        p6 = Point2D(-b / 2, h / 2 - h1)  # left middle 2
        p7 = Point2D(-b1 / 2, h / 2 - h1) # left middle 1
        p8 = Point2D(-b1 / 2, -h / 2) # left bottom

        # describe curves
        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Line2D(p3, p4)
        l4 = Line2D(p4, p5)
        l5 = Line2D(p5, p6)
        l6 = Line2D(p6, p7)
        l7 = Line2D(p7, p8)
        l8 = Line2D(p8, p1)

        self.curve = PolyCurve2D().byJoinedCurves([l1, l2, l3, l4, l5, l6, l7, l8])

        def __str__(self):
            return "Profile(" + f"{self.name})"


class Lshape:
    def __init__(self, name, h, b, h1, b1):
        self.Description = "L-shape"
        self.ID = "L"

        # parameters
        self.name = name
        self.curve = []
        self.h = h  # height
        self.b = b  # width
        self.h1 = h1
        self.b1 = b1

        # describe points
        p1 = Point2D(b / 2, -h / 2)  # right bottom
        p2 = Point2D(b / 2, -h / 2 + h1)  # right middle
        p3 = Point2D(-b / 2 + b1, -h / 2 + h1) # middle
        p4 = Point2D(-b / 2 + b1, h / 2) # middle top
        p5 = Point2D(-b / 2, h / 2)  # left top
        p6 = Point2D(-b / 2, -h / 2)  # left bottom

        # describe curves
        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Line2D(p3, p4)
        l4 = Line2D(p4, p5)
        l5 = Line2D(p5, p6)
        l6 = Line2D(p6, p1)

        self.curve = PolyCurve2D().byJoinedCurves([l1, l2, l3, l4, l5, l6])

        def __str__(self):
            return "Profile(" + f"{self.name})"


class Eshape:
    def __init__(self, name, h, b, h1):
        self.Description = "E-shape"
        self.ID = "E"

        # parameters
        self.name = name
        self.curve = []
        self.h = h  # height
        self.b = b  # width
        self.h1 = h1

        # describe points
        p1 = Point2D(b / 2, -h / 2)  # right bottom
        p2 = Point2D(b / 2, -h / 2 + h1)
        p3 = Point2D(-b / 2 + h1, -h / 2 + h1)
        p4 = Point2D(-b / 2 + h1, -h1 / 2)
        p5 = Point2D(b / 2, -h1 / 2)
        p6 = Point2D(b / 2, h1 / 2)
        p7 = Point2D(-b / 2 + h1, h1 / 2)
        p8 = Point2D(-b / 2 + h1, h / 2 - h1)
        p9 = Point2D(b / 2, h / 2 - h1)
        p10 = Point2D(b / 2, h / 2)
        p11 = Point2D(-b / 2, h / 2)
        p12 = Point2D(-b / 2, -h / 2)

        # describe curves
        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Line2D(p3, p4)
        l4 = Line2D(p4, p5)
        l5 = Line2D(p5, p6)
        l6 = Line2D(p6, p7)
        l7 = Line2D(p7, p8)
        l8 = Line2D(p8, p9)
        l9 = Line2D(p9, p10)
        l10 = Line2D(p10, p11)
        l11 = Line2D(p11, p12)
        l12 = Line2D(p12, p1)

        self.curve = PolyCurve2D().byJoinedCurves([l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12])

        def __str__(self):
            return "Profile(" + f"{self.name})"


class Nshape:
    def __init__(self, name, h, b, b1):
        self.Description = "N-shape"
        self.ID = "N"

        # parameters
        self.name = name
        self.curve = []
        self.h = h  # height
        self.b = b  # width
        self.b1 = b1

        # describe points
        p1 = Point2D(b / 2, -h / 2)  # right bottom
        p2 = Point2D(b / 2, h / 2)
        p3 = Point2D(b / 2 - b1, h / 2)
        p4 = Point2D(b / 2 - b1, -h / 2 + b1 * 2)
        p5 = Point2D(-b / 2 + b1, h / 2)
        p6 = Point2D(-b / 2, h / 2)
        p7 = Point2D(-b / 2, -h / 2)
        p8 = Point2D(-b / 2 + b1, -h / 2)
        p9 = Point2D(-b / 2 + b1, h / 2 - b1 * 2)
        p10 = Point2D(b / 2 - b1, -h / 2)

        # describe curves
        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Line2D(p3, p4)
        l4 = Line2D(p4, p5)
        l5 = Line2D(p5, p6)
        l6 = Line2D(p6, p7)
        l7 = Line2D(p7, p8)
        l8 = Line2D(p8, p9)
        l9 = Line2D(p9, p10)
        l10 = Line2D(p10, p1)

        self.curve = PolyCurve2D().byJoinedCurves([l1, l2, l3, l4, l5, l6, l7, l8, l9, l10])

        def __str__(self):
            return "Profile(" + f"{self.name})"

class Arrowshape:
    def __init__(self, name, l, b, b1, l1):
        self.Description = "Arrow-shape"
        self.ID = "Arrowshape"

        # parameters
        self.name = name
        self.curve = []
        self.l = l  # length
        self.b = b  # width
        self.b1 = b1
        self.l1 = l1

        # describe points
        p1 = Point2D(0, l / 2)  # top middle
        p2 = Point2D(b / 2, -l / 2 + l1)
        # p3 = Point2D(b1 / 2, -l / 2 + l1)
        p3 = Point2D(b1 / 2, (-l / 2 + l1) + (l / 2) / 4)
        p4 = Point2D(b1 / 2, -l / 2)
        p5 = Point2D(-b1 / 2, -l / 2)
        # p6 = Point2D(-b1 / 2, -l / 2 + l1)
        p6 = Point2D(-b1 / 2, (-l / 2 + l1) + (l / 2) / 4)
        p7 = Point2D(-b / 2, -l / 2 + l1)

        # describe curves
        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Line2D(p3, p4)
        l4 = Line2D(p4, p5)
        l5 = Line2D(p5, p6)
        l6 = Line2D(p6, p7)
        l7 = Line2D(p7, p1)

        self.curve = PolyCurve2D().byJoinedCurves([l1, l2, l3, l4, l5, l6, l7])

        def __str__(self):
            return "Profile(" + f"{self.name})"




sqrt2 = math.sqrt(2)

#Hierachie:
  #point 2D
  #line 2D
  #PolyCurve2D 2D
  #shape is een parametrische vorm heeft als resultaat een 2D curve
  #section is een profiel met eigenschappen HEA200, 200,200,10,10,5 en eventuele rekenkundige eigenschappen.
  #beam is een object wat in 3D zit met materiaal enz.

class CChannelParallelFlange:
    def __init__(self, name, h, b, tw, tf, r, ex):
        self.Description = "C-channel with parallel flange"
        self.ID = "C_PF"

        #parameters
        self.name = name
        self.curve = []
        self.h = h          #height
        self.b = b          #width
        self.tw = tw        #web thickness
        self.tf = tf        #flange thickness
        self.r1 = r        #web fillet
        self.ex = ex        #centroid horizontal


        #describe points
        p1 = Point2D(-ex, -h / 2)  # left bottom
        p2 = Point2D(b - ex, -h / 2)  # right bottom
        p3 = Point2D(b - ex, -h / 2 + tf)
        p4 = Point2D(-ex + tw + r, -h / 2 + tf)  # start arc
        p5 = Point2D(-ex + tw + r, -h / 2 + tf + r)  # second point arc
        p6 = Point2D(-ex + tw, -h / 2 + tf + r)  # end arc
        p7 = Point2D(-ex + tw, h / 2 - tf - r)  # start arc
        p8 = Point2D(-ex + tw + r, h / 2 - tf - r)  # second point arc
        p9 = Point2D(-ex + tw + r, h / 2 - tf)  # end arc
        p10 = Point2D(b - ex, h / 2 - tf)
        p11 = Point2D(b - ex, h / 2)  # right top
        p12 = Point2D(-ex, h / 2)  # left top

        #describe curves
        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Line2D(p3, p4)
        l4 = Arc2D(p4, p5, p6)
        l5 = Line2D(p6, p7)
        l6 = Arc2D(p7, p8, p9)
        l7 = Line2D(p9, p10)
        l8 = Line2D(p10, p11)
        l9 = Line2D(p11, p12)
        l10 = Line2D(p12, p1)

        self.curve = PolyCurve2D().byJoinedCurves([l1, l2, l3, l4, l5, l6, l7, l8, l9, l10])

    def __str__(self):
        return "Profile(" + f"{self.name})"


class CChannelSlopedFlange:
    def __init__(self, name, h, b, tw, tf, r1, r2, tl, sa, ex):
        self.Description = "C-channel with sloped flange"
        self.ID = "C_SF"

        # parameters
        self.name = name
        self.curve = []
        self.b = b  # width
        self.h = h  # height
        self.tf = tf  # flange thickness
        self.tw = tw  # web thickness
        self.r1 = r1  # web fillet
        self.r11 = r1 / sqrt2
        self.r2 = r2  # flange fillet
        self.r21 = r2 / sqrt2
        self.tl = tl  # flange thickness location from right
        self.sa = math.radians(sa)  # the angle of sloped flange in degrees
        self.ex = ex  # centroid horizontal

        # describe points
        p1 = Point2D(-ex, -h / 2)  # left bottom
        p2 = Point2D(b - ex, -h / 2)  # right bottom
        p3 = Point2D(b - ex, -h / 2 + tf - math.tan(self.sa) * tl - r2)  # start arc
        p4 = Point2D(b - ex - r2 + self.r21, -h / 2 + tf - math.tan(self.sa) * tl - r2 + self.r21)  # second point arc
        p5 = Point2D(b - ex - r2 + math.sin(self.sa) * r2, -h / 2 + tf - math.tan(self.sa) * (tl - r2))  # end arc
        p6 = Point2D(-ex + tw + r1 - math.sin(self.sa) * r1, -h / 2 + tf + math.tan(self.sa) * (b - tl - tw - r1))  # start arc
        p7 = Point2D(-ex + tw + r1 - self.r11, -h / 2 + tf + math.tan(self.sa) * (b - tl - tw - r1) + r1 - self.r11)  # second point arc
        p8 = Point2D(-ex + tw, -h / 2 + tf + math.tan(self.sa) * (b - tl - tw) + r1)  # end arc
        p9 = Point2D(p8.x, -p8.y)  # start arc
        p10 = Point2D(p7.x, -p7.y)  # second point arc
        p11 = Point2D(p6.x, -p6.y)  # end arc
        p12 = Point2D(p5.x, -p5.y)  # start arc
        p13 = Point2D(p4.x, -p4.y)  # second point arc
        p14 = Point2D(p3.x, -p3.y)  # end arc
        p15 = Point2D(p2.x, -p2.y)  # right top
        p16 = Point2D(p1.x, -p1.y)  # left top

        # describe curves
        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Arc2D(p3, p4, p5)
        l4 = Line2D(p5, p6)
        l5 = Arc2D(p6, p7, p8)
        l6 = Line2D(p8, p9)
        l7 = Arc2D(p9, p10, p11)
        l8 = Line2D(p11, p12)
        l9 = Arc2D(p12, p13, p14)
        l10 = Line2D(p14, p15)
        l11 = Line2D(p15, p16)
        l12 = Line2D(p16, p1)

        self.curve = PolyCurve2D().byJoinedCurves([l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12])

    def __str__(self):
        return "Profile(" + f"{self.name})"


class IShapeParallelFlange:
    def __init__(self, name, h, b, tw, tf, r):
        self.Description = "I Shape profile with parallel flange"
        self.ID = "I_PF"
        # HEA, IPE, HEB, HEM etc.

        # parameters
        self.name = name
        self.h = h  # height
        self.b = b # width
        self.tw = tw  # web thickness
        self.tf = tf  # flange thickness
        self.r = r  # web fillet
        self.r1 = r1 = r / sqrt2

        # describe points
        p1 = Point2D(b / 2, -h / 2)  # right bottom
        p2 = Point2D(b / 2, -h / 2 + tf)
        p3 = Point2D(tw / 2 + r, -h / 2 + tf)  # start arc
        p4 = Point2D(tw / 2 + r - r1, (-h / 2 + tf + r - r1))  # second point arc
        p5 = Point2D(tw / 2, -h / 2 + tf + r)  # end arc
        p6 = Point2D(tw / 2, h / 2 - tf - r)  # start arc
        p7 = Point2D(tw / 2 + r - r1, h / 2 - tf - r + r1)  # second point arc
        p8 = Point2D(tw / 2 + r, h / 2 - tf)  # end arc
        p9 = Point2D(b / 2, h / 2 - tf)
        p10 = Point2D((b / 2), (h / 2))  # right top
        p11 = Point2D(-p10.x, p10.y)  # left top
        p12 = Point2D(-p9.x, p9.y)
        p13 = Point2D(-p8.x, p8.y)  # start arc
        p14 = Point2D(-p7.x, p7.y)  # second point arc
        p15 = Point2D(-p6.x, p6.y)  # end arc
        p16 = Point2D(-p5.x, p5.y)  # start arc
        p17 = Point2D(-p4.x, p4.y)  # second point arc
        p18 = Point2D(-p3.x, p3.y)  # end arc
        p19 = Point2D(-p2.x, p2.y)
        p20 = Point2D(-p1.x, p1.y)

        # describe curves
        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Arc2D(p3, p4, p5)
        l4 = Line2D(p5, p6)
        l5 = Arc2D(p6, p7, p8)
        l6 = Line2D(p8, p9)
        l7 = Line2D(p9, p10)
        l8 = Line2D(p10, p11)
        l9 = Line2D(p11, p12)
        l10 = Line2D(p12, p13)
        l11 = Arc2D(p13, p14, p15)
        l12 = Line2D(p15, p16)
        l13 = Arc2D(p16, p17, p18)
        l14 = Line2D(p18, p19)
        l15 = Line2D(p19, p20)
        l16 = Line2D(p20, p1)

        self.curve = PolyCurve2D().byJoinedCurves([l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16])

        def __str__(self):
            return "Profile(" + f"{self.name})"


class Rectangle:
    def __init__(self, name, b, h):
        self.Description = "Rectangle"
        self.ID = "Rec"

        # parameters
        self.name = name
        self.curve = []
        self.h = h  # height
        self.b = b  # width

        # describe points
        p1 = Point2D(b / 2, -h / 2)  # right bottom
        p2 = Point2D(b / 2, h / 2)  # right top
        p3 = Point2D(-b / 2, h / 2) # left top
        p4 = Point2D(-b / 2, -h / 2) # left bottom

        # describe curves
        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Line2D(p3, p4)
        l4 = Line2D(p4, p1)

        self.curve = PolyCurve2D().byJoinedCurves([l1, l2, l3, l4])

        def __str__(self):
            return "Profile(" + f"{self.name})"


class Round:
    def __init__(self, name, r):
        self.Description = "Round"
        self.ID = "Rnd"

        # parameters
        self.name = name
        self.curve = []
        self.r = r  # radius
        self.data = (name, r, "Round")
        dr = r / sqrt2 #grootste deel

        # describe points
        p1 = Point2D(r, 0)  # right middle
        p2 = Point2D(dr, dr)
        p3 = Point2D(0, r)  # middle top
        p4 = Point2D(-dr, dr)
        p5 = Point2D(-r, 0) # left middle
        p6 = Point2D(-dr, -dr)
        p7 = Point2D(0, -r) # middle bottom
        p8 = Point2D(dr, -dr)

        # describe curves
        l1 = Arc2D(p1, p2, p3)
        l2 = Arc2D(p3, p4, p5)
        l3 = Arc2D(p5, p6, p7)
        l4 = Arc2D(p7, p8, p1)

        self.curve = PolyCurve2D().byJoinedCurves([l1, l2, l3, l4])

        def __str__(self):
            return "Profile(" + f"{self.name})"

class Roundtube:
    def __init__(self, name, d, t):
        self.Description = "Round Tube Profile"
        self.ID = "Tube"

        # parameters
        self.name = name
        self.curve = []
        self.d = d
        self.r = d/2  # radius
        self.t = t  # wall thickness
        self.data = (name, d, t, "Round Tube Profile")
        dr = self.r / sqrt2 #grootste deel
        r = self.r
        ri = r-t
        dri = ri / sqrt2

        # describe points
        p1 = Point2D(r, 0)  # right middle
        p2 = Point2D(dr,dr)
        p3 = Point2D(0, r)  # middle top
        p4 = Point2D(-dr,dr)
        p5 = Point2D(-r, 0) # left middle
        p6 = Point2D(-dr,-dr)
        p7 = Point2D(0, -r) # middle bottom
        p8 = Point2D(dr,-dr)


        p9 = Point2D(ri, 0)  # right middle inner
        p10 = Point2D(dri,dri)
        p11 = Point2D(0, ri)  # middle top inner
        p12 = Point2D(-dri,dri)
        p13 = Point2D(-ri, 0) # left middle inner
        p14 = Point2D(-dri,-dri)
        p15 = Point2D(0, -ri) # middle bottom inner
        p16 = Point2D(dri,-dri)

        # describe curves
        l1 = Arc2D(p1, p2, p3)
        l2 = Arc2D(p3, p4, p5)
        l3 = Arc2D(p5, p6, p7)
        l4 = Arc2D(p7, p8, p1)

        l5 = Line2D(p1,p9)

        l6 = Arc2D(p9, p10, p11)
        l7 = Arc2D(p11, p12, p13)
        l8 = Arc2D(p13, p14, p15)
        l9 = Arc2D(p15, p16, p9)
        l10 = Line2D(p9,p1)

        self.curve = PolyCurve2D().byJoinedCurves([l1, l2, l3, l4, l5, l6, l7, l8, l9, l10])

        def __str__(self):
            return "Profile(" + f"{self.name})"


class LAngle:
    def __init__(self, name, h, b, tw, tf, r1, r2, ex, ey):
        self.Description = "LAngle"
        self.ID = "L"

        # parameters
        self.name = name
        self.curve = []
        self.b = b  # width
        self.h = h  # height
        self.tw = tw  # wall nominal thickness
        self.tf = tw
        self.r1 = r1  # inner fillet
        self.r11 = r1 / sqrt2
        self.r2 = r2  # outer fillet
        self.r21 = r2 / sqrt2
        self.ex = ex  # from left
        self.ey = ey  # from bottom

        # describe points
        p1 = Point2D(-ex, -ey)  # left bottom
        p2 = Point2D(b - ex, -ey)  # right bottom
        p3 = Point2D(b - ex, -ey + tf - r2)  # start arc
        p4 = Point2D(b - ex - r2 + self.r21, -ey + tf - r2 + self.r21)  # second point arc
        p5 = Point2D(b - ex - r2, -ey + tf)  # end arc
        p6 = Point2D(-ex + tf + r1, -ey + tf)  # start arc
        p7 = Point2D(-ex + tf + r1 - self.r11, -ey + tf + r1 - self.r11)  # second point arc
        p8 = Point2D(-ex + tf, -ey + tf + r1)  # end arc
        p9 = Point2D(-ex + tf, h - ey - r2)  # start arc
        p10 = Point2D(-ex + tf - r2 + self.r21, h - ey - r2 + self.r21)  # second point arc
        p11 = Point2D(-ex + tf - r2, h - ey)  # end arc
        p12 = Point2D(-ex, h - ey)  # left top

        # describe curves
        l1 = Line2D(p1, p2)
        l2 = Line2D(p2, p3)
        l3 = Arc2D(p3, p4, p5)
        l4 = Line2D(p5, p6)
        l5 = Arc2D(p6, p7, p8)
        l6 = Line2D(p8, p9)
        l7 = Arc2D(p9, p10, p11)
        l8 = Line2D(p11, p12)
        l9 = Line2D(p12, p1)

        self.curve = PolyCurve2D().byJoinedCurves([l1, l2, l3, l4, l5, l6, l7, l8, l9])

        def __str__(self):
            return "Profile(" + f"{self.name})"

class TProfile:
    #ToDo: inner outer fillets in polycurve
    def __init__(self, name, h, b, tw, tf, r, r1, r2, ex, ey):
        self.Description = "TProfile"
        self.ID = "T"

        # parameters
        self.name = name
        self.curve = []
        self.b = b  # width
        self.h = h  # height
        self.tw = tw  # wall nominal thickness
        self.tf = tw
        self.r = r  # inner fillet
        self.r01 = r/sqrt2
        self.r1 = r1  # outer fillet flange
        self.r11 = r1 / sqrt2
        self.r2 = r2  # outer fillet top web
        self.r21 = r2 / sqrt2
        self.ex = ex  # from left
        self.ey = ey  # from bottom

        # describe points
        p1 = Point2D(-ex, -ey)  # left bottom
        p2 = Point2D(b - ex, -ey)  # right bottom
        p3 = Point2D(b - ex, -ey + tf - r1)  # start arc
        p4 = Point2D(b - ex - r1 + self.r11, -ey + tf - r1 + self.r11)  # second point arc
        p5 = Point2D(b - ex - r1, -ey + tf)  # end arc
        p6 = Point2D(0.5 * tw + r, -ey + tf)  # start arc
        p7 = Point2D(0.5 * tw + r - self.r01, -ey + tf + r - self.r01)  # second point arc
        p8 = Point2D(0.5 * tw, -ey + tf + r)  # end arc
        p9 = Point2D(0.5 * tw, -ey + h - r2)  # start arc
        p10 = Point2D(0.5 * tw - self.r21, -ey + h - r2 + self.r21) # second point arc
        p11 = Point2D(0.5 * tw - r2, -ey + h)  # end arc

        p12 = Point2D(-p11.x,p11.y)
        p13 = Point2D(-p10.x, p10.y)
        p14 = Point2D(-p9.x, p9.y)
        p15 = Point2D(-p8.x, p8.y)
        p16 = Point2D(-p7.x, p7.y)
        p17 = Point2D(-p6.x, p6.y)
        p18 = Point2D(-p5.x, p5.y)
        p19 = Point2D(-p4.x, p4.y)
        p20 = Point2D(-p3.x, p3.y)

        # describe curves
        l1 = Line2D(p1, p2)

        l2 = Line2D(p2, p3)
        l3 = Arc2D(p3, p4, p5)
        l4 = Line2D(p5, p6)
        l5 = Arc2D(p6, p7, p8)
        l6 = Line2D(p8, p9)
        l7 = Arc2D(p9, p10, p11)
        l8 = Line2D(p11, p12)

        l9 = Arc2D(p12, p13, p14)
        l10 = Line2D(p14, p15)
        l11 = Arc2D(p15, p16, p17)
        l12 = Line2D(p17, p18)
        l13 = Arc2D(p18, p19, p20)
        l14 = Line2D(p20, p1)

        self.curve = PolyCurve2D().byJoinedCurves([l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14])

        def __str__(self):
            return "Profile(" + f"{self.name})"


class RectangleHollowSection:
    def __init__(self, name, h, b, t, r1, r2):
        self.Description = "Rectangle Hollow Section"
        self.ID = "RHS"

        # parameters
        self.name = name
        self.curve = []
        self.h = h  # height
        self.b = b  # width
        self.t = t # thickness
        self.r1 = r1 # outer radius
        self.r2 = r2 # inner radius
        dr = r1 - r1 / sqrt2
        dri = r2 - r2 / sqrt2
        bi = b-t
        hi = h-t

        # describe points
        p1 = Point2D(-b / 2 + r1, - h / 2)  #left bottom end arc
        p2 = Point2D(b / 2 - r1, - h / 2)  #right bottom start arc
        p3 = Point2D(b / 2 - dr, - h / 2 + dr) #right bottom mid arc
        p4 = Point2D(b / 2, - h / 2 + r1) #right bottom end arc
        p5 = Point2D(p4.x, -p4.y) #right start arc
        p6 = Point2D(p3.x, -p3.y) #right mid arc
        p7 = Point2D(p2.x, -p2.y) #right end arc
        p8 = Point2D(-p7.x, p7.y) #left start arc
        p9 = Point2D(-p6.x, p6.y)  #left mid arc
        p10 = Point2D(-p5.x, p5.y)  #left end arc
        p11 = Point2D(p10.x, -p10.y) #right bottom start arc
        p12 = Point2D(p9.x, -p9.y) #right bottom mid arc

        #inner part
        p13 = Point2D(-bi / 2 + r2, - hi / 2)  #left bottom end arc
        p14 = Point2D(bi / 2 - r2, - hi / 2)  #right bottom start arc
        p15 = Point2D(bi / 2 - dri, - hi / 2 + dri) #right bottom mid arc
        p16 = Point2D(bi / 2, - hi / 2 + r2) #right bottom end arc
        p17 = Point2D(p16.x, -p16.y) #right start arc
        p18 = Point2D(p15.x, -p15.y) #right mid arc
        p19 = Point2D(p14.x, -p14.y) #right end arc
        p20 = Point2D(-p19.x, p19.y) #left start arc
        p21 = Point2D(-p18.x, p18.y)  #left mid arc
        p22 = Point2D(-p17.x, p17.y)  #left end arc
        p23 = Point2D(p22.x, -p22.y) #right bottom start arc
        p24 = Point2D(p21.x, -p21.y) #right bottom mid arc

        # describe outer curves
        l1 = Line2D(p1, p2)
        l2 = Arc2D(p2,p3,p4)
        l3 = Line2D(p4,p5)
        l4 = Arc2D(p5,p6,p7)
        l5 = Line2D(p7,p8)
        l6 = Arc2D(p8, p9, p10)
        l7 = Line2D(p10, p11)
        l8 = Arc2D(p11, p12, p1)

        l9 = Line2D(p1,p13)
        # describe inner curves
        l10 = Line2D(p13, p14)
        l11 = Arc2D(p14,p15,p16)
        l12 = Line2D(p16,p17)
        l13 = Arc2D(p17,p18,p19)
        l14 = Line2D(p19,p20)
        l15 = Arc2D(p20, p21, p22)
        l16 = Line2D(p22, p23)
        l17 = Arc2D(p23, p24, p13)

        l18 = Line2D(p13,p1)

        self.curve = PolyCurve2D().byJoinedCurves([l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18])

        def __str__(self):
            return "Profile(" + f"{self.name})"

class CProfile:
    def __init__(self, name, b, h, t, r1, ex):
        self.Description = "Cold Formed C Profile"
        self.ID = "CP"

        # parameters
        self.name = name
        self.curve = []
        self.h = h  # height
        self.b = b  # width
        self.t = t # flange thickness
        self.r1 = r1 # outer radius
        self.r2 = r1-t # inner radius
        r2 = r1-t

        self.ex = ex
        self.ey = h/2
        dr = r1 - r1/sqrt2
        dri = r2 - r2/sqrt2
        hi = h-t

        # describe points
        p1 = Point2D(b-ex , -h/2) # right bottom
        p2 = Point2D(r1-ex,-h/2)
        p3 = Point2D(dr-ex,-h/2+dr)
        p4 = Point2D(0-ex,-h/2+r1)
        p5 = Point2D(p4.x,-p4.y)
        p6 = Point2D(p3.x,-p3.y)
        p7 = Point2D(p2.x, -p2.y)
        p8 = Point2D(p1.x, -p1.y) # right top
        p9 = Point2D(b-ex,hi/2) #right top inner
        p10 = Point2D(t+r2-ex,hi/2)
        p11 = Point2D(t+dri-ex,hi/2-dri)
        p12 = Point2D(t-ex,hi/2-r2)
        p13 = Point2D(p12.x,-p12.y)
        p14 = Point2D(p11.x,-p11.y)
        p15 = Point2D(p10.x, -p10.y)
        p16 = Point2D(p9.x, -p9.y) # right bottom inner
        # describe outer curves
        l1 = Line2D(p1, p2) # bottom
        l2 = Arc2D(p2,p3,p4) #right outer fillet
        l3 = Line2D(p4,p5) #left outer web
        l4 = Arc2D(p5,p6,p7) #left top outer fillet
        l5 = Line2D(p7,p8) # outer top
        l6 = Line2D(p8,p9) #
        l7 = Line2D(p9,p10)
        l8 = Arc2D(p10,p11,p12) #left top inner fillet
        l9 = Line2D(p12,p13)
        l10 = Arc2D(p13,p14,p15) #left botom inner fillet
        l11 = Line2D(p15,p16)
        l12 = Line2D(p16,p1)

        self.curve = PolyCurve2D().byJoinedCurves([l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12])

        def __str__(self):
            return "Profile(" + f"{self.name})"

class CProfileWithLips:
    def __init__(self, name, b, h, h1, t, r1, ex):
        self.Description = "Cold Formed C Profile with Lips"
        self.ID = "CPWL"

        # parameters
        self.name = name
        self.curve = []
        self.h = h  # height
        self.b = b  # width
        self.h1 = h1 # lip length
        self.t = t # flange thickness
        self.r1 = r1 # outer radius
        self.r2 = r1-t # inner radius
        r2 = r1-t

        self.ex = ex
        self.ey = h/2
        dr = r1 - r1/sqrt2
        dri = r2 - r2/sqrt2
        hi = h-t

        # describe points
        p1 = Point2D(b-ex-r1 , -h/2) # right bottom  before fillet
        p2 = Point2D(r1-ex,-h/2)
        p3 = Point2D(dr-ex,-h/2+dr)
        p4 = Point2D(0-ex,-h/2+r1)
        p5 = Point2D(p4.x,-p4.y)
        p6 = Point2D(p3.x,-p3.y)
        p7 = Point2D(p2.x, -p2.y)
        p8 = Point2D(p1.x, -p1.y) # right top before fillet
        p9 = Point2D(b-ex-dr,h/2-dr) # middle point arc
        p10 = Point2D(b-ex,h/2-r1) #end fillet
        p11 = Point2D(b-ex,h/2-h1)
        p12 = Point2D(b-ex-t,h/2-h1) #bottom lip
        p13 = Point2D(b-ex-t,h/2-t-r2) # start inner fillet right top
        p14 = Point2D(b-ex-t-dri,h/2-t-dri)
        p15 = Point2D(b-ex-t-r2,h/2-t) #end inner fillet right top
        p16 = Point2D(0-ex+t+r2, h/2-t)
        p17 = Point2D(0-ex+t+dri,h/2-t-dri)
        p18 = Point2D(0-ex+t, h/2-t-r2)

        p19 = Point2D(p18.x,-p18.y)
        p20 = Point2D(p17.x,-p17.y)
        p21 = Point2D(p16.x,-p16.y)
        p22 = Point2D(p15.x,-p15.y)
        p23 = Point2D(p14.x,-p14.y)
        p24 = Point2D(p13.x,-p13.y)
        p25 = Point2D(p12.x,-p12.y)
        p26 = Point2D(p11.x,-p11.y)
        p27 = Point2D(p10.x,-p10.y)
        p28 = Point2D(p9.x,-p9.y)


        # describe outer curves
        l1 = Line2D(p1,p2)
        l2 = Arc2D(p2,p3,p4)
        l3 = Line2D(p4,p5)
        l4 = Arc2D(p5,p6,p7) # outer fillet right top
        l5 = Line2D(p7,p8)
        l6 = Arc2D(p8,p9,p10)
        l7 = Line2D(p10,p11)
        l8 = Line2D(p11,p12)
        l9 = Line2D(p12,p13)
        l10 = Arc2D(p13,p14,p15)
        l11 = Line2D(p15,p16)
        l12 = Arc2D(p16,p17,p18)
        l13 = Line2D(p18,p19) #inner web
        l14 = Arc2D(p19,p20,p21)
        l15 = Line2D(p21,p22)
        l16 = Arc2D(p22,p23,p24)
        l17 = Line2D(p24,p25)
        l18 = Line2D(p25,p26)
        l19 = Line2D(p26,p27)
        l20 = Arc2D(p27,p28,p1)

        self.curve = PolyCurve2D().byJoinedCurves([l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20])

        def __str__(self):
            return "Profile(" + f"{self.name})"

class LProfileColdFormed:
    def __init__(self, name, b, h, t, r1, ex, ey):
        self.Description = "Cold Formed L Profile"
        self.ID = "CF_L"

        # parameters
        self.name = name
        self.curve = []
        self.h = h  # height
        self.b = b  # width
        self.t = t # flange thickness
        self.r1 = r1 # inner radius
        self.r2 = r1-t # outer radius
        self.ex = ex
        self.ey = ey
        r11 = r1/math.sqrt(2)
        r2 = r1+t
        r21 = r2/math.sqrt(2)

        # describe points
        p1 = Point2D(-ex, -ey + r2)  # start arc left bottom
        p2 = Point2D(-ex + r2 - r21, -ey + r2 - r21)  # second point arc
        p3 = Point2D(-ex + r2, -ey)  # end arc
        p4 = Point2D(b - ex, -ey)  # right bottom
        p5 = Point2D(b - ex, -ey + t)
        p6 = Point2D(-ex + t + r1, -ey + t)  # start arc
        p7 = Point2D(-ex + t + r1 - r11, -ey + t + r1 - r11)  # second point arc
        p8 = Point2D(-ex + t, -ey + t + r1)  # end arc
        p9 = Point2D(-ex + t, ey)
        p10 = Point2D(-ex, ey)  # left top

        l1 = Arc2D(p1,p2,p3)
        l2 = Line2D(p3,p4)
        l3 = Line2D(p4,p5)
        l4 = Line2D(p5,p6)
        l5 = Arc2D(p6,p7,p8)
        l6 = Line2D(p8,p9)
        l7 = Line2D(p9,p10)
        l8 = Line2D(p10,p1)

        self.curve = PolyCurve2D().byJoinedCurves([l1, l2, l3, l4, l5, l6, l7, l8])

        def __str__(self):
            return "Profile(" + f"{self.name})"

class SigmaProfileWithLipsColdFormed:
    def __init__(self, name, b, h, t, r1, h1, h2, h3, b2, ex):
        self.Description = "Cold Formed Sigma Profile with Lips"
        self.ID = "CF_SWL"

        # parameters
        self.name = name
        self.curve = []
        self.h = h  # height
        self.h1 = h1  # LipLength
        self.h2 = h2  # MiddleBendLength
        self.h3 = h3  # TopBendLength
        self.h4 = h4 = (h - h2 - h3 * 2) / 2
        self.h5 = h5 = math.tan(0.5 * math.atan(b2 / h4)) * t
        self.b = b  # width
        self.b2 = b2 # MiddleBendWidth
        self.t = t # flange thickness
        self.r1 = r1 # inner radius
        self.r2 = r2 = r1+t # outer radius
        self.ex = ex
        self.ey = ey = h/2
        self.r11 = r11 = r1/math.sqrt(2)
        self.r21 = r21 = r2/math.sqrt(2)

        p1 = Point2D(-ex + b2, -h2 / 2)
        p2 = Point2D(-ex, -ey + h3)
        p3 = Point2D(-ex, -ey + r2)  # start arc left bottom
        p4 = Point2D(-ex + r2 - r21, -ey + r2 - r21)  # second point arc
        p5 = Point2D(-ex + r2, -ey)  # end arc
        p6 = Point2D(b - ex - r2, -ey)  # start arc
        p7 = Point2D(b - ex - r2 + r21, -ey + r2 - r21)  # second point arc
        p8 = Point2D(b - ex, -ey + r2)  # end arc
        p9 = Point2D(b - ex, -ey + h1)  # end lip
        p10 = Point2D(b - ex - t, -ey + h1)
        p11 = Point2D(b - ex - t, -ey + t + r1)  # start arc
        p12 = Point2D(b - ex - t - r1 + r11, -ey + t + r1 - r11)  # second point arc
        p13 = Point2D(b - ex - t - r1, -ey + t)  # end arc
        p14 = Point2D(-ex + t + r1, -ey + t)  # start arc
        p15 = Point2D(-ex + t + r1 - r11, -ey + t + r1 - r11)  # second point arc
        p16 = Point2D(-ex + t, -ey + t + r1)  # end arc
        p17 = Point2D(-ex + t, -ey + h3 - h5)
        p18 = Point2D(-ex + b2 + t, -h2 / 2 - h5)
        p19 = Point2D(p18.x, -p18.y)
        p20 = Point2D(p17.x, -p17.y)
        p21 = Point2D(p16.x, -p16.y)
        p22 = Point2D(p15.x, -p15.y)
        p23 = Point2D(p14.x, -p14.y)
        p24 = Point2D(p13.x, -p13.y)
        p25 = Point2D(p12.x, -p12.y)
        p26 = Point2D(p11.x, -p11.y)
        p27 = Point2D(p10.x, -p10.y)
        p28 = Point2D(p9.x, -p9.y)
        p29 = Point2D(p8.x, -p8.y)
        p30 = Point2D(p7.x, -p7.y)
        p31 = Point2D(p6.x, -p6.y)
        p32 = Point2D(p5.x, -p5.y)
        p33 = Point2D(p4.x, -p4.y)
        p34 = Point2D(p3.x, -p3.y)
        p35 = Point2D(p2.x, -p2.y)
        p36 = Point2D(p1.x, -p1.y)

        l1 = Line2D(p1,p2)
        l2 = Line2D(p2,p3)
        l3 = Arc2D(p3,p4,p5)
        l4 = Line2D(p5,p6)
        l5 = Arc2D(p6,p7,p8)
        l6 = Line2D(p8,p9)
        l7 = Line2D(p9,p10)
        l8 = Line2D(p10,p11)
        l9 = Arc2D(p11,p12,p13)
        l10 = Line2D(p13,p14)
        l11 = Arc2D(p14,p15,p16)
        l12 = Line2D(p16,p17)
        l13 = Line2D(p17,p18)
        l14 = Line2D(p18,p19)
        l15 = Line2D(p19,p20)
        l16 = Line2D(p20,p21)
        l17 = Arc2D(p21,p22,p23)
        l18 = Line2D(p23,p24)
        l19 = Arc2D(p24,p25,p26)
        l20 = Line2D(p26,p27)
        l21 = Line2D(p27,p28)
        l22 = Line2D(p28,p29)
        l23 = Arc2D(p29,p30,p31)
        l24 = Line2D(p31,p32)
        l25 = Arc2D(p32,p33,p34)
        l26 = Line2D(p34,p35)
        l27 = Line2D(p35,p36)
        l28 = Line2D(p36,p1)

        self.curve = PolyCurve2D().byJoinedCurves([l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22, l23,
             l24, l25,
             l26, l27, l28])

        def __str__(self):
            return "Profile(" + f"{self.name})"


class ZProfileColdFormed:
    def __init__(self, name, b, h, t, r1):
        self.Description = "Cold Formed Z Profile"
        self.ID = "CF_Z"

        # parameters
        self.name = name
        self.curve = []
        self.b = b  # width
        self.h = h  # height
        self.t = t # flange thickness
        self.r1 = r1 # inner radius
        self.r2 = r2 = r1+t # outer radius
        self.ex = ex = b/2
        self.ey = ey = h/2
        self.r11 = r11 = r1 / math.sqrt(2)
        self.r21 = r21 = r2 / math.sqrt(2)

        p1 = Point2D(-0.5 * t, -ey + t + r1)  # start arc
        p2 = Point2D(-0.5 * t - r1 + r11, -ey + t + r1 - r11)  # second point arc
        p3 = Point2D(-0.5 * t - r1, -ey + t)  # end arc
        p4 = Point2D(-ex, -ey + t)
        p5 = Point2D(-ex, -ey)  # left bottom
        p6 = Point2D(-r2 + 0.5 * t, -ey)  # start arc
        p7 = Point2D(-r2 + 0.5 * t + r21, -ey + r2 - r21)  # second point arc
        p8 = Point2D(0.5 * t, -ey + r2)  # end arc
        p9 = Point2D(-p1.x, -p1.y)
        p10 = Point2D(-p2.x, -p2.y)
        p11 = Point2D(-p3.x, -p3.y)
        p12 = Point2D(-p4.x, -p4.y)
        p13 = Point2D(-p5.x, -p5.y)
        p14 = Point2D(-p6.x, -p6.y)
        p15 = Point2D(-p7.x, -p7.y)
        p16 = Point2D(-p8.x, -p8.y)

        l1 = Arc2D(p1,p2,p3)
        l2 = Line2D(p3,p4)
        l3 = Line2D(p4,p5)
        l4 = Line2D(p5,p6)
        l5 = Arc2D(p6,p7,p8)
        l6 = Line2D(p8,p9)
        l7 = Arc2D(p9,p10,p11)
        l8 = Line2D(p11,p12)
        l9 = Line2D(p12,p13)
        l10 = Line2D(p13,p14)
        l11 = Arc2D(p14,p15,p16)
        l12 = Line2D(p16,p1)

        self.curve = PolyCurve2D().byJoinedCurves([l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12])

        def __str__(self):
            return "Profile(" + f"{self.name})"

class ZProfileWithLipsColdFormed:
    def __init__(self, name, b, h, t, r1, h1):
        self.Description = "Cold Formed Z Profile with Lips"
        self.ID = "CF_ZL"

        # parameters
        self.name = name
        self.curve = []
        self.b = b  # width
        self.h = h  # height
        self.t = t # flange thickness
        self.h1 = h1 # lip length
        self.r1 = r1 # inner radius
        self.r2 = r2 = r1+t # outer radius
        self.ex = ex = b/2
        self.ey = ey = h/2
        self.r11 = r11 = r1 / math.sqrt(2)
        self.r21 = r21 = r2 / math.sqrt(2)

        p1 = Point2D(-0.5*t,-ey+t+r1) #start arc
        p2 = Point2D(-0.5*t-r1+r11,-ey+t+r1-r11) #second point arc
        p3 = Point2D(-0.5*t-r1,-ey+t) #end arc
        p4 = Point2D(-ex+t+r1,-ey+t) #start arc
        p5 = Point2D(-ex+t+r1-r11,-ey+t+r1-r11) #second point arc
        p6 = Point2D(-ex+t,-ey+t+r1) #end arc
        p7 = Point2D(-ex+t,-ey+h1)
        p8 = Point2D(-ex,-ey+h1)
        p9 = Point2D(-ex,-ey+r2) #start arc
        p10 = Point2D(-ex+r2-r21,-ey+r2-r21) #second point arc
        p11 = Point2D(-ex+r2,-ey) #end arc
        p12 = Point2D(-r2+0.5*t,-ey) #start arc
        p13 = Point2D(-r2+0.5*t+r21,-ey+r2-r21) #second point arc
        p14 = Point2D(0.5*t,-ey+r2) #end arc
        p15 = Point2D(-p1.x,-p1.y)
        p16 = Point2D(-p2.x,-p2.y)
        p17 = Point2D(-p3.x,-p3.y)
        p18 = Point2D(-p4.x,-p4.y)
        p19 = Point2D(-p5.x,-p5.y)
        p20 = Point2D(-p6.x,-p6.y)
        p21 = Point2D(-p7.x,-p7.y)
        p22 = Point2D(-p8.x,-p8.y)
        p23 = Point2D(-p9.x,-p9.y)
        p24 = Point2D(-p10.x,-p10.y)
        p25 = Point2D(-p11.x,-p11.y)
        p26 = Point2D(-p12.x,-p12.y)
        p27 = Point2D(-p13.x,-p13.y)
        p28 = Point2D(-p14.x,-p14.y)

        l1 = Arc2D(p1,p2,p3)
        l2 = Line2D(p3,p4)
        l3 = Arc2D(p4,p5,p6)
        l4 = Line2D(p6,p7)
        l5 = Line2D(p7,p8)
        l6 = Line2D(p8,p9)
        l7 = Arc2D(p9,p10,p11)
        l8 = Line2D(p11,p12)
        l9 = Arc2D(p12,p13,p14)
        l10 = Line2D(p14,p15)
        l11 = Arc2D(p15,p16,p17)
        l12 = Line2D(p17,p18)
        l13 = Arc2D(p18,p19,p20)
        l14 = Line2D(p20,p21)
        l15 = Line2D(p21,p22)
        l16 = Line2D(p22,p23)
        l17 = Arc2D(p23,p24,p25)
        l18 = Line2D(p25,p26)
        l19 = Arc2D(p26,p27,p28)
        l20 = Line2D(p28,p1)

        self.curve = PolyCurve2D().byJoinedCurves([l1,l2,l3,l4,l5,l6,l7,l8,l9,l10,l11,l12,l13,l14,l15,l16,l17,l18,l19,l20])

        def __str__(self):
            return "Profile(" + f"{self.name})"



class ReadDXF():
    #append line only if unique start.value and end.value
    #sort them based on end.value has to be start.value
    def __init__(self, filename):
        self.points = []
        self.lines = []
        self.filename = filename
        self.get_line_coordinates()
        self.polycurve = self.create_polycurve()
        self.isClosed = project.closed


    def convert_coordinates(self, start_point, end_point, reference_point):
        
        # relative_start = start_point - reference_point
        # print(start_point, end_point, reference_point)
        relative_start = start_point[0] - reference_point[0], start_point[1] - reference_point[1], start_point[2] - reference_point[2]
        # print(relative_start)
        # print(end_point, reference_point)
        relative_end = end_point[0] - reference_point[0], end_point[1] - reference_point[1], end_point[2] - reference_point[2]
        # relative_end = end_point - reference_point
        # print(relative_end)
        relative_start = round(relative_start[0], project.decimals), round(relative_start[1], project.decimals), round(relative_start[2], project.decimals)
        relative_end = round(relative_end[0], project.decimals), round(relative_end[1], project.decimals), round(relative_end[2], project.decimals)
        return relative_start, relative_end


    def get_line_coordinates(self):
        doc = ezdxf.readfile(self.filename)
        modelspace = doc.modelspace()
        reference_point = None
        for entity in modelspace:
            if entity.dxftype() == 'LINE':
                start_point = entity.dxf.start
                end_point = entity.dxf.end
                if reference_point is None:
                    reference_point = start_point
                relative_start, relative_end = self.convert_coordinates(start_point, end_point, reference_point)
                p1 = Point(x=relative_start[0], y=relative_start[1], z=relative_start[2])
                p2 = Point(x=relative_end[0], y=relative_end[1], z=relative_end[2]) 
                line = Line(start=p1, end=p2)
                self.points.append(p1)
                self.lines.append(line)


            elif entity.dxftype() == 'LWPOLYLINE':
                splittedpoints = []
                splittedlines = []
                with entity.points() as points:
                    endpoint = None
                    for point in points:
                        if reference_point is None:
                            reference_point = point
                        if endpoint is None:
                            endpoint = point
                        point = point[0], point[1], point[2]
                        endpoint = endpoint[0], endpoint[1], endpoint[2]
                        reference_point = reference_point[0], reference_point[1], reference_point[2]
                        relative_start, relative_end = self.convert_coordinates(point, endpoint, reference_point)
                        p1 = Point(x=relative_start[0], y=relative_start[1], z=relative_start[2])
                        p2 = Point(x=relative_end[0], y=relative_end[1], z=relative_end[2]) 
                        line = Line(start=p1, end=p2)
                        splittedpoints.append(p1)
                        splittedlines.append(line)
                    self.points.append(splittedpoints)
                    self.lines.append(splittedlines)
        # print(self.lines)
        return self.lines

    
    def create_polycurve(self):
        if len(self.points) == 1:
            return PolyCurve.byPoints(self.points)
        elif len(self.points) > 1:
            plList = []
            for pl in self.points:
                plList.append(PolyCurve.byPoints(pl))
            return plList


#TODO Line to Grid Object
#TODO Grid Object with building.py line --> convert to Speckle Line with pattern

def rgb_to_int(rgb):
    r, g, b = [max(0, min(255, c)) for c in rgb]

    return (255 << 24) | (r << 16) | (g << 8) | b

def getXYZ(XMLtree, nodenumber):
    root = XMLtree.getroot()
    # POINTS
    n = root.findall(".//Nodes/Number")
    nodenumbers = []

    for i in n:
        nodenumbers.append(i.text)
    #Search
    rest = nodenumbers.index(nodenumber)
    return(rest)

def XMLImportNodes(XMLtree):
    root = XMLtree.getroot()
    # POINTS
    n = root.findall(".//Nodes/Number")
    nodenumbers = []

    for i in n:
        nodenumbers.append(i.text)
    X = root.findall(".//Nodes/X")
    Y = root.findall(".//Nodes/Y")
    Z = root.findall(".//Nodes/Z")

    XYZ = []
    # Put points in 3D
    for h, i, j, k in zip(n, X, Y, Z):
        Pnt = Point(float(i.text.replace(",", ".")), float(j.text.replace(",", ".")), float(k.text.replace(",", ".")))
        # Pnt.id = int(h.text)
        XYZ.append(Pnt)
    return nodenumbers,XYZ

def XMLImportgetGridDistances(Grids):
    #Function to create grids from the format 0, 4x5400, 4000, 4000 to absolute XYZ-values
    GridsNew = []
    distance = 0.0
    #GridsNew.append(distance)
    for i in Grids:
        #del Grids[0]
        if "x" in i:
            spl = i.split("x")
            count = int(spl[0])
            width = float(spl[1])
            for i in range(count):
                distance = distance + width
                GridsNew.append(distance)
        else:
            distance = distance + float(i)
            GridsNew.append(distance)
    return GridsNew

def XMLImportGrids(XMLtree, gridExtension):
    #create building.py Grids from the grids of XFEM4U
    root = XMLtree.getroot()
    gridlines = []

    #GRIDS
    GridEx = gridExtension

    GridsX = root.findall(".//Grids/X")[0].text.split()
    GridsX = XMLImportgetGridDistances(GridsX)
    Xmax = max(GridsX)
    GridsXLable = root.findall(".//Grids/X_Lable")[0].text.split()
    GridsY = root.findall(".//Grids/Y")[0].text.split()
    GridsY = XMLImportgetGridDistances(GridsY)
    Ymax = max(GridsY)
    GridsYLable = root.findall(".//Grids/Y_Lable")[0].text.split()
    GridsZ = root.findall(".//Grids/Z")[0].text.split()
    GridsZ = XMLImportgetGridDistances(GridsZ)
    GridsZLable = root.findall(".//Grids/Z_Lable")[0].text.split()
    Zmax = max(GridsZ)

    grids = []
    for i in GridsX:
        grids.append(Line(start=Point(i, -GridEx, 0),end=Point(i, Ymax+GridEx, 0)))

    for i in GridsY:
        grids.append(Line(start=Point(-GridEx, i, 0),end=Point(Xmax+GridEx, i, 0)))

    for i in GridsZ:
        grids.append(Line(start=Point(0, 0, i) , end=Point(0, Xmax, i)))

    obj = []
    for i in grids:
        obj.append(Grid.byStartpointEndpoint(i,"Grid"))
     #   gridlines.append(line)
    return obj

#def findMaterial(material):


def XMLImportPlates(XMLtree):
    #Get platedata from XML
    root = XMLtree.getroot()
    #PLATES

    platesNumbersElem = root.findall(".//Plates/Number")
    PlatesNodesElem = root.findall(".//Plates/Node")
    platesMaterialElem = root.findall(".//Plates/Material")
    platesZElem = root.findall(".//Plates/Z")
    platesThicknessElem = root.findall(".//Plates/h")
    platesTop_Center_BottomElem = root.findall(".//Plates/Top_Center_Bottom")

    platesNumbers = []
    for i in platesNumbersElem: platesNumbers.append(i.text)
    PlatesNodes = []
    for i in PlatesNodesElem: PlatesNodes.append(i.text)
    platesMaterialQuality = []
    for i in platesMaterialElem:
        platesMaterialQuality.append(i.text)
    platesMaterial = []
    lstConcrete = ["C20/25","C25/30","C30/37","C35/45","C40/50","C45/55","C50/60","C53/65"]
    lstTimber = ["C14","C16","C18","C20","C22","C24","C27","C30","C35","C40","C50","D18","D24","D30","D35","D40","D50","D60","D70"]
    lstSteel = ["S235,S275,S355"]
    lstColor = []
    for i in platesMaterialQuality:
        if i in lstConcrete:
            platesMaterial.append("Concrete")
            lstColor.append(rgb_to_int([192,192,192]))
        elif i in lstTimber:
            platesMaterial.append("Timber")
            lstColor.append(rgb_to_int([191,159,116]))
        elif i in lstSteel:
            platesMaterial.append("Steel")
            lstColor.append(rgb_to_int([237,28,36]))
        else:
            platesMaterial.append("Other")
            lstColor.append(rgb_to_int([150, 150, 150]))
    platesZ = []
    for i in platesZElem: platesZ.append(float(i.text))
    platesThickness = []
    for i in platesThicknessElem: platesThickness.append(float(i.text))
    platesTop_Center_Bottom = []
    for i in platesTop_Center_BottomElem: platesTop_Center_Bottom.append(i.text)


    # for loop to get each element in an array
    plateOffsets = []
    #Plate ligt standaard in de hartlijn. In het onderstaande is dit aangepast.
    for i,j,k in zip(platesZ, platesThickness, platesTop_Center_Bottom):
        if k == "Top":
            offset = -0.5 * j
        elif k == "Center":
            offset = 0
        elif k == "Bottom":
            offset = 0.5 * j
        else: offset = 0
        offset = offset + j
        plateOffsets.append(offset)

    rootPlates = root.findall(".//Plates")

    #XMLImportPlates(root):
    PlatesTags = []
    PlatesValues = []
    for elements in root:
        if elements.tag == "Plates":
            for element in elements:
                PlatesTags.append(element.tag)
                PlatesValues.append(element.text)

    #Iedere plate met nodes in een sublijst stoppen
        #plate
            #nodes

    ind = [i for i, x in enumerate(PlatesTags) if x == "Number"] # indices where a new plate starts.

    platesIndices = []
    platesValues = []
    platesNodes = []
    count = 0
    for x in ind:
        count = count + 1
        try:
            platesIndices.append(PlatesTags[x:ind[count]])
            platesValues.append(PlatesValues[x:ind[count]])
            platesNodes.append(PlatesValues[x+1:ind[count]-5])
        except:
            platesIndices.append(PlatesTags[x::]) # voor de laatste item uit de lijst, anders out of range
            platesValues.append(PlatesValues[x::]) # voor de laatste item uit de lijst, anders out of range
            platesNodes.append(PlatesValues[x+1:-5])

    obj = []
    XYZ = XMLImportNodes(XMLtree)[1] #Knopen

    platesPolyCurves = []
    for i in platesNodes:
        PlatePoints = []
        for j in i:
            Point = XYZ[getXYZ(XMLtree,j)]
            PlatePoints.append(Point)
        PlatePoints.append(PlatePoints[0])
        ply = PolyCurve.byPoints(PlatePoints)
        #obj.append(ply)
        platesPolyCurves.append(ply)

    # Panels maken Building.py
    Panels = []

    for i, j, k, l, m, n in zip(platesPolyCurves, platesThickness, plateOffsets, platesMaterial, platesNumbers,lstColor):
        Panels.append(Panel.byPolyCurveThickness(i, j, k, l + m, n))

    return Panels

class xmlXFEM4U:
    def __init__(self):
        self.Frame1 = "<Frame>\n"
        self.Project = "<ProjectName>" + "Building.py" + "</ProjectName>\n"
        self.ProjectNumber = "<ProjectNumber>0</ProjectNumber>\n"
        self.ExportDate = "<ExportDateTime>2023-04-08 19:55:39Z</ExportDateTime>\n"
        self.XMLVersion = "<XMLExportVersion>v4.0.30319</XMLExportVersion>\n" #
        self.Nodes = "<Nodes></Nodes>\n"
        self.Supports = "<Supports></Supports>\n"
        self.Grids = "<Grids><X>0 5000</X><X_Lable>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z AA AB AC</X_Lable><Y>0 5000</Y><Y_Lable>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24</Y_Lable><Z>0</Z><Z_Lable>+0</Z_Lable></Grids>\n"
        self.Profiles = "<Profiles></Profiles>\n"
        self.Beamgroup = "<Beamgroup></Beamgroup>\n"
        self.Beams = "<Beams></Beams>\n"
        self.Panels = "<Panels></Panels>\n"
        self.Plates = "<Plates></Plates>\n"
        self.LoadCases = "<LoadCases></LoadCases>\n"
        self.BeamLoads = "<BeamLoads></BeamLoads>\n"
        self.NodeLoads = "<NodeLoads></NodeLoads>\n"
        self.SurfaceLoads = "<SurfaceLoads></SurfaceLoads>\n"
        self.Combinations = "<Combinations></Combinations>\n"
        self.RebarLongitudinal = "<RebarLongitudinal></RebarLongitudinal>\n"
        self.RebarStirrup = "<RebarStirrup></RebarStirrup>\n"
        self.Layers = "<Layers><Layer_number>1</Layer_number><Layer_description>Layer 1</Layer_description></Layers>\n"
        self.Frame2 = "</Frame>\n"
        self.xmlstr = None

    def addBeamsPlates(self, buildingpyobj):
        obj = buildingpyobj
        # Number of nodes:
        n = 0
        Nodes = []
        Plates = []
        Beams = []
        Beamgroup = []
        Profiles = []
        Supports= []
        Points = []
        plateN = 0  # Numbering plates
        beamsN = 0  # Numbering beams
        beamsGN = 0  # Numbering beamgroup
        profN = 0  # Numbering profiles
        supportN = 0 # Numbering of supports
        Nodes.append("<Nodes>\n")
        Plates.append("<Plates>\n")
        Beams.append("<Beams>\n")
        Beamgroup.append("<Beamgroup>\n")
        Profiles.append("<Profiles>\n")
        Supports.append("<Supports>\n")

        ProfileNames = []  # all profiles
        for i in obj:
            nm = i.__class__.__name__
            if nm == "Frame":
                ProfileNames.append([i, i.profileName])

        ProfileNamesUnique = []  # Unique profiles
        ItemsOfUniqueProfileName = []
        for item in ProfileNames:
            if item[1] not in ProfileNamesUnique:
                ProfileNamesUnique.append(item[1])
                ItemsOfUniqueProfileName.append(item[0])

        for i,j in zip(ProfileNamesUnique,ItemsOfUniqueProfileName):
            profN = profN + 1
            Profiles.append("<Number>" + str(profN) + "</Number>\n")
            if j.material.name == "Steel":
                Profiles.append("<Profile_name>" + i + "</Profile_name>\n")
                Profiles.append("<Material_type>" + "0" + "</Material_type>\n")
                Profiles.append("<Material>" + "S235" + "</Material>\n")
                Profiles.append("<Angle>" + "0" + "</Angle>\n")
            elif j.material.name == "Concrete":  #nu simpel al het andere is beton
                Profiles.append("<Profile_name>" + "Profile " + str(profN) + "</Profile_name>\n")
                Profiles.append("<Material_type>" + "1" + "</Material_type>\n")
                Profiles.append("<Material>" + "C20/25" + "</Material>\n")
                Profiles.append("<Angle>" + "0" + "</Angle>\n")
                Profiles.append("<Profile_shape>" + "1" + "</Profile_shape>\n")
                Profiles.append("<h>600</h>\n")
                Profiles.append("<b>500</b>\n")
                Profiles.append("<h1>50</h1>\n")
                Profiles.append("<b1>50</b1>\n")
                Profiles.append("<h2>50</h2>\n")
                Profiles.append("<b2>50</b2>\n")
                Profiles.append("<h3>50</h3>\n")
                Profiles.append("<b3>50</b3>\n")
                Profiles.append("<h4>50</h4>\n")
                Profiles.append("<b4>50</b4>\n")


        for i in obj:
            nm = i.__class__.__name__
            if nm == 'Panel':
                plateN = plateN + 1
                Plates.append("<Number>" + str(plateN) + "</Number>\n")
                PlatePoints = i.origincurve.points[ : -1]
                for j in PlatePoints:
                    n = n + 1
                    Nodes.append("<Number>" + str(n) + "</Number>\n")
                    Nodes.append("<X>" + str(round(j.x)) + "</X>\n")
                    Nodes.append("<Y>" + str(round(j.y)) + "</Y>\n")
                    Nodes.append("<Z>" + str(round(j.z)) + "</Z>\n")
                    Plates.append("<Node>" + str(n) + "</Node>\n")
                Plates.append("<h>" + str(i.thickness) + "</h>\n")
                Plates.append(
                    "<Material_type>" + "c4aeb39b3f8d45cf9613e8377bdf73624" + "</Material_type>\n")  # material nog uitlezen #Concrete: c9a5876f475cefab7cc11281b017914a1 # Steel: c4aeb39b3f8d45cf9613e8377bdf73624
                Plates.append("<Material>" + "S235" + "</Material>\n")  # material nog uitlezen
                Plates.append("<Z>" + "0" + "</Z>\n")
                Plates.append("<Top_Center_Bottom>" + "Center" + "</Top_Center_Bottom>\n")

            elif nm == 'Frame':
                ProfN = ProfileNamesUnique.index(i.profileName) + 1
                beamsGN = beamsGN + 1
                Beamgroup.append("<Number>" + str(beamsGN) + "</Number>\n")
                n = n + 1
                Nodes.append("<Number>" + str(n) + "</Number>\n")
                Nodes.append("<X>" + str(round(i.start.x)) + "</X>\n")
                Nodes.append("<Y>" + str(round(i.start.y)) + "</Y>\n")
                Nodes.append("<Z>" + str(round(i.start.z)) + "</Z>\n")

                Beamgroup.append("<Startnode>" + str(n) + "</Startnode>\n")

                Points.append([i.start, n])

                beamsN = beamsN + 1
                Beams.append("<Number>" + str(beamsN) + "</Number>")
                Beams.append("<Beamgroupnumber>" + str(beamsGN) + "</Beamgroupnumber>\n")
                Beams.append("<From_node_number>" + str(n) + "</From_node_number>\n")

                n = n + 1
                Nodes.append("<Number>" + str(n) + "</Number>\n")
                Nodes.append("<X>" + str(round(i.end.x)) + "</X>\n")
                Nodes.append("<Y>" + str(round(i.end.y)) + "</Y>\n")
                Nodes.append("<Z>" + str(round(i.end.z)) + "</Z>\n")

                Beamgroup.append("<Endnode>" + str(n) + "</Endnode>\n")

                Points.append([i.end, n])

                Beams.append("<To_node_number>" + str(n) + "</To_node_number>\n")
                Beams.append("<Angle>" + str(i.rotation) + "</Angle>\n")
                Beams.append("<Angle_profile>" + "0" + "</Angle_profile>\n")
                ProfNstr = str(ProfN)
                Beams.append("<Profile_number>" + ProfNstr + "</Profile_number>\n")
                Beams.append("<Z>" + str(i.ZOffset) + "</Z>\n")
                Beams.append("<Top_Center_Bottom>" + i.YJustification + "</Top_Center_Bottom>\n")
            elif nm == 'Grid':
                pass
        for i in obj:
            nm = i.__class__.__name__
            if nm == 'Support':
                supportN = supportN + 1

                bools = []
                for j in Points:
                    bools.append(Point.intersect(i.Point, j[0]))
                if sum(bools) > 0: #Means intersection with existing point/node
                    no = bools.index(1)+1
                else: #No intersection, so new node is required
                    n = n + 1
                    Nodes.append("<Number>" + str(n) + "</Number>\n")
                    Nodes.append("<X>" + str(round(i.Point.x)) + "</X>\n")
                    Nodes.append("<Y>" + str(round(i.Point.y)) + "</Y>\n")
                    Nodes.append("<Z>" + str(round(i.Point.z)) + "</Z>\n")
                    no = n
                Supports.append("<Number>" + str(supportN) + "</Number>\n")
                Supports.append("<Nodenumber>" + str(no) + "</Nodenumber>\n")
                Supports.append("<Tx>" + i.Tx + "</Tx>\n")
                Supports.append("<Ty>" + i.Ty + "</Ty>\n")
                Supports.append("<Tz>" + i.Tz + "</Tz>\n")
                Supports.append("<Rx>" + i.Rx + "</Rx>\n")
                Supports.append("<Ry>" + i.Ry + "</Ry>\n")
                Supports.append("<Rz>" + i.Rz + "</Rz>\n")
                Supports.append("<Kx>" + str(i.Kx) + "</Kx>\n")
                Supports.append("<Ky>" + str(i.Ky) + "</Ky>\n")
                Supports.append("<Kz>" + str(i.Kz) + "</Kz>\n")
                Supports.append("<Cx>" + str(i.Cx) + "</Cx>\n")
                Supports.append("<Cy>" + str(i.Cy) + "</Cy>\n")
                Supports.append("<Cz>" + str(i.Cz) + "</Cz>\n")
                Supports.append("<dx>" + str(i.dx) + "</dx>\n")
                Supports.append("<dy>" + str(i.dy) + "</dy>\n")
                Supports.append("<dz>" + str(i.dz) + "</dz>\n")

            else:
                pass


        Nodes.append("</Nodes>\n")
        Plates.append("</Plates>\n")
        Beams.append("</Beams>\n")
        Profiles.append("</Profiles>\n")
        Beamgroup.append("</Beamgroup>\n")
        Supports.append("</Supports>\n")

        self.Nodes = ''.join(str(N) for N in Nodes)
        self.Plates = ''.join(str(P) for P in Plates)
        self.Beams = ''.join(str(B) for B in Beams)
        self.Beamgroup = ''.join(str(BP) for BP in Beamgroup)
        self.Profiles = ''.join(str(Pr) for Pr in Profiles)
        self.Supports = ''.join(str(Sup) for Sup in Supports)

    def addGrids(self, spacX=None, seqX=None, spacY=None, seqY=None, z=None):
        if spacX is None:
            self.Grids = "<Grids>" + "</Grids>"
        else:
            self.Grids = "<Grids>" + "<X>" + spacX + "</X>" + "<X_Lable>" + seqX + "</X_Lable>" + "<Y>" + spacY + "</Y>" + "<Y_Lable>" + seqY + "</Y_Lable>" + "<Z>" + "0 " + str(
                z) + "</Z>" + "<Z_Lable>" + "+0 h" + "</Z_Lable>" + "</Grids>"

    def addLoadCasesCombinations(self):
        # Standard Load Cases and Combinations
        # Load Cases
        LoadCases = []
        LoadCases.append("<LoadCases>\n")
        LoadCases.append("<Number>1</Number>\n")
        LoadCases.append("<Description>Permanent</Description>\n")
        LoadCases.append("<Type>0</Type>\n")
        LoadCases.append("<psi0>1</psi0>\n")
        LoadCases.append("<psi1>1</psi1>\n")
        LoadCases.append("<psi2>1</psi2>\n")
        LoadCases.append("<Number>2</Number>\n")
        LoadCases.append("<Description>Veranderlijk</Description>\n")
        LoadCases.append("<Type>1</Type>\n")
        LoadCases.append("<psi0>0,4</psi0>\n")
        LoadCases.append("<psi1>0,5</psi1>\n")
        LoadCases.append("<psi2>0,3</psi2>\n")
        LoadCases.append("</LoadCases>\n")


        # Load Combinations
        Combinations = []
        Combinations.append("<Combinations>\n")
        Combinations.append("<LoadCombinationNumber>1</LoadCombinationNumber>\n")
        Combinations.append("<Description>Dead load</Description>\n")
        Combinations.append("<CombTyp>0</CombTyp>\n")
        Combinations.append("<Case>1</Case>\n")
        Combinations.append("<Psi>1</Psi>\n")
        Combinations.append("<Gamma>1, 35</Gamma>\n")
        Combinations.append("<Case>2</Case>\n")
        Combinations.append("<Psi>1</Psi>\n")
        Combinations.append("<Gamma>1, 5</Gamma>\n")
        Combinations.append("<LoadCombinationNumber>2</LoadCombinationNumber>\n")
        Combinations.append("<Description>Live load</Description>\n")
        Combinations.append("<CombTyp>0</CombTyp>\n")
        Combinations.append("<Case>1</Case>\n")
        Combinations.append("<Psi>1</Psi>\n")
        Combinations.append("<Gamma>1, 2</Gamma>\n")
        Combinations.append("<Case>2</Case>\n")
        Combinations.append("<Psi>1</Psi>\n")
        Combinations.append("<Gamma>1, 5</Gamma>\n")
        Combinations.append("<LoadCombinationNumber>3</LoadCombinationNumber>\n")
        Combinations.append("<Description>Dead load</Description>\n")
        Combinations.append("<CombTyp>3</CombTyp>")
        Combinations.append("<Case>1</Case>")
        Combinations.append("<Psi>1</Psi>")
        Combinations.append("<Gamma>1</Gamma>")
        Combinations.append("<Case>2</Case>")
        Combinations.append("<Psi>1</Psi>")
        Combinations.append("<Gamma>1</Gamma>")
        Combinations.append("<LoadCombinationNumber>4</LoadCombinationNumber>")
        Combinations.append("<Description>Live")
        Combinations.append("load</Description>")
        Combinations.append("<CombTyp>3</CombTyp>")
        Combinations.append("<Case>1</Case>")
        Combinations.append("<Psi>1</Psi>")
        Combinations.append("<Gamma>1</Gamma>")
        Combinations.append("<Case>2</Case>")
        Combinations.append("<Psi>1</Psi>")
        Combinations.append("<Gamma>1</Gamma>")
        Combinations.append("<LoadCombinationNumber>5</LoadCombinationNumber>")
        Combinations.append("<Description>SLS")
        Combinations.append("Permanent</Description>")
        Combinations.append("<CombTyp>4</CombTyp>")
        Combinations.append("<Case>1</Case>")
        Combinations.append("<Psi>1</Psi>")
        Combinations.append("<Gamma>1</Gamma>")
        Combinations.append("<LoadCombinationNumber>6</LoadCombinationNumber>")
        Combinations.append("<Description>SLS")
        Combinations.append("Quasi - permanent</Description>")
        Combinations.append("<CombTyp>2</CombTyp>")
        Combinations.append("<Case>1</Case>")
        Combinations.append("<Psi>1</Psi>")
        Combinations.append("<Gamma>1</Gamma>")
        Combinations.append("<Case>2</Case>")
        Combinations.append("<Psi>0, 8</Psi>")
        Combinations.append("<Gamma>1</Gamma>")
        Combinations.append("</Combinations>")
        self.LoadCases = ''.join(str(LCa) for LCa in LoadCases)
        self.Combinations = ''.join(str(LC) for LC in Combinations)

    def addSurfaceLoad(self,obj=None):
        SurfaceLoads = []
        SurfaceLoads.append("<SurfaceLoads>\n")
        if obj != None:
            slN = 0
            for i in obj:
                nm = i.__class__.__name__
                if nm == "SurfaceLoad":
                    slN = slN + 1
                    SurfaceLoads.append("<Number>" + str(slN) + "</Number>\n")
                    SurfaceLoads.append("<LoadCaseNumber>" + str(i.LoadCase) + "</LoadCaseNumber>\n")
                    SurfaceLoads.append("<Description>" + i.Description + "</Description>\n")
                    for j in i.PolyCurve.points:
                        SurfaceLoads.append("<NodeX>" + str(j.x) + "</NodeX>\n")
                        SurfaceLoads.append("<NodeY>" + str(j.y) + "</NodeY>\n")
                        SurfaceLoads.append("<NodeZ>" + str(j.z) + "</NodeZ>\n")
                    SurfaceLoads.append("<Coordinate_system>" + i.crs + "</Coordinate_system>\n")
                    SurfaceLoads.append("<Direction>" + i.direction + "</Direction>\n")
                    SurfaceLoads.append("<LoadBearingDirection>" + i.LoadBearingDirection + "</LoadBearingDirection>\n")
                    SurfaceLoads.append("<q1>" + str(i.q1) + "</q1>\n")
                    SurfaceLoads.append("<q2>" + str(i.q2) + "</q2>\n")
                    SurfaceLoads.append("<q3>" + str(i.q3) + "</q3>\n")
                    SurfaceLoads.append("<LoadConstantOrLinear>" + i.LoadConstantOrLinear + "</LoadConstantOrLinear>\n")
                    SurfaceLoads.append("<iq1>" + str(i.iq1) + "</iq1>\n")
                    SurfaceLoads.append("<iq2>" + str(i.iq2) + "</iq2>\n")
                    SurfaceLoads.append("<iq3>" + str(i.iq3) + "</iq3>\n")
                else:
                    pass
        SurfaceLoads.append("</SurfaceLoads>\n")
        self.SurfaceLoads = ''.join(str(SL) for SL in SurfaceLoads)

    def addPanels(self,obj=None):
        Panels = []
        Panels.append("<Panels>\n")
        if obj != None:
            slN = 0
            for i in obj:
                nm = i.__class__.__name__
                if nm == "LoadPanel":
                    slN = slN + 1
                    Panels.append("<Number>" + str(slN) + "</Number>\n")
                    Panels.append("<Description>" + i.Description + "</Description>\n")
                    for j in i.PolyCurve.points:
                        Panels.append("<NodeX>" + str(j.x) + "</NodeX>\n")
                        Panels.append("<NodeY>" + str(j.y) + "</NodeY>\n")
                        Panels.append("<NodeZ>" + str(j.z) + "</NodeZ>\n")
                    Panels.append("<LoadBearingDirection>" + i.LoadBearingDirection + "</LoadBearingDirection>\n")
                    Panels.append("<SurfaceType>" + i.LoadBearingDirection + "</SurfaceType>\n")
                else:
                    pass
        Panels.append("</Panels>\n")
        self.Panels = ''.join(str(pan) for pan in Panels)

    def addProject(self,projectname):
        self.Project = "<ProjectName>" + projectname + "</ProjectName>"

    def addprojectnumber(self,ProjectNumber):
        self.ProjectNumber = "<ProjectNumber>" + ProjectNumber + "</ProjectNumber>\n"

    def XML(self):
        self.xmlstr = self.Frame1 + self.Project + self.ProjectNumber + self.ExportDate + self.XMLVersion + self.Nodes + self.Supports + self.Grids + self.Profiles + self.Beamgroup + self.Beams + self.Plates + self.Panels + self.LoadCases + self.BeamLoads + self.NodeLoads + self.SurfaceLoads + self.Combinations + self.RebarLongitudinal + self.RebarStirrup + self.Layers + self.Frame2

    def __str__(self):
        return f"{__class__.__name__}(" + f"{self.xmlstr})"


class LoadXML:
    def __init__(self, filename=str, project=BuildingPy):
        self.filename = filename
        self.project = project
        self.unrecognizedElements = []
        
        self.root = self.load()
        if self.root != None:
            self.getStaaf()
            if len(self.unrecognizedElements) != 0:
                print(f"Unrecognized objects: {self.unrecognizedElements}")


    def load(self):
        try:
            tree = ET.parse(self.filename)
            root = tree.getroot()
            return root
        except Exception as e:
            print(e)
            return None


    def getAllKnoop(self):
        tableName = "EP_DSG_Elements.EP_StructNode.1"
        for container in self.root:
            for table in container:
                if table.attrib["t"] == tableName:
                    for obj in table:
                        if obj.tag == "{http://www.scia.cz}h":
                            for header in obj:
                                # print(header.attrib["t"])
                                pass
                        else:
                            pass
                            # print(obj.attrib["nm"])


    def findKnoop(self, name):
        tableName = "EP_DSG_Elements.EP_StructNode.1"
        for container in self.root:
            for table in container:
                if table.attrib["t"] == tableName:
                    for obj in table.iter("{http://www.scia.cz}obj"):
                        if obj.attrib["nm"] == name:
                            x, y, z = float(obj[1].attrib["v"])*self.project.scale, float(obj[2].attrib["v"])*self.project.scale, float(obj[3].attrib["v"])*self.project.scale
                            return Point(x,y,z)

    def convertJustification(self, justification):
        justification = justification.lower()
        if justification == "left" or justification == "links":
            return "center", "right"
        elif justification == "right" or justification == "rechts":
            return "center", "left"
        elif justification == "top" or justification == "boven":
            return "top", "center"
        elif justification == "bottom" or justification == "onder":
            return "bottom", "center"
        elif justification == "top left" or justification == "linksboven":
            return "top", "right"
        elif justification == "top right" or justification == "rechtsboven":
            return "top", "left"
        elif justification == "bottom left" or justification == "linksonder":
            return "bottom", "right"
        elif justification == "bottom right" or justification == "rechtsonder":
            return "bottom", "left"
        elif justification == "center" or justification == "midden" or justification == "centre":
            return "center", "center"
        else:
            print(f"Justification: [{justification}] not recognized")
            return "center", "center"

    def getStaaf(self):
        tableName = "EP_DSG_Elements.EP_Beam.1"
        h0 = "Naam"
        h1 = "Laag"
        h2 = "Loodrecht uitlijning"
        h3 = "LCS-rotatie"
        h3Index = None

        h4 = "Beginknoop"
        h4Index = None

        h5 = "Eindknoop"
        h5Index = None

        h6 = "Doorsnede"
        h6Index = None

        h7 = "EEM-type"

        h8 = "Staafsysteemlijn op"
        h8Index = None

        h9 = "ey"
        h9Index = None

        h10= "ez"
        h10Index = None

        h11 = "Tabel van geometrie"

        removeLayers = ["dummy"]

        for container in self.root:
            for table in container:
                if table.attrib["t"] == tableName:
                    for obj in table:
                        if obj.tag == "{http://www.scia.cz}h":
                            for index, header in enumerate(obj):
                                if header.attrib["t"] == h3:
                                    h3Index = index
                                if header.attrib["t"] == h4:
                                    h4Index = index
                                elif header.attrib["t"] == h5:
                                    h5Index = index
                                elif header.attrib["t"] == h6:
                                    h6Index = index
                                elif header.attrib["t"] == h8:
                                    h8Index = index
                                elif header.attrib["t"] == h9:
                                    h9Index = index
                                elif header.attrib["t"] == h10:
                                    h10Index = index
                        else:
                            rotationRAD = obj[h3Index].attrib["v"]
                            rotationDEG = (float(rotationRAD)*float(180) / math.pi) * -1
                            # print(rotationDEG)
                            Yjustification, Xjustification = self.convertJustification(obj[h8Index].attrib["t"])
                            p1 = self.findKnoop(obj[h4Index].attrib["n"])
                            p2 = self.findKnoop(obj[h5Index].attrib["n"])
                            #TEMP
                            p1 = Point(p1.x-0.00000000001, p1.y, p1.z)

                            ey = float(obj[h9Index].attrib["v"]) * -project.scale
                            ez = float(obj[h10Index].attrib["v"]) * project.scale
                            
                            lineSeg = Line(start=p1, end=p2)
                            
                            elementType = (obj[h6Index].attrib["n"])
                            for removeLayer in removeLayers:
                                if removeLayer.lower() in elementType.lower():
                                    # print(f"[removeLayers]: {elementType}")
                                    pass
                                else:
                                    elementType = elementType.split("-")[1].strip()
                                    self.project.objects.append(lineSeg)
                                    # self.project.objects.append(Frame.byStartpointEndpointProfileName(p1, p2, elementType, elementType, BaseSteel))
                                    try:
                                        self.project.objects.append(Frame.byStartpointEndpointProfileNameJustifiction(p1, p2, elementType, elementType, Xjustification, Yjustification, rotationDEG, BaseSteel, ey, ez))                                        
                                    except Exception as e:
                                        if elementType not in self.unrecognizedElements:
                                            self.unrecognizedElements.append(elementType)
                                        print(e, elementType)

outlist = []
def run():
    project = BuildingPy("TempCommit", "0")
    # LoadXML(IN[0], project)

    LoadXML(r"C:\Users\Jonathan\Documents\GitHub\building.py\temp\Scia\Examples buildingpy\scia_temp.xml", project)
    for obj in project.objects:
        print(obj.type)
    return project.objects

OUT = run()
print(OUT)